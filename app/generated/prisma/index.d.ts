
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AuditAccess
 * 
 */
export type AuditAccess = $Result.DefaultSelection<Prisma.$AuditAccessPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Warehouse
 * 
 */
export type Warehouse = $Result.DefaultSelection<Prisma.$WarehousePayload>
/**
 * Model UserWarehouse
 * 
 */
export type UserWarehouse = $Result.DefaultSelection<Prisma.$UserWarehousePayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model UnitConversion
 * 
 */
export type UnitConversion = $Result.DefaultSelection<Prisma.$UnitConversionPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model FiscalYear
 * 
 */
export type FiscalYear = $Result.DefaultSelection<Prisma.$FiscalYearPayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Variant
 * 
 */
export type Variant = $Result.DefaultSelection<Prisma.$VariantPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model Operator
 * 
 */
export type Operator = $Result.DefaultSelection<Prisma.$OperatorPayload>
/**
 * Model Machine
 * 
 */
export type Machine = $Result.DefaultSelection<Prisma.$MachinePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model JournalEntry
 * 
 */
export type JournalEntry = $Result.DefaultSelection<Prisma.$JournalEntryPayload>
/**
 * Model JournalLine
 * 
 */
export type JournalLine = $Result.DefaultSelection<Prisma.$JournalLinePayload>
/**
 * Model VoucherSequence
 * 
 */
export type VoucherSequence = $Result.DefaultSelection<Prisma.$VoucherSequencePayload>
/**
 * Model ItemGroup
 * 
 */
export type ItemGroup = $Result.DefaultSelection<Prisma.$ItemGroupPayload>
/**
 * Model Color
 * 
 */
export type Color = $Result.DefaultSelection<Prisma.$ColorPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model ItemGrade
 * 
 */
export type ItemGrade = $Result.DefaultSelection<Prisma.$ItemGradePayload>
/**
 * Model PackingUnit
 * 
 */
export type PackingUnit = $Result.DefaultSelection<Prisma.$PackingUnitPayload>
/**
 * Model ItemMaster
 * 
 */
export type ItemMaster = $Result.DefaultSelection<Prisma.$ItemMasterPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderItem
 * 
 */
export type PurchaseOrderItem = $Result.DefaultSelection<Prisma.$PurchaseOrderItemPayload>
/**
 * Model GRN
 * 
 */
export type GRN = $Result.DefaultSelection<Prisma.$GRNPayload>
/**
 * Model GRNItem
 * 
 */
export type GRNItem = $Result.DefaultSelection<Prisma.$GRNItemPayload>
/**
 * Model PurchaseInvoice
 * 
 */
export type PurchaseInvoice = $Result.DefaultSelection<Prisma.$PurchaseInvoicePayload>
/**
 * Model PurchaseInvoiceItem
 * 
 */
export type PurchaseInvoiceItem = $Result.DefaultSelection<Prisma.$PurchaseInvoiceItemPayload>
/**
 * Model PurchaseReturn
 * 
 */
export type PurchaseReturn = $Result.DefaultSelection<Prisma.$PurchaseReturnPayload>
/**
 * Model PurchaseReturnItem
 * 
 */
export type PurchaseReturnItem = $Result.DefaultSelection<Prisma.$PurchaseReturnItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ProductType: {
  YARN: 'YARN',
  FABRIC: 'FABRIC',
  PACKING_MATERIAL: 'PACKING_MATERIAL'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const AccountType: {
  ASSET: 'ASSET',
  LIABILITY: 'LIABILITY',
  EQUITY: 'EQUITY',
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const BalanceType: {
  DR: 'DR',
  CR: 'CR'
};

export type BalanceType = (typeof BalanceType)[keyof typeof BalanceType]


export const VoucherType: {
  JOURNAL: 'JOURNAL',
  PAYMENT: 'PAYMENT',
  RECEIPT: 'RECEIPT',
  PURCHASE: 'PURCHASE',
  SALES: 'SALES',
  CONTRA: 'CONTRA',
  PURCHASE_RETURN: 'PURCHASE_RETURN',
  SALES_RETURN: 'SALES_RETURN',
  OPENING: 'OPENING',
  CLOSING: 'CLOSING'
};

export type VoucherType = (typeof VoucherType)[keyof typeof VoucherType]


export const PurchaseOrderType: {
  LOCAL: 'LOCAL',
  IMPORT: 'IMPORT'
};

export type PurchaseOrderType = (typeof PurchaseOrderType)[keyof typeof PurchaseOrderType]


export const PurchaseOrderStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type PurchaseOrderStatus = (typeof PurchaseOrderStatus)[keyof typeof PurchaseOrderStatus]


export const PackingType: {
  EVEN: 'EVEN',
  UNEVEN: 'UNEVEN'
};

export type PackingType = (typeof PackingType)[keyof typeof PackingType]

}

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type BalanceType = $Enums.BalanceType

export const BalanceType: typeof $Enums.BalanceType

export type VoucherType = $Enums.VoucherType

export const VoucherType: typeof $Enums.VoucherType

export type PurchaseOrderType = $Enums.PurchaseOrderType

export const PurchaseOrderType: typeof $Enums.PurchaseOrderType

export type PurchaseOrderStatus = $Enums.PurchaseOrderStatus

export const PurchaseOrderStatus: typeof $Enums.PurchaseOrderStatus

export type PackingType = $Enums.PackingType

export const PackingType: typeof $Enums.PackingType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditAccess`: Exposes CRUD operations for the **AuditAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditAccesses
    * const auditAccesses = await prisma.auditAccess.findMany()
    * ```
    */
  get auditAccess(): Prisma.AuditAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warehouse`: Exposes CRUD operations for the **Warehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouse.findMany()
    * ```
    */
  get warehouse(): Prisma.WarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userWarehouse`: Exposes CRUD operations for the **UserWarehouse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserWarehouses
    * const userWarehouses = await prisma.userWarehouse.findMany()
    * ```
    */
  get userWarehouse(): Prisma.UserWarehouseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unitConversion`: Exposes CRUD operations for the **UnitConversion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitConversions
    * const unitConversions = await prisma.unitConversion.findMany()
    * ```
    */
  get unitConversion(): Prisma.UnitConversionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fiscalYear`: Exposes CRUD operations for the **FiscalYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FiscalYears
    * const fiscalYears = await prisma.fiscalYear.findMany()
    * ```
    */
  get fiscalYear(): Prisma.FiscalYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variant`: Exposes CRUD operations for the **Variant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variants
    * const variants = await prisma.variant.findMany()
    * ```
    */
  get variant(): Prisma.VariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operator`: Exposes CRUD operations for the **Operator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operators
    * const operators = await prisma.operator.findMany()
    * ```
    */
  get operator(): Prisma.OperatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.machine`: Exposes CRUD operations for the **Machine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Machines
    * const machines = await prisma.machine.findMany()
    * ```
    */
  get machine(): Prisma.MachineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalEntry`: Exposes CRUD operations for the **JournalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalEntries
    * const journalEntries = await prisma.journalEntry.findMany()
    * ```
    */
  get journalEntry(): Prisma.JournalEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalLine`: Exposes CRUD operations for the **JournalLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalLines
    * const journalLines = await prisma.journalLine.findMany()
    * ```
    */
  get journalLine(): Prisma.JournalLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucherSequence`: Exposes CRUD operations for the **VoucherSequence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoucherSequences
    * const voucherSequences = await prisma.voucherSequence.findMany()
    * ```
    */
  get voucherSequence(): Prisma.VoucherSequenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemGroup`: Exposes CRUD operations for the **ItemGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemGroups
    * const itemGroups = await prisma.itemGroup.findMany()
    * ```
    */
  get itemGroup(): Prisma.ItemGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.color`: Exposes CRUD operations for the **Color** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Colors
    * const colors = await prisma.color.findMany()
    * ```
    */
  get color(): Prisma.ColorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemGrade`: Exposes CRUD operations for the **ItemGrade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemGrades
    * const itemGrades = await prisma.itemGrade.findMany()
    * ```
    */
  get itemGrade(): Prisma.ItemGradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.packingUnit`: Exposes CRUD operations for the **PackingUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackingUnits
    * const packingUnits = await prisma.packingUnit.findMany()
    * ```
    */
  get packingUnit(): Prisma.PackingUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemMaster`: Exposes CRUD operations for the **ItemMaster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemMasters
    * const itemMasters = await prisma.itemMaster.findMany()
    * ```
    */
  get itemMaster(): Prisma.ItemMasterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrderItem`: Exposes CRUD operations for the **PurchaseOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderItems
    * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
    * ```
    */
  get purchaseOrderItem(): Prisma.PurchaseOrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gRN`: Exposes CRUD operations for the **GRN** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GRNS
    * const gRNS = await prisma.gRN.findMany()
    * ```
    */
  get gRN(): Prisma.GRNDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gRNItem`: Exposes CRUD operations for the **GRNItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GRNItems
    * const gRNItems = await prisma.gRNItem.findMany()
    * ```
    */
  get gRNItem(): Prisma.GRNItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseInvoice`: Exposes CRUD operations for the **PurchaseInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseInvoices
    * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
    * ```
    */
  get purchaseInvoice(): Prisma.PurchaseInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseInvoiceItem`: Exposes CRUD operations for the **PurchaseInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseInvoiceItems
    * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany()
    * ```
    */
  get purchaseInvoiceItem(): Prisma.PurchaseInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseReturn`: Exposes CRUD operations for the **PurchaseReturn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseReturns
    * const purchaseReturns = await prisma.purchaseReturn.findMany()
    * ```
    */
  get purchaseReturn(): Prisma.PurchaseReturnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseReturnItem`: Exposes CRUD operations for the **PurchaseReturnItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseReturnItems
    * const purchaseReturnItems = await prisma.purchaseReturnItem.findMany()
    * ```
    */
  get purchaseReturnItem(): Prisma.PurchaseReturnItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.1.0
   * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AuditAccess: 'AuditAccess',
    Department: 'Department',
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    UserRole: 'UserRole',
    Post: 'Post',
    RefreshToken: 'RefreshToken',
    AuditLog: 'AuditLog',
    Warehouse: 'Warehouse',
    UserWarehouse: 'UserWarehouse',
    Unit: 'Unit',
    UnitConversion: 'UnitConversion',
    Company: 'Company',
    FiscalYear: 'FiscalYear',
    Currency: 'Currency',
    SystemConfig: 'SystemConfig',
    SystemSetting: 'SystemSetting',
    Category: 'Category',
    Product: 'Product',
    Variant: 'Variant',
    Location: 'Location',
    Shift: 'Shift',
    Operator: 'Operator',
    Machine: 'Machine',
    Account: 'Account',
    JournalEntry: 'JournalEntry',
    JournalLine: 'JournalLine',
    VoucherSequence: 'VoucherSequence',
    ItemGroup: 'ItemGroup',
    Color: 'Color',
    Brand: 'Brand',
    ItemGrade: 'ItemGrade',
    PackingUnit: 'PackingUnit',
    ItemMaster: 'ItemMaster',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderItem: 'PurchaseOrderItem',
    GRN: 'GRN',
    GRNItem: 'GRNItem',
    PurchaseInvoice: 'PurchaseInvoice',
    PurchaseInvoiceItem: 'PurchaseInvoiceItem',
    PurchaseReturn: 'PurchaseReturn',
    PurchaseReturnItem: 'PurchaseReturnItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "auditAccess" | "department" | "role" | "permission" | "rolePermission" | "userRole" | "post" | "refreshToken" | "auditLog" | "warehouse" | "userWarehouse" | "unit" | "unitConversion" | "company" | "fiscalYear" | "currency" | "systemConfig" | "systemSetting" | "category" | "product" | "variant" | "location" | "shift" | "operator" | "machine" | "account" | "journalEntry" | "journalLine" | "voucherSequence" | "itemGroup" | "color" | "brand" | "itemGrade" | "packingUnit" | "itemMaster" | "purchaseOrder" | "purchaseOrderItem" | "gRN" | "gRNItem" | "purchaseInvoice" | "purchaseInvoiceItem" | "purchaseReturn" | "purchaseReturnItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AuditAccess: {
        payload: Prisma.$AuditAccessPayload<ExtArgs>
        fields: Prisma.AuditAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload>
          }
          findFirst: {
            args: Prisma.AuditAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload>
          }
          findMany: {
            args: Prisma.AuditAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload>[]
          }
          create: {
            args: Prisma.AuditAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload>
          }
          createMany: {
            args: Prisma.AuditAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload>[]
          }
          delete: {
            args: Prisma.AuditAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload>
          }
          update: {
            args: Prisma.AuditAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload>
          }
          deleteMany: {
            args: Prisma.AuditAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditAccessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload>[]
          }
          upsert: {
            args: Prisma.AuditAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditAccessPayload>
          }
          aggregate: {
            args: Prisma.AuditAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditAccess>
          }
          groupBy: {
            args: Prisma.AuditAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditAccessCountArgs<ExtArgs>
            result: $Utils.Optional<AuditAccessCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Warehouse: {
        payload: Prisma.$WarehousePayload<ExtArgs>
        fields: Prisma.WarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findFirst: {
            args: Prisma.WarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          findMany: {
            args: Prisma.WarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          create: {
            args: Prisma.WarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          createMany: {
            args: Prisma.WarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          delete: {
            args: Prisma.WarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          update: {
            args: Prisma.WarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          deleteMany: {
            args: Prisma.WarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>[]
          }
          upsert: {
            args: Prisma.WarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WarehousePayload>
          }
          aggregate: {
            args: Prisma.WarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarehouse>
          }
          groupBy: {
            args: Prisma.WarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<WarehouseCountAggregateOutputType> | number
          }
        }
      }
      UserWarehouse: {
        payload: Prisma.$UserWarehousePayload<ExtArgs>
        fields: Prisma.UserWarehouseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserWarehouseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserWarehouseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload>
          }
          findFirst: {
            args: Prisma.UserWarehouseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserWarehouseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload>
          }
          findMany: {
            args: Prisma.UserWarehouseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload>[]
          }
          create: {
            args: Prisma.UserWarehouseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload>
          }
          createMany: {
            args: Prisma.UserWarehouseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserWarehouseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload>[]
          }
          delete: {
            args: Prisma.UserWarehouseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload>
          }
          update: {
            args: Prisma.UserWarehouseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload>
          }
          deleteMany: {
            args: Prisma.UserWarehouseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserWarehouseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserWarehouseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload>[]
          }
          upsert: {
            args: Prisma.UserWarehouseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWarehousePayload>
          }
          aggregate: {
            args: Prisma.UserWarehouseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserWarehouse>
          }
          groupBy: {
            args: Prisma.UserWarehouseGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserWarehouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserWarehouseCountArgs<ExtArgs>
            result: $Utils.Optional<UserWarehouseCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      UnitConversion: {
        payload: Prisma.$UnitConversionPayload<ExtArgs>
        fields: Prisma.UnitConversionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitConversionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitConversionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload>
          }
          findFirst: {
            args: Prisma.UnitConversionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitConversionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload>
          }
          findMany: {
            args: Prisma.UnitConversionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload>[]
          }
          create: {
            args: Prisma.UnitConversionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload>
          }
          createMany: {
            args: Prisma.UnitConversionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitConversionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload>[]
          }
          delete: {
            args: Prisma.UnitConversionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload>
          }
          update: {
            args: Prisma.UnitConversionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload>
          }
          deleteMany: {
            args: Prisma.UnitConversionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitConversionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitConversionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload>[]
          }
          upsert: {
            args: Prisma.UnitConversionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitConversionPayload>
          }
          aggregate: {
            args: Prisma.UnitConversionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnitConversion>
          }
          groupBy: {
            args: Prisma.UnitConversionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitConversionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitConversionCountArgs<ExtArgs>
            result: $Utils.Optional<UnitConversionCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      FiscalYear: {
        payload: Prisma.$FiscalYearPayload<ExtArgs>
        fields: Prisma.FiscalYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FiscalYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FiscalYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          findFirst: {
            args: Prisma.FiscalYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FiscalYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          findMany: {
            args: Prisma.FiscalYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>[]
          }
          create: {
            args: Prisma.FiscalYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          createMany: {
            args: Prisma.FiscalYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FiscalYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>[]
          }
          delete: {
            args: Prisma.FiscalYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          update: {
            args: Prisma.FiscalYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          deleteMany: {
            args: Prisma.FiscalYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FiscalYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FiscalYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>[]
          }
          upsert: {
            args: Prisma.FiscalYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FiscalYearPayload>
          }
          aggregate: {
            args: Prisma.FiscalYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiscalYear>
          }
          groupBy: {
            args: Prisma.FiscalYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<FiscalYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.FiscalYearCountArgs<ExtArgs>
            result: $Utils.Optional<FiscalYearCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Variant: {
        payload: Prisma.$VariantPayload<ExtArgs>
        fields: Prisma.VariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          findFirst: {
            args: Prisma.VariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          findMany: {
            args: Prisma.VariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>[]
          }
          create: {
            args: Prisma.VariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          createMany: {
            args: Prisma.VariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>[]
          }
          delete: {
            args: Prisma.VariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          update: {
            args: Prisma.VariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          deleteMany: {
            args: Prisma.VariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>[]
          }
          upsert: {
            args: Prisma.VariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          aggregate: {
            args: Prisma.VariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariant>
          }
          groupBy: {
            args: Prisma.VariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariantCountArgs<ExtArgs>
            result: $Utils.Optional<VariantCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      Operator: {
        payload: Prisma.$OperatorPayload<ExtArgs>
        fields: Prisma.OperatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          findFirst: {
            args: Prisma.OperatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          findMany: {
            args: Prisma.OperatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          create: {
            args: Prisma.OperatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          createMany: {
            args: Prisma.OperatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          delete: {
            args: Prisma.OperatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          update: {
            args: Prisma.OperatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          deleteMany: {
            args: Prisma.OperatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>[]
          }
          upsert: {
            args: Prisma.OperatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperatorPayload>
          }
          aggregate: {
            args: Prisma.OperatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperator>
          }
          groupBy: {
            args: Prisma.OperatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperatorCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorCountAggregateOutputType> | number
          }
        }
      }
      Machine: {
        payload: Prisma.$MachinePayload<ExtArgs>
        fields: Prisma.MachineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MachineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MachineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findFirst: {
            args: Prisma.MachineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MachineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          findMany: {
            args: Prisma.MachineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          create: {
            args: Prisma.MachineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          createMany: {
            args: Prisma.MachineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MachineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          delete: {
            args: Prisma.MachineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          update: {
            args: Prisma.MachineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          deleteMany: {
            args: Prisma.MachineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MachineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MachineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>[]
          }
          upsert: {
            args: Prisma.MachineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MachinePayload>
          }
          aggregate: {
            args: Prisma.MachineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachine>
          }
          groupBy: {
            args: Prisma.MachineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MachineCountArgs<ExtArgs>
            result: $Utils.Optional<MachineCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      JournalEntry: {
        payload: Prisma.$JournalEntryPayload<ExtArgs>
        fields: Prisma.JournalEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findFirst: {
            args: Prisma.JournalEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findMany: {
            args: Prisma.JournalEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          create: {
            args: Prisma.JournalEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          createMany: {
            args: Prisma.JournalEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          delete: {
            args: Prisma.JournalEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          update: {
            args: Prisma.JournalEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          deleteMany: {
            args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          upsert: {
            args: Prisma.JournalEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          aggregate: {
            args: Prisma.JournalEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalEntry>
          }
          groupBy: {
            args: Prisma.JournalEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalEntryCountArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryCountAggregateOutputType> | number
          }
        }
      }
      JournalLine: {
        payload: Prisma.$JournalLinePayload<ExtArgs>
        fields: Prisma.JournalLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findFirst: {
            args: Prisma.JournalLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          findMany: {
            args: Prisma.JournalLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          create: {
            args: Prisma.JournalLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          createMany: {
            args: Prisma.JournalLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          delete: {
            args: Prisma.JournalLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          update: {
            args: Prisma.JournalLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          deleteMany: {
            args: Prisma.JournalLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>[]
          }
          upsert: {
            args: Prisma.JournalLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalLinePayload>
          }
          aggregate: {
            args: Prisma.JournalLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalLine>
          }
          groupBy: {
            args: Prisma.JournalLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalLineCountArgs<ExtArgs>
            result: $Utils.Optional<JournalLineCountAggregateOutputType> | number
          }
        }
      }
      VoucherSequence: {
        payload: Prisma.$VoucherSequencePayload<ExtArgs>
        fields: Prisma.VoucherSequenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherSequenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherSequenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload>
          }
          findFirst: {
            args: Prisma.VoucherSequenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherSequenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload>
          }
          findMany: {
            args: Prisma.VoucherSequenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload>[]
          }
          create: {
            args: Prisma.VoucherSequenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload>
          }
          createMany: {
            args: Prisma.VoucherSequenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherSequenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload>[]
          }
          delete: {
            args: Prisma.VoucherSequenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload>
          }
          update: {
            args: Prisma.VoucherSequenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload>
          }
          deleteMany: {
            args: Prisma.VoucherSequenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherSequenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherSequenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload>[]
          }
          upsert: {
            args: Prisma.VoucherSequenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherSequencePayload>
          }
          aggregate: {
            args: Prisma.VoucherSequenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucherSequence>
          }
          groupBy: {
            args: Prisma.VoucherSequenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherSequenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherSequenceCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherSequenceCountAggregateOutputType> | number
          }
        }
      }
      ItemGroup: {
        payload: Prisma.$ItemGroupPayload<ExtArgs>
        fields: Prisma.ItemGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload>
          }
          findFirst: {
            args: Prisma.ItemGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload>
          }
          findMany: {
            args: Prisma.ItemGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload>[]
          }
          create: {
            args: Prisma.ItemGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload>
          }
          createMany: {
            args: Prisma.ItemGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload>[]
          }
          delete: {
            args: Prisma.ItemGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload>
          }
          update: {
            args: Prisma.ItemGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload>
          }
          deleteMany: {
            args: Prisma.ItemGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload>[]
          }
          upsert: {
            args: Prisma.ItemGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGroupPayload>
          }
          aggregate: {
            args: Prisma.ItemGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemGroup>
          }
          groupBy: {
            args: Prisma.ItemGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemGroupCountArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupCountAggregateOutputType> | number
          }
        }
      }
      Color: {
        payload: Prisma.$ColorPayload<ExtArgs>
        fields: Prisma.ColorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          findFirst: {
            args: Prisma.ColorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          findMany: {
            args: Prisma.ColorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>[]
          }
          create: {
            args: Prisma.ColorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          createMany: {
            args: Prisma.ColorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ColorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>[]
          }
          delete: {
            args: Prisma.ColorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          update: {
            args: Prisma.ColorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          deleteMany: {
            args: Prisma.ColorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ColorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>[]
          }
          upsert: {
            args: Prisma.ColorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          aggregate: {
            args: Prisma.ColorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColor>
          }
          groupBy: {
            args: Prisma.ColorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColorCountArgs<ExtArgs>
            result: $Utils.Optional<ColorCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      ItemGrade: {
        payload: Prisma.$ItemGradePayload<ExtArgs>
        fields: Prisma.ItemGradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemGradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemGradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload>
          }
          findFirst: {
            args: Prisma.ItemGradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemGradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload>
          }
          findMany: {
            args: Prisma.ItemGradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload>[]
          }
          create: {
            args: Prisma.ItemGradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload>
          }
          createMany: {
            args: Prisma.ItemGradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemGradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload>[]
          }
          delete: {
            args: Prisma.ItemGradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload>
          }
          update: {
            args: Prisma.ItemGradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload>
          }
          deleteMany: {
            args: Prisma.ItemGradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemGradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemGradeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload>[]
          }
          upsert: {
            args: Prisma.ItemGradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemGradePayload>
          }
          aggregate: {
            args: Prisma.ItemGradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemGrade>
          }
          groupBy: {
            args: Prisma.ItemGradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemGradeCountArgs<ExtArgs>
            result: $Utils.Optional<ItemGradeCountAggregateOutputType> | number
          }
        }
      }
      PackingUnit: {
        payload: Prisma.$PackingUnitPayload<ExtArgs>
        fields: Prisma.PackingUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackingUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackingUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload>
          }
          findFirst: {
            args: Prisma.PackingUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackingUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload>
          }
          findMany: {
            args: Prisma.PackingUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload>[]
          }
          create: {
            args: Prisma.PackingUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload>
          }
          createMany: {
            args: Prisma.PackingUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackingUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload>[]
          }
          delete: {
            args: Prisma.PackingUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload>
          }
          update: {
            args: Prisma.PackingUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload>
          }
          deleteMany: {
            args: Prisma.PackingUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackingUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackingUnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload>[]
          }
          upsert: {
            args: Prisma.PackingUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackingUnitPayload>
          }
          aggregate: {
            args: Prisma.PackingUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackingUnit>
          }
          groupBy: {
            args: Prisma.PackingUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackingUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackingUnitCountArgs<ExtArgs>
            result: $Utils.Optional<PackingUnitCountAggregateOutputType> | number
          }
        }
      }
      ItemMaster: {
        payload: Prisma.$ItemMasterPayload<ExtArgs>
        fields: Prisma.ItemMasterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemMasterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemMasterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload>
          }
          findFirst: {
            args: Prisma.ItemMasterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemMasterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload>
          }
          findMany: {
            args: Prisma.ItemMasterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload>[]
          }
          create: {
            args: Prisma.ItemMasterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload>
          }
          createMany: {
            args: Prisma.ItemMasterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemMasterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload>[]
          }
          delete: {
            args: Prisma.ItemMasterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload>
          }
          update: {
            args: Prisma.ItemMasterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload>
          }
          deleteMany: {
            args: Prisma.ItemMasterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemMasterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemMasterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload>[]
          }
          upsert: {
            args: Prisma.ItemMasterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemMasterPayload>
          }
          aggregate: {
            args: Prisma.ItemMasterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemMaster>
          }
          groupBy: {
            args: Prisma.ItemMasterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemMasterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemMasterCountArgs<ExtArgs>
            result: $Utils.Optional<ItemMasterCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderItem: {
        payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
        fields: Prisma.PurchaseOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          update: {
            args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderItem>
          }
          groupBy: {
            args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemCountAggregateOutputType> | number
          }
        }
      }
      GRN: {
        payload: Prisma.$GRNPayload<ExtArgs>
        fields: Prisma.GRNFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GRNFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GRNFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          findFirst: {
            args: Prisma.GRNFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GRNFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          findMany: {
            args: Prisma.GRNFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>[]
          }
          create: {
            args: Prisma.GRNCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          createMany: {
            args: Prisma.GRNCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GRNCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>[]
          }
          delete: {
            args: Prisma.GRNDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          update: {
            args: Prisma.GRNUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          deleteMany: {
            args: Prisma.GRNDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GRNUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GRNUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>[]
          }
          upsert: {
            args: Prisma.GRNUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          aggregate: {
            args: Prisma.GRNAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGRN>
          }
          groupBy: {
            args: Prisma.GRNGroupByArgs<ExtArgs>
            result: $Utils.Optional<GRNGroupByOutputType>[]
          }
          count: {
            args: Prisma.GRNCountArgs<ExtArgs>
            result: $Utils.Optional<GRNCountAggregateOutputType> | number
          }
        }
      }
      GRNItem: {
        payload: Prisma.$GRNItemPayload<ExtArgs>
        fields: Prisma.GRNItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GRNItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GRNItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload>
          }
          findFirst: {
            args: Prisma.GRNItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GRNItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload>
          }
          findMany: {
            args: Prisma.GRNItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload>[]
          }
          create: {
            args: Prisma.GRNItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload>
          }
          createMany: {
            args: Prisma.GRNItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GRNItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload>[]
          }
          delete: {
            args: Prisma.GRNItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload>
          }
          update: {
            args: Prisma.GRNItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload>
          }
          deleteMany: {
            args: Prisma.GRNItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GRNItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GRNItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload>[]
          }
          upsert: {
            args: Prisma.GRNItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNItemPayload>
          }
          aggregate: {
            args: Prisma.GRNItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGRNItem>
          }
          groupBy: {
            args: Prisma.GRNItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<GRNItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.GRNItemCountArgs<ExtArgs>
            result: $Utils.Optional<GRNItemCountAggregateOutputType> | number
          }
        }
      }
      PurchaseInvoice: {
        payload: Prisma.$PurchaseInvoicePayload<ExtArgs>
        fields: Prisma.PurchaseInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findFirst: {
            args: Prisma.PurchaseInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findMany: {
            args: Prisma.PurchaseInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          create: {
            args: Prisma.PurchaseInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          createMany: {
            args: Prisma.PurchaseInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          delete: {
            args: Prisma.PurchaseInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          update: {
            args: Prisma.PurchaseInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          aggregate: {
            args: Prisma.PurchaseInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseInvoice>
          }
          groupBy: {
            args: Prisma.PurchaseInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceCountAggregateOutputType> | number
          }
        }
      }
      PurchaseInvoiceItem: {
        payload: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>
        fields: Prisma.PurchaseInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          update: {
            args: Prisma.PurchaseInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseInvoiceItem>
          }
          groupBy: {
            args: Prisma.PurchaseInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      PurchaseReturn: {
        payload: Prisma.$PurchaseReturnPayload<ExtArgs>
        fields: Prisma.PurchaseReturnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseReturnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseReturnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload>
          }
          findFirst: {
            args: Prisma.PurchaseReturnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseReturnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload>
          }
          findMany: {
            args: Prisma.PurchaseReturnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload>[]
          }
          create: {
            args: Prisma.PurchaseReturnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload>
          }
          createMany: {
            args: Prisma.PurchaseReturnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseReturnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload>[]
          }
          delete: {
            args: Prisma.PurchaseReturnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload>
          }
          update: {
            args: Prisma.PurchaseReturnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseReturnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseReturnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseReturnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseReturnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnPayload>
          }
          aggregate: {
            args: Prisma.PurchaseReturnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseReturn>
          }
          groupBy: {
            args: Prisma.PurchaseReturnGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseReturnCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnCountAggregateOutputType> | number
          }
        }
      }
      PurchaseReturnItem: {
        payload: Prisma.$PurchaseReturnItemPayload<ExtArgs>
        fields: Prisma.PurchaseReturnItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseReturnItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseReturnItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseReturnItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseReturnItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseReturnItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseReturnItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseReturnItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseReturnItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseReturnItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload>
          }
          update: {
            args: Prisma.PurchaseReturnItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseReturnItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseReturnItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseReturnItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseReturnItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseReturnItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseReturnItem>
          }
          groupBy: {
            args: Prisma.PurchaseReturnItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseReturnItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    auditAccess?: AuditAccessOmit
    department?: DepartmentOmit
    role?: RoleOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
    userRole?: UserRoleOmit
    post?: PostOmit
    refreshToken?: RefreshTokenOmit
    auditLog?: AuditLogOmit
    warehouse?: WarehouseOmit
    userWarehouse?: UserWarehouseOmit
    unit?: UnitOmit
    unitConversion?: UnitConversionOmit
    company?: CompanyOmit
    fiscalYear?: FiscalYearOmit
    currency?: CurrencyOmit
    systemConfig?: SystemConfigOmit
    systemSetting?: SystemSettingOmit
    category?: CategoryOmit
    product?: ProductOmit
    variant?: VariantOmit
    location?: LocationOmit
    shift?: ShiftOmit
    operator?: OperatorOmit
    machine?: MachineOmit
    account?: AccountOmit
    journalEntry?: JournalEntryOmit
    journalLine?: JournalLineOmit
    voucherSequence?: VoucherSequenceOmit
    itemGroup?: ItemGroupOmit
    color?: ColorOmit
    brand?: BrandOmit
    itemGrade?: ItemGradeOmit
    packingUnit?: PackingUnitOmit
    itemMaster?: ItemMasterOmit
    purchaseOrder?: PurchaseOrderOmit
    purchaseOrderItem?: PurchaseOrderItemOmit
    gRN?: GRNOmit
    gRNItem?: GRNItemOmit
    purchaseInvoice?: PurchaseInvoiceOmit
    purchaseInvoiceItem?: PurchaseInvoiceItemOmit
    purchaseReturn?: PurchaseReturnOmit
    purchaseReturnItem?: PurchaseReturnItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    posts: number
    refreshTokens: number
    auditLogs: number
    auditLogPermissions: number
    visibleToAudit: number
    userRoles: number
    userWarehouses: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    auditLogPermissions?: boolean | UserCountOutputTypeCountAuditLogPermissionsArgs
    visibleToAudit?: boolean | UserCountOutputTypeCountVisibleToAuditArgs
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    userWarehouses?: boolean | UserCountOutputTypeCountUserWarehousesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditAccessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVisibleToAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditAccessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserWarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWarehouseWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    users: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | DepartmentCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number
    permissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type WarehouseCountOutputType
   */

  export type WarehouseCountOutputType = {
    userWarehouses: number
    purchaseOrders: number
  }

  export type WarehouseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userWarehouses?: boolean | WarehouseCountOutputTypeCountUserWarehousesArgs
    purchaseOrders?: boolean | WarehouseCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseCountOutputType
     */
    select?: WarehouseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountUserWarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWarehouseWhereInput
  }

  /**
   * WarehouseCountOutputType without action
   */
  export type WarehouseCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    conversionsFrom: number
    conversionsTo: number
    products: number
    itemMasters: number
    purchaseOrderItems: number
    grnItems: number
    purchaseInvoiceItems: number
    purchaseReturnItems: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversionsFrom?: boolean | UnitCountOutputTypeCountConversionsFromArgs
    conversionsTo?: boolean | UnitCountOutputTypeCountConversionsToArgs
    products?: boolean | UnitCountOutputTypeCountProductsArgs
    itemMasters?: boolean | UnitCountOutputTypeCountItemMastersArgs
    purchaseOrderItems?: boolean | UnitCountOutputTypeCountPurchaseOrderItemsArgs
    grnItems?: boolean | UnitCountOutputTypeCountGrnItemsArgs
    purchaseInvoiceItems?: boolean | UnitCountOutputTypeCountPurchaseInvoiceItemsArgs
    purchaseReturnItems?: boolean | UnitCountOutputTypeCountPurchaseReturnItemsArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountConversionsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitConversionWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountConversionsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitConversionWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountItemMastersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemMasterWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountGrnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNItemWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountPurchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountPurchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    itemGroups: number
    colors: number
    brands: number
    units: number
    itemGrades: number
    unitConversions: number
    itemMasters: number
    purchaseOrders: number
    grns: number
    purchaseInvoices: number
    purchaseReturns: number
    packingUnits: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemGroups?: boolean | CompanyCountOutputTypeCountItemGroupsArgs
    colors?: boolean | CompanyCountOutputTypeCountColorsArgs
    brands?: boolean | CompanyCountOutputTypeCountBrandsArgs
    units?: boolean | CompanyCountOutputTypeCountUnitsArgs
    itemGrades?: boolean | CompanyCountOutputTypeCountItemGradesArgs
    unitConversions?: boolean | CompanyCountOutputTypeCountUnitConversionsArgs
    itemMasters?: boolean | CompanyCountOutputTypeCountItemMastersArgs
    purchaseOrders?: boolean | CompanyCountOutputTypeCountPurchaseOrdersArgs
    grns?: boolean | CompanyCountOutputTypeCountGrnsArgs
    purchaseInvoices?: boolean | CompanyCountOutputTypeCountPurchaseInvoicesArgs
    purchaseReturns?: boolean | CompanyCountOutputTypeCountPurchaseReturnsArgs
    packingUnits?: boolean | CompanyCountOutputTypeCountPackingUnitsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountItemGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemGroupWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountColorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColorWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountItemGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemGradeWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUnitConversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitConversionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountItemMastersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemMasterWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountGrnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPurchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPurchaseReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountPackingUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackingUnitWhereInput
  }


  /**
   * Count Type FiscalYearCountOutputType
   */

  export type FiscalYearCountOutputType = {
    journalEntries: number
  }

  export type FiscalYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalEntries?: boolean | FiscalYearCountOutputTypeCountJournalEntriesArgs
  }

  // Custom InputTypes
  /**
   * FiscalYearCountOutputType without action
   */
  export type FiscalYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYearCountOutputType
     */
    select?: FiscalYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FiscalYearCountOutputType without action
   */
  export type FiscalYearCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    purchaseOrders: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrders?: boolean | CurrencyCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    variants: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    machines: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machines?: boolean | LocationCountOutputTypeCountMachinesArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountMachinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    children: number
    journalLines: number
    purchaseOrders: number
    purchaseInvoices: number
    purchaseReturns: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | AccountCountOutputTypeCountChildrenArgs
    journalLines?: boolean | AccountCountOutputTypeCountJournalLinesArgs
    purchaseOrders?: boolean | AccountCountOutputTypeCountPurchaseOrdersArgs
    purchaseInvoices?: boolean | AccountCountOutputTypeCountPurchaseInvoicesArgs
    purchaseReturns?: boolean | AccountCountOutputTypeCountPurchaseReturnsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountJournalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPurchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPurchaseReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnWhereInput
  }


  /**
   * Count Type JournalEntryCountOutputType
   */

  export type JournalEntryCountOutputType = {
    lines: number
  }

  export type JournalEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | JournalEntryCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntryCountOutputType
     */
    select?: JournalEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalEntryCountOutputType without action
   */
  export type JournalEntryCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
  }


  /**
   * Count Type ItemGroupCountOutputType
   */

  export type ItemGroupCountOutputType = {
    children: number
    itemMasters: number
  }

  export type ItemGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ItemGroupCountOutputTypeCountChildrenArgs
    itemMasters?: boolean | ItemGroupCountOutputTypeCountItemMastersArgs
  }

  // Custom InputTypes
  /**
   * ItemGroupCountOutputType without action
   */
  export type ItemGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroupCountOutputType
     */
    select?: ItemGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemGroupCountOutputType without action
   */
  export type ItemGroupCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemGroupWhereInput
  }

  /**
   * ItemGroupCountOutputType without action
   */
  export type ItemGroupCountOutputTypeCountItemMastersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemMasterWhereInput
  }


  /**
   * Count Type ColorCountOutputType
   */

  export type ColorCountOutputType = {
    purchaseOrderItems: number
    grnItems: number
    purchaseInvoiceItems: number
    purchaseReturnItems: number
  }

  export type ColorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrderItems?: boolean | ColorCountOutputTypeCountPurchaseOrderItemsArgs
    grnItems?: boolean | ColorCountOutputTypeCountGrnItemsArgs
    purchaseInvoiceItems?: boolean | ColorCountOutputTypeCountPurchaseInvoiceItemsArgs
    purchaseReturnItems?: boolean | ColorCountOutputTypeCountPurchaseReturnItemsArgs
  }

  // Custom InputTypes
  /**
   * ColorCountOutputType without action
   */
  export type ColorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorCountOutputType
     */
    select?: ColorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ColorCountOutputType without action
   */
  export type ColorCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * ColorCountOutputType without action
   */
  export type ColorCountOutputTypeCountGrnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNItemWhereInput
  }

  /**
   * ColorCountOutputType without action
   */
  export type ColorCountOutputTypeCountPurchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }

  /**
   * ColorCountOutputType without action
   */
  export type ColorCountOutputTypeCountPurchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    purchaseOrderItems: number
    grnItems: number
    purchaseInvoiceItems: number
    purchaseReturnItems: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrderItems?: boolean | BrandCountOutputTypeCountPurchaseOrderItemsArgs
    grnItems?: boolean | BrandCountOutputTypeCountGrnItemsArgs
    purchaseInvoiceItems?: boolean | BrandCountOutputTypeCountPurchaseInvoiceItemsArgs
    purchaseReturnItems?: boolean | BrandCountOutputTypeCountPurchaseReturnItemsArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountGrnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNItemWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountPurchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountPurchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemWhereInput
  }


  /**
   * Count Type ItemGradeCountOutputType
   */

  export type ItemGradeCountOutputType = {
    purchaseOrderItems: number
    grnItems: number
    purchaseInvoiceItems: number
    purchaseReturnItems: number
  }

  export type ItemGradeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrderItems?: boolean | ItemGradeCountOutputTypeCountPurchaseOrderItemsArgs
    grnItems?: boolean | ItemGradeCountOutputTypeCountGrnItemsArgs
    purchaseInvoiceItems?: boolean | ItemGradeCountOutputTypeCountPurchaseInvoiceItemsArgs
    purchaseReturnItems?: boolean | ItemGradeCountOutputTypeCountPurchaseReturnItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemGradeCountOutputType without action
   */
  export type ItemGradeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGradeCountOutputType
     */
    select?: ItemGradeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemGradeCountOutputType without action
   */
  export type ItemGradeCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * ItemGradeCountOutputType without action
   */
  export type ItemGradeCountOutputTypeCountGrnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNItemWhereInput
  }

  /**
   * ItemGradeCountOutputType without action
   */
  export type ItemGradeCountOutputTypeCountPurchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }

  /**
   * ItemGradeCountOutputType without action
   */
  export type ItemGradeCountOutputTypeCountPurchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemWhereInput
  }


  /**
   * Count Type PackingUnitCountOutputType
   */

  export type PackingUnitCountOutputType = {
    itemMasters: number
    purchaseOrderItems: number
    grnItems: number
  }

  export type PackingUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemMasters?: boolean | PackingUnitCountOutputTypeCountItemMastersArgs
    purchaseOrderItems?: boolean | PackingUnitCountOutputTypeCountPurchaseOrderItemsArgs
    grnItems?: boolean | PackingUnitCountOutputTypeCountGrnItemsArgs
  }

  // Custom InputTypes
  /**
   * PackingUnitCountOutputType without action
   */
  export type PackingUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnitCountOutputType
     */
    select?: PackingUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackingUnitCountOutputType without action
   */
  export type PackingUnitCountOutputTypeCountItemMastersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemMasterWhereInput
  }

  /**
   * PackingUnitCountOutputType without action
   */
  export type PackingUnitCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PackingUnitCountOutputType without action
   */
  export type PackingUnitCountOutputTypeCountGrnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNItemWhereInput
  }


  /**
   * Count Type ItemMasterCountOutputType
   */

  export type ItemMasterCountOutputType = {
    purchaseOrderItems: number
    grnItems: number
    purchaseInvoiceItems: number
    purchaseReturnItems: number
  }

  export type ItemMasterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrderItems?: boolean | ItemMasterCountOutputTypeCountPurchaseOrderItemsArgs
    grnItems?: boolean | ItemMasterCountOutputTypeCountGrnItemsArgs
    purchaseInvoiceItems?: boolean | ItemMasterCountOutputTypeCountPurchaseInvoiceItemsArgs
    purchaseReturnItems?: boolean | ItemMasterCountOutputTypeCountPurchaseReturnItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemMasterCountOutputType without action
   */
  export type ItemMasterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMasterCountOutputType
     */
    select?: ItemMasterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemMasterCountOutputType without action
   */
  export type ItemMasterCountOutputTypeCountPurchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * ItemMasterCountOutputType without action
   */
  export type ItemMasterCountOutputTypeCountGrnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNItemWhereInput
  }

  /**
   * ItemMasterCountOutputType without action
   */
  export type ItemMasterCountOutputTypeCountPurchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }

  /**
   * ItemMasterCountOutputType without action
   */
  export type ItemMasterCountOutputTypeCountPurchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    items: number
    grns: number
    invoices: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrderCountOutputTypeCountItemsArgs
    grns?: boolean | PurchaseOrderCountOutputTypeCountGrnsArgs
    invoices?: boolean | PurchaseOrderCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountGrnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
  }


  /**
   * Count Type PurchaseOrderItemCountOutputType
   */

  export type PurchaseOrderItemCountOutputType = {
    grnItems: number
    invoiceItems: number
  }

  export type PurchaseOrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grnItems?: boolean | PurchaseOrderItemCountOutputTypeCountGrnItemsArgs
    invoiceItems?: boolean | PurchaseOrderItemCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderItemCountOutputType without action
   */
  export type PurchaseOrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItemCountOutputType
     */
    select?: PurchaseOrderItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderItemCountOutputType without action
   */
  export type PurchaseOrderItemCountOutputTypeCountGrnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNItemWhereInput
  }

  /**
   * PurchaseOrderItemCountOutputType without action
   */
  export type PurchaseOrderItemCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }


  /**
   * Count Type GRNCountOutputType
   */

  export type GRNCountOutputType = {
    items: number
    purchaseReturns: number
  }

  export type GRNCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | GRNCountOutputTypeCountItemsArgs
    purchaseReturns?: boolean | GRNCountOutputTypeCountPurchaseReturnsArgs
  }

  // Custom InputTypes
  /**
   * GRNCountOutputType without action
   */
  export type GRNCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNCountOutputType
     */
    select?: GRNCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GRNCountOutputType without action
   */
  export type GRNCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNItemWhereInput
  }

  /**
   * GRNCountOutputType without action
   */
  export type GRNCountOutputTypeCountPurchaseReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnWhereInput
  }


  /**
   * Count Type GRNItemCountOutputType
   */

  export type GRNItemCountOutputType = {
    invoiceItems: number
  }

  export type GRNItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoiceItems?: boolean | GRNItemCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * GRNItemCountOutputType without action
   */
  export type GRNItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItemCountOutputType
     */
    select?: GRNItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GRNItemCountOutputType without action
   */
  export type GRNItemCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }


  /**
   * Count Type PurchaseInvoiceCountOutputType
   */

  export type PurchaseInvoiceCountOutputType = {
    items: number
    purchaseReturns: number
  }

  export type PurchaseInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseInvoiceCountOutputTypeCountItemsArgs
    purchaseReturns?: boolean | PurchaseInvoiceCountOutputTypeCountPurchaseReturnsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceCountOutputType
     */
    select?: PurchaseInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }

  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeCountPurchaseReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnWhereInput
  }


  /**
   * Count Type PurchaseReturnCountOutputType
   */

  export type PurchaseReturnCountOutputType = {
    items: number
  }

  export type PurchaseReturnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseReturnCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseReturnCountOutputType without action
   */
  export type PurchaseReturnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnCountOutputType
     */
    select?: PurchaseReturnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseReturnCountOutputType without action
   */
  export type PurchaseReturnCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    image: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    firstLogin: boolean | null
    forcePasswordChange: boolean | null
    isActive: boolean | null
    departmentId: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    image: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    firstLogin: boolean | null
    forcePasswordChange: boolean | null
    isActive: boolean | null
    departmentId: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    image: number
    password: number
    createdAt: number
    updatedAt: number
    firstLogin: number
    forcePasswordChange: number
    isActive: number
    departmentId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    firstLogin?: true
    forcePasswordChange?: true
    isActive?: true
    departmentId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    firstLogin?: true
    forcePasswordChange?: true
    isActive?: true
    departmentId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    image?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    firstLogin?: true
    forcePasswordChange?: true
    isActive?: true
    departmentId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string | null
    image: string | null
    password: string
    createdAt: Date
    updatedAt: Date
    firstLogin: boolean
    forcePasswordChange: boolean
    isActive: boolean
    departmentId: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: boolean
    posts?: boolean | User$postsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    auditLogPermissions?: boolean | User$auditLogPermissionsArgs<ExtArgs>
    visibleToAudit?: boolean | User$visibleToAuditArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    userWarehouses?: boolean | User$userWarehousesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: boolean
    department?: boolean | User$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    image?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "image" | "password" | "createdAt" | "updatedAt" | "firstLogin" | "forcePasswordChange" | "isActive" | "departmentId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | User$postsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    auditLogPermissions?: boolean | User$auditLogPermissionsArgs<ExtArgs>
    visibleToAudit?: boolean | User$visibleToAuditArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    userWarehouses?: boolean | User$userWarehousesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | User$departmentArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      auditLogPermissions: Prisma.$AuditAccessPayload<ExtArgs>[]
      visibleToAudit: Prisma.$AuditAccessPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      userWarehouses: Prisma.$UserWarehousePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string | null
      image: string | null
      password: string
      createdAt: Date
      updatedAt: Date
      firstLogin: boolean
      forcePasswordChange: boolean
      isActive: boolean
      departmentId: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department<T extends User$departmentArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    auditLogPermissions<T extends User$auditLogPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visibleToAudit<T extends User$visibleToAuditArgs<ExtArgs> = {}>(args?: Subset<T, User$visibleToAuditArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userWarehouses<T extends User$userWarehousesArgs<ExtArgs> = {}>(args?: Subset<T, User$userWarehousesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly firstLogin: FieldRef<"User", 'Boolean'>
    readonly forcePasswordChange: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly departmentId: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.department
   */
  export type User$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * User.auditLogPermissions
   */
  export type User$auditLogPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    where?: AuditAccessWhereInput
    orderBy?: AuditAccessOrderByWithRelationInput | AuditAccessOrderByWithRelationInput[]
    cursor?: AuditAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditAccessScalarFieldEnum | AuditAccessScalarFieldEnum[]
  }

  /**
   * User.visibleToAudit
   */
  export type User$visibleToAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    where?: AuditAccessWhereInput
    orderBy?: AuditAccessOrderByWithRelationInput | AuditAccessOrderByWithRelationInput[]
    cursor?: AuditAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditAccessScalarFieldEnum | AuditAccessScalarFieldEnum[]
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.userWarehouses
   */
  export type User$userWarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    where?: UserWarehouseWhereInput
    orderBy?: UserWarehouseOrderByWithRelationInput | UserWarehouseOrderByWithRelationInput[]
    cursor?: UserWarehouseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserWarehouseScalarFieldEnum | UserWarehouseScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AuditAccess
   */

  export type AggregateAuditAccess = {
    _count: AuditAccessCountAggregateOutputType | null
    _avg: AuditAccessAvgAggregateOutputType | null
    _sum: AuditAccessSumAggregateOutputType | null
    _min: AuditAccessMinAggregateOutputType | null
    _max: AuditAccessMaxAggregateOutputType | null
  }

  export type AuditAccessAvgAggregateOutputType = {
    id: number | null
    seniorId: number | null
    juniorId: number | null
  }

  export type AuditAccessSumAggregateOutputType = {
    id: number | null
    seniorId: number | null
    juniorId: number | null
  }

  export type AuditAccessMinAggregateOutputType = {
    id: number | null
    seniorId: number | null
    juniorId: number | null
  }

  export type AuditAccessMaxAggregateOutputType = {
    id: number | null
    seniorId: number | null
    juniorId: number | null
  }

  export type AuditAccessCountAggregateOutputType = {
    id: number
    seniorId: number
    juniorId: number
    _all: number
  }


  export type AuditAccessAvgAggregateInputType = {
    id?: true
    seniorId?: true
    juniorId?: true
  }

  export type AuditAccessSumAggregateInputType = {
    id?: true
    seniorId?: true
    juniorId?: true
  }

  export type AuditAccessMinAggregateInputType = {
    id?: true
    seniorId?: true
    juniorId?: true
  }

  export type AuditAccessMaxAggregateInputType = {
    id?: true
    seniorId?: true
    juniorId?: true
  }

  export type AuditAccessCountAggregateInputType = {
    id?: true
    seniorId?: true
    juniorId?: true
    _all?: true
  }

  export type AuditAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditAccess to aggregate.
     */
    where?: AuditAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAccesses to fetch.
     */
    orderBy?: AuditAccessOrderByWithRelationInput | AuditAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditAccesses
    **/
    _count?: true | AuditAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditAccessMaxAggregateInputType
  }

  export type GetAuditAccessAggregateType<T extends AuditAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditAccess[P]>
      : GetScalarType<T[P], AggregateAuditAccess[P]>
  }




  export type AuditAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditAccessWhereInput
    orderBy?: AuditAccessOrderByWithAggregationInput | AuditAccessOrderByWithAggregationInput[]
    by: AuditAccessScalarFieldEnum[] | AuditAccessScalarFieldEnum
    having?: AuditAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditAccessCountAggregateInputType | true
    _avg?: AuditAccessAvgAggregateInputType
    _sum?: AuditAccessSumAggregateInputType
    _min?: AuditAccessMinAggregateInputType
    _max?: AuditAccessMaxAggregateInputType
  }

  export type AuditAccessGroupByOutputType = {
    id: number
    seniorId: number
    juniorId: number
    _count: AuditAccessCountAggregateOutputType | null
    _avg: AuditAccessAvgAggregateOutputType | null
    _sum: AuditAccessSumAggregateOutputType | null
    _min: AuditAccessMinAggregateOutputType | null
    _max: AuditAccessMaxAggregateOutputType | null
  }

  type GetAuditAccessGroupByPayload<T extends AuditAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditAccessGroupByOutputType[P]>
            : GetScalarType<T[P], AuditAccessGroupByOutputType[P]>
        }
      >
    >


  export type AuditAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seniorId?: boolean
    juniorId?: boolean
    senior?: boolean | UserDefaultArgs<ExtArgs>
    junior?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditAccess"]>

  export type AuditAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seniorId?: boolean
    juniorId?: boolean
    senior?: boolean | UserDefaultArgs<ExtArgs>
    junior?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditAccess"]>

  export type AuditAccessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seniorId?: boolean
    juniorId?: boolean
    senior?: boolean | UserDefaultArgs<ExtArgs>
    junior?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditAccess"]>

  export type AuditAccessSelectScalar = {
    id?: boolean
    seniorId?: boolean
    juniorId?: boolean
  }

  export type AuditAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seniorId" | "juniorId", ExtArgs["result"]["auditAccess"]>
  export type AuditAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    senior?: boolean | UserDefaultArgs<ExtArgs>
    junior?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditAccessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    senior?: boolean | UserDefaultArgs<ExtArgs>
    junior?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditAccessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    senior?: boolean | UserDefaultArgs<ExtArgs>
    junior?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditAccess"
    objects: {
      senior: Prisma.$UserPayload<ExtArgs>
      junior: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      seniorId: number
      juniorId: number
    }, ExtArgs["result"]["auditAccess"]>
    composites: {}
  }

  type AuditAccessGetPayload<S extends boolean | null | undefined | AuditAccessDefaultArgs> = $Result.GetResult<Prisma.$AuditAccessPayload, S>

  type AuditAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditAccessCountAggregateInputType | true
    }

  export interface AuditAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditAccess'], meta: { name: 'AuditAccess' } }
    /**
     * Find zero or one AuditAccess that matches the filter.
     * @param {AuditAccessFindUniqueArgs} args - Arguments to find a AuditAccess
     * @example
     * // Get one AuditAccess
     * const auditAccess = await prisma.auditAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditAccessFindUniqueArgs>(args: SelectSubset<T, AuditAccessFindUniqueArgs<ExtArgs>>): Prisma__AuditAccessClient<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditAccessFindUniqueOrThrowArgs} args - Arguments to find a AuditAccess
     * @example
     * // Get one AuditAccess
     * const auditAccess = await prisma.auditAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditAccessClient<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAccessFindFirstArgs} args - Arguments to find a AuditAccess
     * @example
     * // Get one AuditAccess
     * const auditAccess = await prisma.auditAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditAccessFindFirstArgs>(args?: SelectSubset<T, AuditAccessFindFirstArgs<ExtArgs>>): Prisma__AuditAccessClient<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAccessFindFirstOrThrowArgs} args - Arguments to find a AuditAccess
     * @example
     * // Get one AuditAccess
     * const auditAccess = await prisma.auditAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditAccessClient<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditAccesses
     * const auditAccesses = await prisma.auditAccess.findMany()
     * 
     * // Get first 10 AuditAccesses
     * const auditAccesses = await prisma.auditAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditAccessWithIdOnly = await prisma.auditAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditAccessFindManyArgs>(args?: SelectSubset<T, AuditAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditAccess.
     * @param {AuditAccessCreateArgs} args - Arguments to create a AuditAccess.
     * @example
     * // Create one AuditAccess
     * const AuditAccess = await prisma.auditAccess.create({
     *   data: {
     *     // ... data to create a AuditAccess
     *   }
     * })
     * 
     */
    create<T extends AuditAccessCreateArgs>(args: SelectSubset<T, AuditAccessCreateArgs<ExtArgs>>): Prisma__AuditAccessClient<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditAccesses.
     * @param {AuditAccessCreateManyArgs} args - Arguments to create many AuditAccesses.
     * @example
     * // Create many AuditAccesses
     * const auditAccess = await prisma.auditAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditAccessCreateManyArgs>(args?: SelectSubset<T, AuditAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditAccesses and returns the data saved in the database.
     * @param {AuditAccessCreateManyAndReturnArgs} args - Arguments to create many AuditAccesses.
     * @example
     * // Create many AuditAccesses
     * const auditAccess = await prisma.auditAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditAccesses and only return the `id`
     * const auditAccessWithIdOnly = await prisma.auditAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditAccess.
     * @param {AuditAccessDeleteArgs} args - Arguments to delete one AuditAccess.
     * @example
     * // Delete one AuditAccess
     * const AuditAccess = await prisma.auditAccess.delete({
     *   where: {
     *     // ... filter to delete one AuditAccess
     *   }
     * })
     * 
     */
    delete<T extends AuditAccessDeleteArgs>(args: SelectSubset<T, AuditAccessDeleteArgs<ExtArgs>>): Prisma__AuditAccessClient<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditAccess.
     * @param {AuditAccessUpdateArgs} args - Arguments to update one AuditAccess.
     * @example
     * // Update one AuditAccess
     * const auditAccess = await prisma.auditAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditAccessUpdateArgs>(args: SelectSubset<T, AuditAccessUpdateArgs<ExtArgs>>): Prisma__AuditAccessClient<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditAccesses.
     * @param {AuditAccessDeleteManyArgs} args - Arguments to filter AuditAccesses to delete.
     * @example
     * // Delete a few AuditAccesses
     * const { count } = await prisma.auditAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditAccessDeleteManyArgs>(args?: SelectSubset<T, AuditAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditAccesses
     * const auditAccess = await prisma.auditAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditAccessUpdateManyArgs>(args: SelectSubset<T, AuditAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditAccesses and returns the data updated in the database.
     * @param {AuditAccessUpdateManyAndReturnArgs} args - Arguments to update many AuditAccesses.
     * @example
     * // Update many AuditAccesses
     * const auditAccess = await prisma.auditAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditAccesses and only return the `id`
     * const auditAccessWithIdOnly = await prisma.auditAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditAccessUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditAccessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditAccess.
     * @param {AuditAccessUpsertArgs} args - Arguments to update or create a AuditAccess.
     * @example
     * // Update or create a AuditAccess
     * const auditAccess = await prisma.auditAccess.upsert({
     *   create: {
     *     // ... data to create a AuditAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditAccess we want to update
     *   }
     * })
     */
    upsert<T extends AuditAccessUpsertArgs>(args: SelectSubset<T, AuditAccessUpsertArgs<ExtArgs>>): Prisma__AuditAccessClient<$Result.GetResult<Prisma.$AuditAccessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAccessCountArgs} args - Arguments to filter AuditAccesses to count.
     * @example
     * // Count the number of AuditAccesses
     * const count = await prisma.auditAccess.count({
     *   where: {
     *     // ... the filter for the AuditAccesses we want to count
     *   }
     * })
    **/
    count<T extends AuditAccessCountArgs>(
      args?: Subset<T, AuditAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditAccessAggregateArgs>(args: Subset<T, AuditAccessAggregateArgs>): Prisma.PrismaPromise<GetAuditAccessAggregateType<T>>

    /**
     * Group by AuditAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditAccessGroupByArgs['orderBy'] }
        : { orderBy?: AuditAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditAccess model
   */
  readonly fields: AuditAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    senior<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    junior<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditAccess model
   */
  interface AuditAccessFieldRefs {
    readonly id: FieldRef<"AuditAccess", 'Int'>
    readonly seniorId: FieldRef<"AuditAccess", 'Int'>
    readonly juniorId: FieldRef<"AuditAccess", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AuditAccess findUnique
   */
  export type AuditAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    /**
     * Filter, which AuditAccess to fetch.
     */
    where: AuditAccessWhereUniqueInput
  }

  /**
   * AuditAccess findUniqueOrThrow
   */
  export type AuditAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    /**
     * Filter, which AuditAccess to fetch.
     */
    where: AuditAccessWhereUniqueInput
  }

  /**
   * AuditAccess findFirst
   */
  export type AuditAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    /**
     * Filter, which AuditAccess to fetch.
     */
    where?: AuditAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAccesses to fetch.
     */
    orderBy?: AuditAccessOrderByWithRelationInput | AuditAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditAccesses.
     */
    cursor?: AuditAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditAccesses.
     */
    distinct?: AuditAccessScalarFieldEnum | AuditAccessScalarFieldEnum[]
  }

  /**
   * AuditAccess findFirstOrThrow
   */
  export type AuditAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    /**
     * Filter, which AuditAccess to fetch.
     */
    where?: AuditAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAccesses to fetch.
     */
    orderBy?: AuditAccessOrderByWithRelationInput | AuditAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditAccesses.
     */
    cursor?: AuditAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditAccesses.
     */
    distinct?: AuditAccessScalarFieldEnum | AuditAccessScalarFieldEnum[]
  }

  /**
   * AuditAccess findMany
   */
  export type AuditAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    /**
     * Filter, which AuditAccesses to fetch.
     */
    where?: AuditAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditAccesses to fetch.
     */
    orderBy?: AuditAccessOrderByWithRelationInput | AuditAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditAccesses.
     */
    cursor?: AuditAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditAccesses.
     */
    skip?: number
    distinct?: AuditAccessScalarFieldEnum | AuditAccessScalarFieldEnum[]
  }

  /**
   * AuditAccess create
   */
  export type AuditAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditAccess.
     */
    data: XOR<AuditAccessCreateInput, AuditAccessUncheckedCreateInput>
  }

  /**
   * AuditAccess createMany
   */
  export type AuditAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditAccesses.
     */
    data: AuditAccessCreateManyInput | AuditAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditAccess createManyAndReturn
   */
  export type AuditAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * The data used to create many AuditAccesses.
     */
    data: AuditAccessCreateManyInput | AuditAccessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditAccess update
   */
  export type AuditAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditAccess.
     */
    data: XOR<AuditAccessUpdateInput, AuditAccessUncheckedUpdateInput>
    /**
     * Choose, which AuditAccess to update.
     */
    where: AuditAccessWhereUniqueInput
  }

  /**
   * AuditAccess updateMany
   */
  export type AuditAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditAccesses.
     */
    data: XOR<AuditAccessUpdateManyMutationInput, AuditAccessUncheckedUpdateManyInput>
    /**
     * Filter which AuditAccesses to update
     */
    where?: AuditAccessWhereInput
    /**
     * Limit how many AuditAccesses to update.
     */
    limit?: number
  }

  /**
   * AuditAccess updateManyAndReturn
   */
  export type AuditAccessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * The data used to update AuditAccesses.
     */
    data: XOR<AuditAccessUpdateManyMutationInput, AuditAccessUncheckedUpdateManyInput>
    /**
     * Filter which AuditAccesses to update
     */
    where?: AuditAccessWhereInput
    /**
     * Limit how many AuditAccesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditAccess upsert
   */
  export type AuditAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditAccess to update in case it exists.
     */
    where: AuditAccessWhereUniqueInput
    /**
     * In case the AuditAccess found by the `where` argument doesn't exist, create a new AuditAccess with this data.
     */
    create: XOR<AuditAccessCreateInput, AuditAccessUncheckedCreateInput>
    /**
     * In case the AuditAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditAccessUpdateInput, AuditAccessUncheckedUpdateInput>
  }

  /**
   * AuditAccess delete
   */
  export type AuditAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
    /**
     * Filter which AuditAccess to delete.
     */
    where: AuditAccessWhereUniqueInput
  }

  /**
   * AuditAccess deleteMany
   */
  export type AuditAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditAccesses to delete
     */
    where?: AuditAccessWhereInput
    /**
     * Limit how many AuditAccesses to delete.
     */
    limit?: number
  }

  /**
   * AuditAccess without action
   */
  export type AuditAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditAccess
     */
    select?: AuditAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditAccess
     */
    omit?: AuditAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditAccessInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Department$usersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Department$usersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Department$usersArgs<ExtArgs> = {}>(args?: Subset<T, Department$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.users
   */
  export type Department$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | Role$userRolesArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends Role$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.userRoles
   */
  export type Role$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    id: number | null
    action: string | null
    resource: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: number | null
    action: string | null
    resource: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    action: number
    resource: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    id?: true
  }

  export type PermissionSumAggregateInputType = {
    id?: true
  }

  export type PermissionMinAggregateInputType = {
    id?: true
    action?: true
    resource?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    action?: true
    resource?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    action?: true
    resource?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: number
    action: string
    resource: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    resource?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    resource?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    resource?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    action?: boolean
    resource?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "resource" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      action: string
      resource: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'Int'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
    assignedAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    roleId: number | null
    permissionId: number | null
    assignedAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    roleId: number
    permissionId: number
    assignedAt: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionSumAggregateInputType = {
    roleId?: true
    permissionId?: true
  }

  export type RolePermissionMinAggregateInputType = {
    roleId?: true
    permissionId?: true
    assignedAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    roleId?: true
    permissionId?: true
    assignedAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    roleId?: true
    permissionId?: true
    assignedAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    roleId: number
    permissionId: number
    assignedAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>

  export type RolePermissionSelectScalar = {
    roleId?: boolean
    permissionId?: boolean
    assignedAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roleId" | "permissionId" | "assignedAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }
  export type RolePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      permissionId: number
      assignedAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.createManyAndReturn({
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions and returns the data updated in the database.
     * @param {RolePermissionUpdateManyAndReturnArgs} args - Arguments to update many RolePermissions.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolePermissions and only return the `roleId`
     * const rolePermissionWithRoleIdOnly = await prisma.rolePermission.updateManyAndReturn({
     *   select: { roleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, RolePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly roleId: FieldRef<"RolePermission", 'Int'>
    readonly permissionId: FieldRef<"RolePermission", 'Int'>
    readonly assignedAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission createManyAndReturn
   */
  export type RolePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission updateManyAndReturn
   */
  export type RolePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: number | null
    roleId: number | null
    assignedAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: number | null
    roleId: number | null
    assignedAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    assignedAt: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleSumAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
    assignedAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
    assignedAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    assignedAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: number
    roleId: number
    assignedAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
    assignedAt?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId" | "assignedAt", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      roleId: number
      assignedAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'Int'>
    readonly roleId: FieldRef<"UserRole", 'Int'>
    readonly assignedAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    published: boolean | null
    authorId: number | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    published: boolean | null
    authorId: number | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    title: number
    content: number
    published: number
    authorId: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    published?: true
    authorId?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    published?: true
    authorId?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    published?: true
    authorId?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    title: string
    content: string | null
    published: boolean
    authorId: number
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    authorId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    authorId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    authorId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    authorId?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "published" | "authorId", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string | null
      published: boolean
      authorId: number
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly published: FieldRef<"Post", 'Boolean'>
    readonly authorId: FieldRef<"Post", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    userId: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    userId: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: number | null
    expiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    isRevoked: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    userId?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    userId?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: number
    expiresAt: Date
    isRevoked: boolean
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "isRevoked" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: number
      expiresAt: Date
      isRevoked: boolean
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'Int'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly isRevoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    userId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    userId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: number | null
    action: string | null
    module: string | null
    resourceId: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: number | null
    action: string | null
    module: string | null
    resourceId: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    module: number
    resourceId: number
    before: number
    after: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    userId?: true
  }

  export type AuditLogSumAggregateInputType = {
    userId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    module?: true
    resourceId?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    module?: true
    resourceId?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    module?: true
    resourceId?: true
    before?: true
    after?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: number
    action: string
    module: string
    resourceId: string | null
    before: JsonValue | null
    after: JsonValue | null
    metadata: JsonValue | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    resourceId?: boolean
    before?: boolean
    after?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    resourceId?: boolean
    before?: boolean
    after?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    resourceId?: boolean
    before?: boolean
    after?: boolean
    metadata?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    resourceId?: boolean
    before?: boolean
    after?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "module" | "resourceId" | "before" | "after" | "metadata" | "timestamp", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: number
      action: string
      module: string
      resourceId: string | null
      before: Prisma.JsonValue | null
      after: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly module: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly before: FieldRef<"AuditLog", 'Json'>
    readonly after: FieldRef<"AuditLog", 'Json'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Warehouse
   */

  export type AggregateWarehouse = {
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  export type WarehouseAvgAggregateOutputType = {
    id: number | null
  }

  export type WarehouseSumAggregateOutputType = {
    id: number | null
  }

  export type WarehouseMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    contactPerson: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    contactPerson: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehouseCountAggregateOutputType = {
    id: number
    name: number
    location: number
    contactPerson: number
    contactNumbers: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehouseAvgAggregateInputType = {
    id?: true
  }

  export type WarehouseSumAggregateInputType = {
    id?: true
  }

  export type WarehouseMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    contactPerson?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    contactPerson?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehouseCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    contactPerson?: true
    contactNumbers?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouse to aggregate.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseMaxAggregateInputType
  }

  export type GetWarehouseAggregateType<T extends WarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouse[P]>
      : GetScalarType<T[P], AggregateWarehouse[P]>
  }




  export type WarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseWhereInput
    orderBy?: WarehouseOrderByWithAggregationInput | WarehouseOrderByWithAggregationInput[]
    by: WarehouseScalarFieldEnum[] | WarehouseScalarFieldEnum
    having?: WarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseCountAggregateInputType | true
    _avg?: WarehouseAvgAggregateInputType
    _sum?: WarehouseSumAggregateInputType
    _min?: WarehouseMinAggregateInputType
    _max?: WarehouseMaxAggregateInputType
  }

  export type WarehouseGroupByOutputType = {
    id: number
    name: string
    location: string | null
    contactPerson: string | null
    contactNumbers: string[]
    status: string
    createdAt: Date
    updatedAt: Date
    _count: WarehouseCountAggregateOutputType | null
    _avg: WarehouseAvgAggregateOutputType | null
    _sum: WarehouseSumAggregateOutputType | null
    _min: WarehouseMinAggregateOutputType | null
    _max: WarehouseMaxAggregateOutputType | null
  }

  type GetWarehouseGroupByPayload<T extends WarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    contactPerson?: boolean
    contactNumbers?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userWarehouses?: boolean | Warehouse$userWarehousesArgs<ExtArgs>
    purchaseOrders?: boolean | Warehouse$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    contactPerson?: boolean
    contactNumbers?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    contactPerson?: boolean
    contactNumbers?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["warehouse"]>

  export type WarehouseSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    contactPerson?: boolean
    contactNumbers?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "contactPerson" | "contactNumbers" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["warehouse"]>
  export type WarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userWarehouses?: boolean | Warehouse$userWarehousesArgs<ExtArgs>
    purchaseOrders?: boolean | Warehouse$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | WarehouseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouse"
    objects: {
      userWarehouses: Prisma.$UserWarehousePayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string | null
      contactPerson: string | null
      contactNumbers: string[]
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouse"]>
    composites: {}
  }

  type WarehouseGetPayload<S extends boolean | null | undefined | WarehouseDefaultArgs> = $Result.GetResult<Prisma.$WarehousePayload, S>

  type WarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarehouseCountAggregateInputType | true
    }

  export interface WarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouse'], meta: { name: 'Warehouse' } }
    /**
     * Find zero or one Warehouse that matches the filter.
     * @param {WarehouseFindUniqueArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WarehouseFindUniqueArgs>(args: SelectSubset<T, WarehouseFindUniqueArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WarehouseFindUniqueOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, WarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WarehouseFindFirstArgs>(args?: SelectSubset<T, WarehouseFindFirstArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindFirstOrThrowArgs} args - Arguments to find a Warehouse
     * @example
     * // Get one Warehouse
     * const warehouse = await prisma.warehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, WarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouse.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WarehouseFindManyArgs>(args?: SelectSubset<T, WarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warehouse.
     * @param {WarehouseCreateArgs} args - Arguments to create a Warehouse.
     * @example
     * // Create one Warehouse
     * const Warehouse = await prisma.warehouse.create({
     *   data: {
     *     // ... data to create a Warehouse
     *   }
     * })
     * 
     */
    create<T extends WarehouseCreateArgs>(args: SelectSubset<T, WarehouseCreateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warehouses.
     * @param {WarehouseCreateManyArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WarehouseCreateManyArgs>(args?: SelectSubset<T, WarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warehouses and returns the data saved in the database.
     * @param {WarehouseCreateManyAndReturnArgs} args - Arguments to create many Warehouses.
     * @example
     * // Create many Warehouses
     * const warehouse = await prisma.warehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, WarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warehouse.
     * @param {WarehouseDeleteArgs} args - Arguments to delete one Warehouse.
     * @example
     * // Delete one Warehouse
     * const Warehouse = await prisma.warehouse.delete({
     *   where: {
     *     // ... filter to delete one Warehouse
     *   }
     * })
     * 
     */
    delete<T extends WarehouseDeleteArgs>(args: SelectSubset<T, WarehouseDeleteArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warehouse.
     * @param {WarehouseUpdateArgs} args - Arguments to update one Warehouse.
     * @example
     * // Update one Warehouse
     * const warehouse = await prisma.warehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WarehouseUpdateArgs>(args: SelectSubset<T, WarehouseUpdateArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehouseDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WarehouseDeleteManyArgs>(args?: SelectSubset<T, WarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WarehouseUpdateManyArgs>(args: SelectSubset<T, WarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses and returns the data updated in the database.
     * @param {WarehouseUpdateManyAndReturnArgs} args - Arguments to update many Warehouses.
     * @example
     * // Update many Warehouses
     * const warehouse = await prisma.warehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warehouses and only return the `id`
     * const warehouseWithIdOnly = await prisma.warehouse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, WarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warehouse.
     * @param {WarehouseUpsertArgs} args - Arguments to update or create a Warehouse.
     * @example
     * // Update or create a Warehouse
     * const warehouse = await prisma.warehouse.upsert({
     *   create: {
     *     // ... data to create a Warehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouse we want to update
     *   }
     * })
     */
    upsert<T extends WarehouseUpsertArgs>(args: SelectSubset<T, WarehouseUpsertArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouse.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehouseCountArgs>(
      args?: Subset<T, WarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseAggregateArgs>(args: Subset<T, WarehouseAggregateArgs>): Prisma.PrismaPromise<GetWarehouseAggregateType<T>>

    /**
     * Group by Warehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouse model
   */
  readonly fields: WarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userWarehouses<T extends Warehouse$userWarehousesArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$userWarehousesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Warehouse$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Warehouse$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Warehouse model
   */
  interface WarehouseFieldRefs {
    readonly id: FieldRef<"Warehouse", 'Int'>
    readonly name: FieldRef<"Warehouse", 'String'>
    readonly location: FieldRef<"Warehouse", 'String'>
    readonly contactPerson: FieldRef<"Warehouse", 'String'>
    readonly contactNumbers: FieldRef<"Warehouse", 'String[]'>
    readonly status: FieldRef<"Warehouse", 'String'>
    readonly createdAt: FieldRef<"Warehouse", 'DateTime'>
    readonly updatedAt: FieldRef<"Warehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Warehouse findUnique
   */
  export type WarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findUniqueOrThrow
   */
  export type WarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse findFirst
   */
  export type WarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findFirstOrThrow
   */
  export type WarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouse to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse findMany
   */
  export type WarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehouseOrderByWithRelationInput | WarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehouseScalarFieldEnum | WarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse create
   */
  export type WarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouse.
     */
    data: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
  }

  /**
   * Warehouse createMany
   */
  export type WarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse createManyAndReturn
   */
  export type WarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many Warehouses.
     */
    data: WarehouseCreateManyInput | WarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Warehouse update
   */
  export type WarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouse.
     */
    data: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
    /**
     * Choose, which Warehouse to update.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse updateMany
   */
  export type WarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse updateManyAndReturn
   */
  export type WarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehouseUpdateManyMutationInput, WarehouseUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to update.
     */
    limit?: number
  }

  /**
   * Warehouse upsert
   */
  export type WarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouse to update in case it exists.
     */
    where: WarehouseWhereUniqueInput
    /**
     * In case the Warehouse found by the `where` argument doesn't exist, create a new Warehouse with this data.
     */
    create: XOR<WarehouseCreateInput, WarehouseUncheckedCreateInput>
    /**
     * In case the Warehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseUpdateInput, WarehouseUncheckedUpdateInput>
  }

  /**
   * Warehouse delete
   */
  export type WarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    /**
     * Filter which Warehouse to delete.
     */
    where: WarehouseWhereUniqueInput
  }

  /**
   * Warehouse deleteMany
   */
  export type WarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehouseWhereInput
    /**
     * Limit how many Warehouses to delete.
     */
    limit?: number
  }

  /**
   * Warehouse.userWarehouses
   */
  export type Warehouse$userWarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    where?: UserWarehouseWhereInput
    orderBy?: UserWarehouseOrderByWithRelationInput | UserWarehouseOrderByWithRelationInput[]
    cursor?: UserWarehouseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserWarehouseScalarFieldEnum | UserWarehouseScalarFieldEnum[]
  }

  /**
   * Warehouse.purchaseOrders
   */
  export type Warehouse$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Warehouse without action
   */
  export type WarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
  }


  /**
   * Model UserWarehouse
   */

  export type AggregateUserWarehouse = {
    _count: UserWarehouseCountAggregateOutputType | null
    _avg: UserWarehouseAvgAggregateOutputType | null
    _sum: UserWarehouseSumAggregateOutputType | null
    _min: UserWarehouseMinAggregateOutputType | null
    _max: UserWarehouseMaxAggregateOutputType | null
  }

  export type UserWarehouseAvgAggregateOutputType = {
    userId: number | null
    warehouseId: number | null
  }

  export type UserWarehouseSumAggregateOutputType = {
    userId: number | null
    warehouseId: number | null
  }

  export type UserWarehouseMinAggregateOutputType = {
    userId: number | null
    warehouseId: number | null
    assignedAt: Date | null
  }

  export type UserWarehouseMaxAggregateOutputType = {
    userId: number | null
    warehouseId: number | null
    assignedAt: Date | null
  }

  export type UserWarehouseCountAggregateOutputType = {
    userId: number
    warehouseId: number
    assignedAt: number
    _all: number
  }


  export type UserWarehouseAvgAggregateInputType = {
    userId?: true
    warehouseId?: true
  }

  export type UserWarehouseSumAggregateInputType = {
    userId?: true
    warehouseId?: true
  }

  export type UserWarehouseMinAggregateInputType = {
    userId?: true
    warehouseId?: true
    assignedAt?: true
  }

  export type UserWarehouseMaxAggregateInputType = {
    userId?: true
    warehouseId?: true
    assignedAt?: true
  }

  export type UserWarehouseCountAggregateInputType = {
    userId?: true
    warehouseId?: true
    assignedAt?: true
    _all?: true
  }

  export type UserWarehouseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWarehouse to aggregate.
     */
    where?: UserWarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWarehouses to fetch.
     */
    orderBy?: UserWarehouseOrderByWithRelationInput | UserWarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWarehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWarehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserWarehouses
    **/
    _count?: true | UserWarehouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserWarehouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserWarehouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserWarehouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserWarehouseMaxAggregateInputType
  }

  export type GetUserWarehouseAggregateType<T extends UserWarehouseAggregateArgs> = {
        [P in keyof T & keyof AggregateUserWarehouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserWarehouse[P]>
      : GetScalarType<T[P], AggregateUserWarehouse[P]>
  }




  export type UserWarehouseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWarehouseWhereInput
    orderBy?: UserWarehouseOrderByWithAggregationInput | UserWarehouseOrderByWithAggregationInput[]
    by: UserWarehouseScalarFieldEnum[] | UserWarehouseScalarFieldEnum
    having?: UserWarehouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserWarehouseCountAggregateInputType | true
    _avg?: UserWarehouseAvgAggregateInputType
    _sum?: UserWarehouseSumAggregateInputType
    _min?: UserWarehouseMinAggregateInputType
    _max?: UserWarehouseMaxAggregateInputType
  }

  export type UserWarehouseGroupByOutputType = {
    userId: number
    warehouseId: number
    assignedAt: Date
    _count: UserWarehouseCountAggregateOutputType | null
    _avg: UserWarehouseAvgAggregateOutputType | null
    _sum: UserWarehouseSumAggregateOutputType | null
    _min: UserWarehouseMinAggregateOutputType | null
    _max: UserWarehouseMaxAggregateOutputType | null
  }

  type GetUserWarehouseGroupByPayload<T extends UserWarehouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserWarehouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserWarehouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserWarehouseGroupByOutputType[P]>
            : GetScalarType<T[P], UserWarehouseGroupByOutputType[P]>
        }
      >
    >


  export type UserWarehouseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    warehouseId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWarehouse"]>

  export type UserWarehouseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    warehouseId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWarehouse"]>

  export type UserWarehouseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    warehouseId?: boolean
    assignedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWarehouse"]>

  export type UserWarehouseSelectScalar = {
    userId?: boolean
    warehouseId?: boolean
    assignedAt?: boolean
  }

  export type UserWarehouseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "warehouseId" | "assignedAt", ExtArgs["result"]["userWarehouse"]>
  export type UserWarehouseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type UserWarehouseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }
  export type UserWarehouseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    warehouse?: boolean | WarehouseDefaultArgs<ExtArgs>
  }

  export type $UserWarehousePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserWarehouse"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      warehouse: Prisma.$WarehousePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      warehouseId: number
      assignedAt: Date
    }, ExtArgs["result"]["userWarehouse"]>
    composites: {}
  }

  type UserWarehouseGetPayload<S extends boolean | null | undefined | UserWarehouseDefaultArgs> = $Result.GetResult<Prisma.$UserWarehousePayload, S>

  type UserWarehouseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserWarehouseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserWarehouseCountAggregateInputType | true
    }

  export interface UserWarehouseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserWarehouse'], meta: { name: 'UserWarehouse' } }
    /**
     * Find zero or one UserWarehouse that matches the filter.
     * @param {UserWarehouseFindUniqueArgs} args - Arguments to find a UserWarehouse
     * @example
     * // Get one UserWarehouse
     * const userWarehouse = await prisma.userWarehouse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserWarehouseFindUniqueArgs>(args: SelectSubset<T, UserWarehouseFindUniqueArgs<ExtArgs>>): Prisma__UserWarehouseClient<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserWarehouse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserWarehouseFindUniqueOrThrowArgs} args - Arguments to find a UserWarehouse
     * @example
     * // Get one UserWarehouse
     * const userWarehouse = await prisma.userWarehouse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserWarehouseFindUniqueOrThrowArgs>(args: SelectSubset<T, UserWarehouseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserWarehouseClient<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserWarehouse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWarehouseFindFirstArgs} args - Arguments to find a UserWarehouse
     * @example
     * // Get one UserWarehouse
     * const userWarehouse = await prisma.userWarehouse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserWarehouseFindFirstArgs>(args?: SelectSubset<T, UserWarehouseFindFirstArgs<ExtArgs>>): Prisma__UserWarehouseClient<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserWarehouse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWarehouseFindFirstOrThrowArgs} args - Arguments to find a UserWarehouse
     * @example
     * // Get one UserWarehouse
     * const userWarehouse = await prisma.userWarehouse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserWarehouseFindFirstOrThrowArgs>(args?: SelectSubset<T, UserWarehouseFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserWarehouseClient<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserWarehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWarehouseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserWarehouses
     * const userWarehouses = await prisma.userWarehouse.findMany()
     * 
     * // Get first 10 UserWarehouses
     * const userWarehouses = await prisma.userWarehouse.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userWarehouseWithUserIdOnly = await prisma.userWarehouse.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserWarehouseFindManyArgs>(args?: SelectSubset<T, UserWarehouseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserWarehouse.
     * @param {UserWarehouseCreateArgs} args - Arguments to create a UserWarehouse.
     * @example
     * // Create one UserWarehouse
     * const UserWarehouse = await prisma.userWarehouse.create({
     *   data: {
     *     // ... data to create a UserWarehouse
     *   }
     * })
     * 
     */
    create<T extends UserWarehouseCreateArgs>(args: SelectSubset<T, UserWarehouseCreateArgs<ExtArgs>>): Prisma__UserWarehouseClient<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserWarehouses.
     * @param {UserWarehouseCreateManyArgs} args - Arguments to create many UserWarehouses.
     * @example
     * // Create many UserWarehouses
     * const userWarehouse = await prisma.userWarehouse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserWarehouseCreateManyArgs>(args?: SelectSubset<T, UserWarehouseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserWarehouses and returns the data saved in the database.
     * @param {UserWarehouseCreateManyAndReturnArgs} args - Arguments to create many UserWarehouses.
     * @example
     * // Create many UserWarehouses
     * const userWarehouse = await prisma.userWarehouse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserWarehouses and only return the `userId`
     * const userWarehouseWithUserIdOnly = await prisma.userWarehouse.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserWarehouseCreateManyAndReturnArgs>(args?: SelectSubset<T, UserWarehouseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserWarehouse.
     * @param {UserWarehouseDeleteArgs} args - Arguments to delete one UserWarehouse.
     * @example
     * // Delete one UserWarehouse
     * const UserWarehouse = await prisma.userWarehouse.delete({
     *   where: {
     *     // ... filter to delete one UserWarehouse
     *   }
     * })
     * 
     */
    delete<T extends UserWarehouseDeleteArgs>(args: SelectSubset<T, UserWarehouseDeleteArgs<ExtArgs>>): Prisma__UserWarehouseClient<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserWarehouse.
     * @param {UserWarehouseUpdateArgs} args - Arguments to update one UserWarehouse.
     * @example
     * // Update one UserWarehouse
     * const userWarehouse = await prisma.userWarehouse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserWarehouseUpdateArgs>(args: SelectSubset<T, UserWarehouseUpdateArgs<ExtArgs>>): Prisma__UserWarehouseClient<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserWarehouses.
     * @param {UserWarehouseDeleteManyArgs} args - Arguments to filter UserWarehouses to delete.
     * @example
     * // Delete a few UserWarehouses
     * const { count } = await prisma.userWarehouse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserWarehouseDeleteManyArgs>(args?: SelectSubset<T, UserWarehouseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWarehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWarehouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserWarehouses
     * const userWarehouse = await prisma.userWarehouse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserWarehouseUpdateManyArgs>(args: SelectSubset<T, UserWarehouseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWarehouses and returns the data updated in the database.
     * @param {UserWarehouseUpdateManyAndReturnArgs} args - Arguments to update many UserWarehouses.
     * @example
     * // Update many UserWarehouses
     * const userWarehouse = await prisma.userWarehouse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserWarehouses and only return the `userId`
     * const userWarehouseWithUserIdOnly = await prisma.userWarehouse.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserWarehouseUpdateManyAndReturnArgs>(args: SelectSubset<T, UserWarehouseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserWarehouse.
     * @param {UserWarehouseUpsertArgs} args - Arguments to update or create a UserWarehouse.
     * @example
     * // Update or create a UserWarehouse
     * const userWarehouse = await prisma.userWarehouse.upsert({
     *   create: {
     *     // ... data to create a UserWarehouse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserWarehouse we want to update
     *   }
     * })
     */
    upsert<T extends UserWarehouseUpsertArgs>(args: SelectSubset<T, UserWarehouseUpsertArgs<ExtArgs>>): Prisma__UserWarehouseClient<$Result.GetResult<Prisma.$UserWarehousePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserWarehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWarehouseCountArgs} args - Arguments to filter UserWarehouses to count.
     * @example
     * // Count the number of UserWarehouses
     * const count = await prisma.userWarehouse.count({
     *   where: {
     *     // ... the filter for the UserWarehouses we want to count
     *   }
     * })
    **/
    count<T extends UserWarehouseCountArgs>(
      args?: Subset<T, UserWarehouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserWarehouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserWarehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWarehouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserWarehouseAggregateArgs>(args: Subset<T, UserWarehouseAggregateArgs>): Prisma.PrismaPromise<GetUserWarehouseAggregateType<T>>

    /**
     * Group by UserWarehouse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWarehouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserWarehouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserWarehouseGroupByArgs['orderBy'] }
        : { orderBy?: UserWarehouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserWarehouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserWarehouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserWarehouse model
   */
  readonly fields: UserWarehouseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserWarehouse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserWarehouseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends WarehouseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseDefaultArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserWarehouse model
   */
  interface UserWarehouseFieldRefs {
    readonly userId: FieldRef<"UserWarehouse", 'Int'>
    readonly warehouseId: FieldRef<"UserWarehouse", 'Int'>
    readonly assignedAt: FieldRef<"UserWarehouse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserWarehouse findUnique
   */
  export type UserWarehouseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    /**
     * Filter, which UserWarehouse to fetch.
     */
    where: UserWarehouseWhereUniqueInput
  }

  /**
   * UserWarehouse findUniqueOrThrow
   */
  export type UserWarehouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    /**
     * Filter, which UserWarehouse to fetch.
     */
    where: UserWarehouseWhereUniqueInput
  }

  /**
   * UserWarehouse findFirst
   */
  export type UserWarehouseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    /**
     * Filter, which UserWarehouse to fetch.
     */
    where?: UserWarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWarehouses to fetch.
     */
    orderBy?: UserWarehouseOrderByWithRelationInput | UserWarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWarehouses.
     */
    cursor?: UserWarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWarehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWarehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWarehouses.
     */
    distinct?: UserWarehouseScalarFieldEnum | UserWarehouseScalarFieldEnum[]
  }

  /**
   * UserWarehouse findFirstOrThrow
   */
  export type UserWarehouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    /**
     * Filter, which UserWarehouse to fetch.
     */
    where?: UserWarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWarehouses to fetch.
     */
    orderBy?: UserWarehouseOrderByWithRelationInput | UserWarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWarehouses.
     */
    cursor?: UserWarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWarehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWarehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWarehouses.
     */
    distinct?: UserWarehouseScalarFieldEnum | UserWarehouseScalarFieldEnum[]
  }

  /**
   * UserWarehouse findMany
   */
  export type UserWarehouseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    /**
     * Filter, which UserWarehouses to fetch.
     */
    where?: UserWarehouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWarehouses to fetch.
     */
    orderBy?: UserWarehouseOrderByWithRelationInput | UserWarehouseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserWarehouses.
     */
    cursor?: UserWarehouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWarehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWarehouses.
     */
    skip?: number
    distinct?: UserWarehouseScalarFieldEnum | UserWarehouseScalarFieldEnum[]
  }

  /**
   * UserWarehouse create
   */
  export type UserWarehouseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    /**
     * The data needed to create a UserWarehouse.
     */
    data: XOR<UserWarehouseCreateInput, UserWarehouseUncheckedCreateInput>
  }

  /**
   * UserWarehouse createMany
   */
  export type UserWarehouseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserWarehouses.
     */
    data: UserWarehouseCreateManyInput | UserWarehouseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserWarehouse createManyAndReturn
   */
  export type UserWarehouseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * The data used to create many UserWarehouses.
     */
    data: UserWarehouseCreateManyInput | UserWarehouseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWarehouse update
   */
  export type UserWarehouseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    /**
     * The data needed to update a UserWarehouse.
     */
    data: XOR<UserWarehouseUpdateInput, UserWarehouseUncheckedUpdateInput>
    /**
     * Choose, which UserWarehouse to update.
     */
    where: UserWarehouseWhereUniqueInput
  }

  /**
   * UserWarehouse updateMany
   */
  export type UserWarehouseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserWarehouses.
     */
    data: XOR<UserWarehouseUpdateManyMutationInput, UserWarehouseUncheckedUpdateManyInput>
    /**
     * Filter which UserWarehouses to update
     */
    where?: UserWarehouseWhereInput
    /**
     * Limit how many UserWarehouses to update.
     */
    limit?: number
  }

  /**
   * UserWarehouse updateManyAndReturn
   */
  export type UserWarehouseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * The data used to update UserWarehouses.
     */
    data: XOR<UserWarehouseUpdateManyMutationInput, UserWarehouseUncheckedUpdateManyInput>
    /**
     * Filter which UserWarehouses to update
     */
    where?: UserWarehouseWhereInput
    /**
     * Limit how many UserWarehouses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWarehouse upsert
   */
  export type UserWarehouseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    /**
     * The filter to search for the UserWarehouse to update in case it exists.
     */
    where: UserWarehouseWhereUniqueInput
    /**
     * In case the UserWarehouse found by the `where` argument doesn't exist, create a new UserWarehouse with this data.
     */
    create: XOR<UserWarehouseCreateInput, UserWarehouseUncheckedCreateInput>
    /**
     * In case the UserWarehouse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserWarehouseUpdateInput, UserWarehouseUncheckedUpdateInput>
  }

  /**
   * UserWarehouse delete
   */
  export type UserWarehouseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
    /**
     * Filter which UserWarehouse to delete.
     */
    where: UserWarehouseWhereUniqueInput
  }

  /**
   * UserWarehouse deleteMany
   */
  export type UserWarehouseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWarehouses to delete
     */
    where?: UserWarehouseWhereInput
    /**
     * Limit how many UserWarehouses to delete.
     */
    limit?: number
  }

  /**
   * UserWarehouse without action
   */
  export type UserWarehouseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWarehouse
     */
    select?: UserWarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWarehouse
     */
    omit?: UserWarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWarehouseInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
    companyId: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    symbol: string | null
    unitType: string | null
    isBase: boolean | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    symbol: string | null
    unitType: string | null
    isBase: boolean | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    code: number
    name: number
    symbol: number
    unitType: number
    isBase: number
    status: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
    companyId?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    unitType?: true
    isBase?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    unitType?: true
    isBase?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    unitType?: true
    isBase?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    id: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase: boolean
    status: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    unitType?: boolean
    isBase?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    conversionsFrom?: boolean | Unit$conversionsFromArgs<ExtArgs>
    conversionsTo?: boolean | Unit$conversionsToArgs<ExtArgs>
    products?: boolean | Unit$productsArgs<ExtArgs>
    itemMasters?: boolean | Unit$itemMastersArgs<ExtArgs>
    purchaseOrderItems?: boolean | Unit$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | Unit$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | Unit$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | Unit$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    unitType?: boolean
    isBase?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    unitType?: boolean
    isBase?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    unitType?: boolean
    isBase?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "symbol" | "unitType" | "isBase" | "status" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    conversionsFrom?: boolean | Unit$conversionsFromArgs<ExtArgs>
    conversionsTo?: boolean | Unit$conversionsToArgs<ExtArgs>
    products?: boolean | Unit$productsArgs<ExtArgs>
    itemMasters?: boolean | Unit$itemMastersArgs<ExtArgs>
    purchaseOrderItems?: boolean | Unit$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | Unit$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | Unit$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | Unit$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      conversionsFrom: Prisma.$UnitConversionPayload<ExtArgs>[]
      conversionsTo: Prisma.$UnitConversionPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      itemMasters: Prisma.$ItemMasterPayload<ExtArgs>[]
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      grnItems: Prisma.$GRNItemPayload<ExtArgs>[]
      purchaseInvoiceItems: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
      purchaseReturnItems: Prisma.$PurchaseReturnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      symbol: string
      unitType: string
      isBase: boolean
      status: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `id`
     * const unitWithIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversionsFrom<T extends Unit$conversionsFromArgs<ExtArgs> = {}>(args?: Subset<T, Unit$conversionsFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversionsTo<T extends Unit$conversionsToArgs<ExtArgs> = {}>(args?: Subset<T, Unit$conversionsToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Unit$productsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    itemMasters<T extends Unit$itemMastersArgs<ExtArgs> = {}>(args?: Subset<T, Unit$itemMastersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrderItems<T extends Unit$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grnItems<T extends Unit$grnItemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$grnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoiceItems<T extends Unit$purchaseInvoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$purchaseInvoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturnItems<T extends Unit$purchaseReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, Unit$purchaseReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly id: FieldRef<"Unit", 'Int'>
    readonly code: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly symbol: FieldRef<"Unit", 'String'>
    readonly unitType: FieldRef<"Unit", 'String'>
    readonly isBase: FieldRef<"Unit", 'Boolean'>
    readonly status: FieldRef<"Unit", 'String'>
    readonly companyId: FieldRef<"Unit", 'Int'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.conversionsFrom
   */
  export type Unit$conversionsFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    where?: UnitConversionWhereInput
    orderBy?: UnitConversionOrderByWithRelationInput | UnitConversionOrderByWithRelationInput[]
    cursor?: UnitConversionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitConversionScalarFieldEnum | UnitConversionScalarFieldEnum[]
  }

  /**
   * Unit.conversionsTo
   */
  export type Unit$conversionsToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    where?: UnitConversionWhereInput
    orderBy?: UnitConversionOrderByWithRelationInput | UnitConversionOrderByWithRelationInput[]
    cursor?: UnitConversionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitConversionScalarFieldEnum | UnitConversionScalarFieldEnum[]
  }

  /**
   * Unit.products
   */
  export type Unit$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Unit.itemMasters
   */
  export type Unit$itemMastersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    where?: ItemMasterWhereInput
    orderBy?: ItemMasterOrderByWithRelationInput | ItemMasterOrderByWithRelationInput[]
    cursor?: ItemMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemMasterScalarFieldEnum | ItemMasterScalarFieldEnum[]
  }

  /**
   * Unit.purchaseOrderItems
   */
  export type Unit$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * Unit.grnItems
   */
  export type Unit$grnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    where?: GRNItemWhereInput
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    cursor?: GRNItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * Unit.purchaseInvoiceItems
   */
  export type Unit$purchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * Unit.purchaseReturnItems
   */
  export type Unit$purchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    where?: PurchaseReturnItemWhereInput
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    cursor?: PurchaseReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnItemScalarFieldEnum | PurchaseReturnItemScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model UnitConversion
   */

  export type AggregateUnitConversion = {
    _count: UnitConversionCountAggregateOutputType | null
    _avg: UnitConversionAvgAggregateOutputType | null
    _sum: UnitConversionSumAggregateOutputType | null
    _min: UnitConversionMinAggregateOutputType | null
    _max: UnitConversionMaxAggregateOutputType | null
  }

  export type UnitConversionAvgAggregateOutputType = {
    id: number | null
    fromUnitId: number | null
    toUnitId: number | null
    conversionRate: number | null
    companyId: number | null
  }

  export type UnitConversionSumAggregateOutputType = {
    id: number | null
    fromUnitId: number | null
    toUnitId: number | null
    conversionRate: number | null
    companyId: number | null
  }

  export type UnitConversionMinAggregateOutputType = {
    id: number | null
    fromUnitId: number | null
    toUnitId: number | null
    conversionRate: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitConversionMaxAggregateOutputType = {
    id: number | null
    fromUnitId: number | null
    toUnitId: number | null
    conversionRate: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitConversionCountAggregateOutputType = {
    id: number
    fromUnitId: number
    toUnitId: number
    conversionRate: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitConversionAvgAggregateInputType = {
    id?: true
    fromUnitId?: true
    toUnitId?: true
    conversionRate?: true
    companyId?: true
  }

  export type UnitConversionSumAggregateInputType = {
    id?: true
    fromUnitId?: true
    toUnitId?: true
    conversionRate?: true
    companyId?: true
  }

  export type UnitConversionMinAggregateInputType = {
    id?: true
    fromUnitId?: true
    toUnitId?: true
    conversionRate?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitConversionMaxAggregateInputType = {
    id?: true
    fromUnitId?: true
    toUnitId?: true
    conversionRate?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitConversionCountAggregateInputType = {
    id?: true
    fromUnitId?: true
    toUnitId?: true
    conversionRate?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitConversionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitConversion to aggregate.
     */
    where?: UnitConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitConversions to fetch.
     */
    orderBy?: UnitConversionOrderByWithRelationInput | UnitConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitConversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitConversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitConversions
    **/
    _count?: true | UnitConversionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitConversionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitConversionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitConversionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitConversionMaxAggregateInputType
  }

  export type GetUnitConversionAggregateType<T extends UnitConversionAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitConversion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitConversion[P]>
      : GetScalarType<T[P], AggregateUnitConversion[P]>
  }




  export type UnitConversionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitConversionWhereInput
    orderBy?: UnitConversionOrderByWithAggregationInput | UnitConversionOrderByWithAggregationInput[]
    by: UnitConversionScalarFieldEnum[] | UnitConversionScalarFieldEnum
    having?: UnitConversionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitConversionCountAggregateInputType | true
    _avg?: UnitConversionAvgAggregateInputType
    _sum?: UnitConversionSumAggregateInputType
    _min?: UnitConversionMinAggregateInputType
    _max?: UnitConversionMaxAggregateInputType
  }

  export type UnitConversionGroupByOutputType = {
    id: number
    fromUnitId: number
    toUnitId: number
    conversionRate: number
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: UnitConversionCountAggregateOutputType | null
    _avg: UnitConversionAvgAggregateOutputType | null
    _sum: UnitConversionSumAggregateOutputType | null
    _min: UnitConversionMinAggregateOutputType | null
    _max: UnitConversionMaxAggregateOutputType | null
  }

  type GetUnitConversionGroupByPayload<T extends UnitConversionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitConversionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitConversionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitConversionGroupByOutputType[P]>
            : GetScalarType<T[P], UnitConversionGroupByOutputType[P]>
        }
      >
    >


  export type UnitConversionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUnitId?: boolean
    toUnitId?: boolean
    conversionRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fromUnit?: boolean | UnitDefaultArgs<ExtArgs>
    toUnit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitConversion"]>

  export type UnitConversionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUnitId?: boolean
    toUnitId?: boolean
    conversionRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fromUnit?: boolean | UnitDefaultArgs<ExtArgs>
    toUnit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitConversion"]>

  export type UnitConversionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUnitId?: boolean
    toUnitId?: boolean
    conversionRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fromUnit?: boolean | UnitDefaultArgs<ExtArgs>
    toUnit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unitConversion"]>

  export type UnitConversionSelectScalar = {
    id?: boolean
    fromUnitId?: boolean
    toUnitId?: boolean
    conversionRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitConversionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromUnitId" | "toUnitId" | "conversionRate" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["unitConversion"]>
  export type UnitConversionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fromUnit?: boolean | UnitDefaultArgs<ExtArgs>
    toUnit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitConversionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fromUnit?: boolean | UnitDefaultArgs<ExtArgs>
    toUnit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type UnitConversionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    fromUnit?: boolean | UnitDefaultArgs<ExtArgs>
    toUnit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $UnitConversionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnitConversion"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      fromUnit: Prisma.$UnitPayload<ExtArgs>
      toUnit: Prisma.$UnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fromUnitId: number
      toUnitId: number
      conversionRate: number
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unitConversion"]>
    composites: {}
  }

  type UnitConversionGetPayload<S extends boolean | null | undefined | UnitConversionDefaultArgs> = $Result.GetResult<Prisma.$UnitConversionPayload, S>

  type UnitConversionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitConversionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitConversionCountAggregateInputType | true
    }

  export interface UnitConversionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnitConversion'], meta: { name: 'UnitConversion' } }
    /**
     * Find zero or one UnitConversion that matches the filter.
     * @param {UnitConversionFindUniqueArgs} args - Arguments to find a UnitConversion
     * @example
     * // Get one UnitConversion
     * const unitConversion = await prisma.unitConversion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitConversionFindUniqueArgs>(args: SelectSubset<T, UnitConversionFindUniqueArgs<ExtArgs>>): Prisma__UnitConversionClient<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UnitConversion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitConversionFindUniqueOrThrowArgs} args - Arguments to find a UnitConversion
     * @example
     * // Get one UnitConversion
     * const unitConversion = await prisma.unitConversion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitConversionFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitConversionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitConversionClient<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitConversion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConversionFindFirstArgs} args - Arguments to find a UnitConversion
     * @example
     * // Get one UnitConversion
     * const unitConversion = await prisma.unitConversion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitConversionFindFirstArgs>(args?: SelectSubset<T, UnitConversionFindFirstArgs<ExtArgs>>): Prisma__UnitConversionClient<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UnitConversion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConversionFindFirstOrThrowArgs} args - Arguments to find a UnitConversion
     * @example
     * // Get one UnitConversion
     * const unitConversion = await prisma.unitConversion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitConversionFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitConversionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitConversionClient<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UnitConversions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConversionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitConversions
     * const unitConversions = await prisma.unitConversion.findMany()
     * 
     * // Get first 10 UnitConversions
     * const unitConversions = await prisma.unitConversion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitConversionWithIdOnly = await prisma.unitConversion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnitConversionFindManyArgs>(args?: SelectSubset<T, UnitConversionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UnitConversion.
     * @param {UnitConversionCreateArgs} args - Arguments to create a UnitConversion.
     * @example
     * // Create one UnitConversion
     * const UnitConversion = await prisma.unitConversion.create({
     *   data: {
     *     // ... data to create a UnitConversion
     *   }
     * })
     * 
     */
    create<T extends UnitConversionCreateArgs>(args: SelectSubset<T, UnitConversionCreateArgs<ExtArgs>>): Prisma__UnitConversionClient<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UnitConversions.
     * @param {UnitConversionCreateManyArgs} args - Arguments to create many UnitConversions.
     * @example
     * // Create many UnitConversions
     * const unitConversion = await prisma.unitConversion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitConversionCreateManyArgs>(args?: SelectSubset<T, UnitConversionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnitConversions and returns the data saved in the database.
     * @param {UnitConversionCreateManyAndReturnArgs} args - Arguments to create many UnitConversions.
     * @example
     * // Create many UnitConversions
     * const unitConversion = await prisma.unitConversion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnitConversions and only return the `id`
     * const unitConversionWithIdOnly = await prisma.unitConversion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitConversionCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitConversionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UnitConversion.
     * @param {UnitConversionDeleteArgs} args - Arguments to delete one UnitConversion.
     * @example
     * // Delete one UnitConversion
     * const UnitConversion = await prisma.unitConversion.delete({
     *   where: {
     *     // ... filter to delete one UnitConversion
     *   }
     * })
     * 
     */
    delete<T extends UnitConversionDeleteArgs>(args: SelectSubset<T, UnitConversionDeleteArgs<ExtArgs>>): Prisma__UnitConversionClient<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UnitConversion.
     * @param {UnitConversionUpdateArgs} args - Arguments to update one UnitConversion.
     * @example
     * // Update one UnitConversion
     * const unitConversion = await prisma.unitConversion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitConversionUpdateArgs>(args: SelectSubset<T, UnitConversionUpdateArgs<ExtArgs>>): Prisma__UnitConversionClient<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UnitConversions.
     * @param {UnitConversionDeleteManyArgs} args - Arguments to filter UnitConversions to delete.
     * @example
     * // Delete a few UnitConversions
     * const { count } = await prisma.unitConversion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitConversionDeleteManyArgs>(args?: SelectSubset<T, UnitConversionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitConversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConversionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitConversions
     * const unitConversion = await prisma.unitConversion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitConversionUpdateManyArgs>(args: SelectSubset<T, UnitConversionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitConversions and returns the data updated in the database.
     * @param {UnitConversionUpdateManyAndReturnArgs} args - Arguments to update many UnitConversions.
     * @example
     * // Update many UnitConversions
     * const unitConversion = await prisma.unitConversion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UnitConversions and only return the `id`
     * const unitConversionWithIdOnly = await prisma.unitConversion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitConversionUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitConversionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UnitConversion.
     * @param {UnitConversionUpsertArgs} args - Arguments to update or create a UnitConversion.
     * @example
     * // Update or create a UnitConversion
     * const unitConversion = await prisma.unitConversion.upsert({
     *   create: {
     *     // ... data to create a UnitConversion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitConversion we want to update
     *   }
     * })
     */
    upsert<T extends UnitConversionUpsertArgs>(args: SelectSubset<T, UnitConversionUpsertArgs<ExtArgs>>): Prisma__UnitConversionClient<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UnitConversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConversionCountArgs} args - Arguments to filter UnitConversions to count.
     * @example
     * // Count the number of UnitConversions
     * const count = await prisma.unitConversion.count({
     *   where: {
     *     // ... the filter for the UnitConversions we want to count
     *   }
     * })
    **/
    count<T extends UnitConversionCountArgs>(
      args?: Subset<T, UnitConversionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitConversionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitConversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConversionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitConversionAggregateArgs>(args: Subset<T, UnitConversionAggregateArgs>): Prisma.PrismaPromise<GetUnitConversionAggregateType<T>>

    /**
     * Group by UnitConversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitConversionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitConversionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitConversionGroupByArgs['orderBy'] }
        : { orderBy?: UnitConversionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitConversionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitConversionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnitConversion model
   */
  readonly fields: UnitConversionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitConversion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitConversionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fromUnit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toUnit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnitConversion model
   */
  interface UnitConversionFieldRefs {
    readonly id: FieldRef<"UnitConversion", 'Int'>
    readonly fromUnitId: FieldRef<"UnitConversion", 'Int'>
    readonly toUnitId: FieldRef<"UnitConversion", 'Int'>
    readonly conversionRate: FieldRef<"UnitConversion", 'Float'>
    readonly companyId: FieldRef<"UnitConversion", 'Int'>
    readonly createdAt: FieldRef<"UnitConversion", 'DateTime'>
    readonly updatedAt: FieldRef<"UnitConversion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnitConversion findUnique
   */
  export type UnitConversionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    /**
     * Filter, which UnitConversion to fetch.
     */
    where: UnitConversionWhereUniqueInput
  }

  /**
   * UnitConversion findUniqueOrThrow
   */
  export type UnitConversionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    /**
     * Filter, which UnitConversion to fetch.
     */
    where: UnitConversionWhereUniqueInput
  }

  /**
   * UnitConversion findFirst
   */
  export type UnitConversionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    /**
     * Filter, which UnitConversion to fetch.
     */
    where?: UnitConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitConversions to fetch.
     */
    orderBy?: UnitConversionOrderByWithRelationInput | UnitConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitConversions.
     */
    cursor?: UnitConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitConversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitConversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitConversions.
     */
    distinct?: UnitConversionScalarFieldEnum | UnitConversionScalarFieldEnum[]
  }

  /**
   * UnitConversion findFirstOrThrow
   */
  export type UnitConversionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    /**
     * Filter, which UnitConversion to fetch.
     */
    where?: UnitConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitConversions to fetch.
     */
    orderBy?: UnitConversionOrderByWithRelationInput | UnitConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitConversions.
     */
    cursor?: UnitConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitConversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitConversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitConversions.
     */
    distinct?: UnitConversionScalarFieldEnum | UnitConversionScalarFieldEnum[]
  }

  /**
   * UnitConversion findMany
   */
  export type UnitConversionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    /**
     * Filter, which UnitConversions to fetch.
     */
    where?: UnitConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitConversions to fetch.
     */
    orderBy?: UnitConversionOrderByWithRelationInput | UnitConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitConversions.
     */
    cursor?: UnitConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitConversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitConversions.
     */
    skip?: number
    distinct?: UnitConversionScalarFieldEnum | UnitConversionScalarFieldEnum[]
  }

  /**
   * UnitConversion create
   */
  export type UnitConversionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    /**
     * The data needed to create a UnitConversion.
     */
    data: XOR<UnitConversionCreateInput, UnitConversionUncheckedCreateInput>
  }

  /**
   * UnitConversion createMany
   */
  export type UnitConversionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnitConversions.
     */
    data: UnitConversionCreateManyInput | UnitConversionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnitConversion createManyAndReturn
   */
  export type UnitConversionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * The data used to create many UnitConversions.
     */
    data: UnitConversionCreateManyInput | UnitConversionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitConversion update
   */
  export type UnitConversionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    /**
     * The data needed to update a UnitConversion.
     */
    data: XOR<UnitConversionUpdateInput, UnitConversionUncheckedUpdateInput>
    /**
     * Choose, which UnitConversion to update.
     */
    where: UnitConversionWhereUniqueInput
  }

  /**
   * UnitConversion updateMany
   */
  export type UnitConversionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnitConversions.
     */
    data: XOR<UnitConversionUpdateManyMutationInput, UnitConversionUncheckedUpdateManyInput>
    /**
     * Filter which UnitConversions to update
     */
    where?: UnitConversionWhereInput
    /**
     * Limit how many UnitConversions to update.
     */
    limit?: number
  }

  /**
   * UnitConversion updateManyAndReturn
   */
  export type UnitConversionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * The data used to update UnitConversions.
     */
    data: XOR<UnitConversionUpdateManyMutationInput, UnitConversionUncheckedUpdateManyInput>
    /**
     * Filter which UnitConversions to update
     */
    where?: UnitConversionWhereInput
    /**
     * Limit how many UnitConversions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UnitConversion upsert
   */
  export type UnitConversionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    /**
     * The filter to search for the UnitConversion to update in case it exists.
     */
    where: UnitConversionWhereUniqueInput
    /**
     * In case the UnitConversion found by the `where` argument doesn't exist, create a new UnitConversion with this data.
     */
    create: XOR<UnitConversionCreateInput, UnitConversionUncheckedCreateInput>
    /**
     * In case the UnitConversion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitConversionUpdateInput, UnitConversionUncheckedUpdateInput>
  }

  /**
   * UnitConversion delete
   */
  export type UnitConversionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    /**
     * Filter which UnitConversion to delete.
     */
    where: UnitConversionWhereUniqueInput
  }

  /**
   * UnitConversion deleteMany
   */
  export type UnitConversionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnitConversions to delete
     */
    where?: UnitConversionWhereInput
    /**
     * Limit how many UnitConversions to delete.
     */
    limit?: number
  }

  /**
   * UnitConversion without action
   */
  export type UnitConversionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    legalName: string | null
    tradeName: string | null
    address: string | null
    country: string | null
    phone: string | null
    email: string | null
    taxId: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    legalName: string | null
    tradeName: string | null
    address: string | null
    country: string | null
    phone: string | null
    email: string | null
    taxId: string | null
    logoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    legalName: number
    tradeName: number
    address: number
    country: number
    phone: number
    email: number
    taxId: number
    logoUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    legalName?: true
    tradeName?: true
    address?: true
    country?: true
    phone?: true
    email?: true
    taxId?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    legalName?: true
    tradeName?: true
    address?: true
    country?: true
    phone?: true
    email?: true
    taxId?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    legalName?: true
    tradeName?: true
    address?: true
    country?: true
    phone?: true
    email?: true
    taxId?: true
    logoUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    legalName: string
    tradeName: string | null
    address: string | null
    country: string | null
    phone: string | null
    email: string | null
    taxId: string | null
    logoUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    legalName?: boolean
    tradeName?: boolean
    address?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itemGroups?: boolean | Company$itemGroupsArgs<ExtArgs>
    colors?: boolean | Company$colorsArgs<ExtArgs>
    brands?: boolean | Company$brandsArgs<ExtArgs>
    units?: boolean | Company$unitsArgs<ExtArgs>
    itemGrades?: boolean | Company$itemGradesArgs<ExtArgs>
    unitConversions?: boolean | Company$unitConversionsArgs<ExtArgs>
    itemMasters?: boolean | Company$itemMastersArgs<ExtArgs>
    purchaseOrders?: boolean | Company$purchaseOrdersArgs<ExtArgs>
    grns?: boolean | Company$grnsArgs<ExtArgs>
    purchaseInvoices?: boolean | Company$purchaseInvoicesArgs<ExtArgs>
    purchaseReturns?: boolean | Company$purchaseReturnsArgs<ExtArgs>
    packingUnits?: boolean | Company$packingUnitsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    legalName?: boolean
    tradeName?: boolean
    address?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    legalName?: boolean
    tradeName?: boolean
    address?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    legalName?: boolean
    tradeName?: boolean
    address?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    taxId?: boolean
    logoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "legalName" | "tradeName" | "address" | "country" | "phone" | "email" | "taxId" | "logoUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemGroups?: boolean | Company$itemGroupsArgs<ExtArgs>
    colors?: boolean | Company$colorsArgs<ExtArgs>
    brands?: boolean | Company$brandsArgs<ExtArgs>
    units?: boolean | Company$unitsArgs<ExtArgs>
    itemGrades?: boolean | Company$itemGradesArgs<ExtArgs>
    unitConversions?: boolean | Company$unitConversionsArgs<ExtArgs>
    itemMasters?: boolean | Company$itemMastersArgs<ExtArgs>
    purchaseOrders?: boolean | Company$purchaseOrdersArgs<ExtArgs>
    grns?: boolean | Company$grnsArgs<ExtArgs>
    purchaseInvoices?: boolean | Company$purchaseInvoicesArgs<ExtArgs>
    purchaseReturns?: boolean | Company$purchaseReturnsArgs<ExtArgs>
    packingUnits?: boolean | Company$packingUnitsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      itemGroups: Prisma.$ItemGroupPayload<ExtArgs>[]
      colors: Prisma.$ColorPayload<ExtArgs>[]
      brands: Prisma.$BrandPayload<ExtArgs>[]
      units: Prisma.$UnitPayload<ExtArgs>[]
      itemGrades: Prisma.$ItemGradePayload<ExtArgs>[]
      unitConversions: Prisma.$UnitConversionPayload<ExtArgs>[]
      itemMasters: Prisma.$ItemMasterPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      grns: Prisma.$GRNPayload<ExtArgs>[]
      purchaseInvoices: Prisma.$PurchaseInvoicePayload<ExtArgs>[]
      purchaseReturns: Prisma.$PurchaseReturnPayload<ExtArgs>[]
      packingUnits: Prisma.$PackingUnitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      legalName: string
      tradeName: string | null
      address: string | null
      country: string | null
      phone: string | null
      email: string | null
      taxId: string | null
      logoUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemGroups<T extends Company$itemGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Company$itemGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    colors<T extends Company$colorsArgs<ExtArgs> = {}>(args?: Subset<T, Company$colorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    brands<T extends Company$brandsArgs<ExtArgs> = {}>(args?: Subset<T, Company$brandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    units<T extends Company$unitsArgs<ExtArgs> = {}>(args?: Subset<T, Company$unitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    itemGrades<T extends Company$itemGradesArgs<ExtArgs> = {}>(args?: Subset<T, Company$itemGradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unitConversions<T extends Company$unitConversionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$unitConversionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitConversionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    itemMasters<T extends Company$itemMastersArgs<ExtArgs> = {}>(args?: Subset<T, Company$itemMastersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Company$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Company$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grns<T extends Company$grnsArgs<ExtArgs> = {}>(args?: Subset<T, Company$grnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoices<T extends Company$purchaseInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Company$purchaseInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturns<T extends Company$purchaseReturnsArgs<ExtArgs> = {}>(args?: Subset<T, Company$purchaseReturnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    packingUnits<T extends Company$packingUnitsArgs<ExtArgs> = {}>(args?: Subset<T, Company$packingUnitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly legalName: FieldRef<"Company", 'String'>
    readonly tradeName: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly country: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly taxId: FieldRef<"Company", 'String'>
    readonly logoUrl: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.itemGroups
   */
  export type Company$itemGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    where?: ItemGroupWhereInput
    orderBy?: ItemGroupOrderByWithRelationInput | ItemGroupOrderByWithRelationInput[]
    cursor?: ItemGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemGroupScalarFieldEnum | ItemGroupScalarFieldEnum[]
  }

  /**
   * Company.colors
   */
  export type Company$colorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    where?: ColorWhereInput
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    cursor?: ColorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Company.brands
   */
  export type Company$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    cursor?: BrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Company.units
   */
  export type Company$unitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Company.itemGrades
   */
  export type Company$itemGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    where?: ItemGradeWhereInput
    orderBy?: ItemGradeOrderByWithRelationInput | ItemGradeOrderByWithRelationInput[]
    cursor?: ItemGradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemGradeScalarFieldEnum | ItemGradeScalarFieldEnum[]
  }

  /**
   * Company.unitConversions
   */
  export type Company$unitConversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitConversion
     */
    select?: UnitConversionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UnitConversion
     */
    omit?: UnitConversionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitConversionInclude<ExtArgs> | null
    where?: UnitConversionWhereInput
    orderBy?: UnitConversionOrderByWithRelationInput | UnitConversionOrderByWithRelationInput[]
    cursor?: UnitConversionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitConversionScalarFieldEnum | UnitConversionScalarFieldEnum[]
  }

  /**
   * Company.itemMasters
   */
  export type Company$itemMastersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    where?: ItemMasterWhereInput
    orderBy?: ItemMasterOrderByWithRelationInput | ItemMasterOrderByWithRelationInput[]
    cursor?: ItemMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemMasterScalarFieldEnum | ItemMasterScalarFieldEnum[]
  }

  /**
   * Company.purchaseOrders
   */
  export type Company$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Company.grns
   */
  export type Company$grnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    where?: GRNWhereInput
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    cursor?: GRNWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * Company.purchaseInvoices
   */
  export type Company$purchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * Company.purchaseReturns
   */
  export type Company$purchaseReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    where?: PurchaseReturnWhereInput
    orderBy?: PurchaseReturnOrderByWithRelationInput | PurchaseReturnOrderByWithRelationInput[]
    cursor?: PurchaseReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnScalarFieldEnum | PurchaseReturnScalarFieldEnum[]
  }

  /**
   * Company.packingUnits
   */
  export type Company$packingUnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    where?: PackingUnitWhereInput
    orderBy?: PackingUnitOrderByWithRelationInput | PackingUnitOrderByWithRelationInput[]
    cursor?: PackingUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackingUnitScalarFieldEnum | PackingUnitScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model FiscalYear
   */

  export type AggregateFiscalYear = {
    _count: FiscalYearCountAggregateOutputType | null
    _avg: FiscalYearAvgAggregateOutputType | null
    _sum: FiscalYearSumAggregateOutputType | null
    _min: FiscalYearMinAggregateOutputType | null
    _max: FiscalYearMaxAggregateOutputType | null
  }

  export type FiscalYearAvgAggregateOutputType = {
    id: number | null
  }

  export type FiscalYearSumAggregateOutputType = {
    id: number | null
  }

  export type FiscalYearMinAggregateOutputType = {
    id: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalYearMaxAggregateOutputType = {
    id: number | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isLocked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FiscalYearCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    isActive: number
    isLocked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FiscalYearAvgAggregateInputType = {
    id?: true
  }

  export type FiscalYearSumAggregateInputType = {
    id?: true
  }

  export type FiscalYearMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalYearMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FiscalYearCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isLocked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FiscalYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalYear to aggregate.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FiscalYears
    **/
    _count?: true | FiscalYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FiscalYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FiscalYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiscalYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiscalYearMaxAggregateInputType
  }

  export type GetFiscalYearAggregateType<T extends FiscalYearAggregateArgs> = {
        [P in keyof T & keyof AggregateFiscalYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiscalYear[P]>
      : GetScalarType<T[P], AggregateFiscalYear[P]>
  }




  export type FiscalYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FiscalYearWhereInput
    orderBy?: FiscalYearOrderByWithAggregationInput | FiscalYearOrderByWithAggregationInput[]
    by: FiscalYearScalarFieldEnum[] | FiscalYearScalarFieldEnum
    having?: FiscalYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiscalYearCountAggregateInputType | true
    _avg?: FiscalYearAvgAggregateInputType
    _sum?: FiscalYearSumAggregateInputType
    _min?: FiscalYearMinAggregateInputType
    _max?: FiscalYearMaxAggregateInputType
  }

  export type FiscalYearGroupByOutputType = {
    id: number
    name: string
    startDate: Date
    endDate: Date
    isActive: boolean
    isLocked: boolean
    createdAt: Date
    updatedAt: Date
    _count: FiscalYearCountAggregateOutputType | null
    _avg: FiscalYearAvgAggregateOutputType | null
    _sum: FiscalYearSumAggregateOutputType | null
    _min: FiscalYearMinAggregateOutputType | null
    _max: FiscalYearMaxAggregateOutputType | null
  }

  type GetFiscalYearGroupByPayload<T extends FiscalYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FiscalYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiscalYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiscalYearGroupByOutputType[P]>
            : GetScalarType<T[P], FiscalYearGroupByOutputType[P]>
        }
      >
    >


  export type FiscalYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    journalEntries?: boolean | FiscalYear$journalEntriesArgs<ExtArgs>
    _count?: boolean | FiscalYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalYear"]>

  export type FiscalYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fiscalYear"]>

  export type FiscalYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fiscalYear"]>

  export type FiscalYearSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isLocked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FiscalYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startDate" | "endDate" | "isActive" | "isLocked" | "createdAt" | "updatedAt", ExtArgs["result"]["fiscalYear"]>
  export type FiscalYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journalEntries?: boolean | FiscalYear$journalEntriesArgs<ExtArgs>
    _count?: boolean | FiscalYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FiscalYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FiscalYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FiscalYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FiscalYear"
    objects: {
      journalEntries: Prisma.$JournalEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      startDate: Date
      endDate: Date
      isActive: boolean
      isLocked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fiscalYear"]>
    composites: {}
  }

  type FiscalYearGetPayload<S extends boolean | null | undefined | FiscalYearDefaultArgs> = $Result.GetResult<Prisma.$FiscalYearPayload, S>

  type FiscalYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FiscalYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FiscalYearCountAggregateInputType | true
    }

  export interface FiscalYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FiscalYear'], meta: { name: 'FiscalYear' } }
    /**
     * Find zero or one FiscalYear that matches the filter.
     * @param {FiscalYearFindUniqueArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FiscalYearFindUniqueArgs>(args: SelectSubset<T, FiscalYearFindUniqueArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FiscalYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FiscalYearFindUniqueOrThrowArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FiscalYearFindUniqueOrThrowArgs>(args: SelectSubset<T, FiscalYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FiscalYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearFindFirstArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FiscalYearFindFirstArgs>(args?: SelectSubset<T, FiscalYearFindFirstArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FiscalYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearFindFirstOrThrowArgs} args - Arguments to find a FiscalYear
     * @example
     * // Get one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FiscalYearFindFirstOrThrowArgs>(args?: SelectSubset<T, FiscalYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FiscalYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FiscalYears
     * const fiscalYears = await prisma.fiscalYear.findMany()
     * 
     * // Get first 10 FiscalYears
     * const fiscalYears = await prisma.fiscalYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fiscalYearWithIdOnly = await prisma.fiscalYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FiscalYearFindManyArgs>(args?: SelectSubset<T, FiscalYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FiscalYear.
     * @param {FiscalYearCreateArgs} args - Arguments to create a FiscalYear.
     * @example
     * // Create one FiscalYear
     * const FiscalYear = await prisma.fiscalYear.create({
     *   data: {
     *     // ... data to create a FiscalYear
     *   }
     * })
     * 
     */
    create<T extends FiscalYearCreateArgs>(args: SelectSubset<T, FiscalYearCreateArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FiscalYears.
     * @param {FiscalYearCreateManyArgs} args - Arguments to create many FiscalYears.
     * @example
     * // Create many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FiscalYearCreateManyArgs>(args?: SelectSubset<T, FiscalYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FiscalYears and returns the data saved in the database.
     * @param {FiscalYearCreateManyAndReturnArgs} args - Arguments to create many FiscalYears.
     * @example
     * // Create many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FiscalYears and only return the `id`
     * const fiscalYearWithIdOnly = await prisma.fiscalYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FiscalYearCreateManyAndReturnArgs>(args?: SelectSubset<T, FiscalYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FiscalYear.
     * @param {FiscalYearDeleteArgs} args - Arguments to delete one FiscalYear.
     * @example
     * // Delete one FiscalYear
     * const FiscalYear = await prisma.fiscalYear.delete({
     *   where: {
     *     // ... filter to delete one FiscalYear
     *   }
     * })
     * 
     */
    delete<T extends FiscalYearDeleteArgs>(args: SelectSubset<T, FiscalYearDeleteArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FiscalYear.
     * @param {FiscalYearUpdateArgs} args - Arguments to update one FiscalYear.
     * @example
     * // Update one FiscalYear
     * const fiscalYear = await prisma.fiscalYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FiscalYearUpdateArgs>(args: SelectSubset<T, FiscalYearUpdateArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FiscalYears.
     * @param {FiscalYearDeleteManyArgs} args - Arguments to filter FiscalYears to delete.
     * @example
     * // Delete a few FiscalYears
     * const { count } = await prisma.fiscalYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FiscalYearDeleteManyArgs>(args?: SelectSubset<T, FiscalYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiscalYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FiscalYearUpdateManyArgs>(args: SelectSubset<T, FiscalYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiscalYears and returns the data updated in the database.
     * @param {FiscalYearUpdateManyAndReturnArgs} args - Arguments to update many FiscalYears.
     * @example
     * // Update many FiscalYears
     * const fiscalYear = await prisma.fiscalYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FiscalYears and only return the `id`
     * const fiscalYearWithIdOnly = await prisma.fiscalYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FiscalYearUpdateManyAndReturnArgs>(args: SelectSubset<T, FiscalYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FiscalYear.
     * @param {FiscalYearUpsertArgs} args - Arguments to update or create a FiscalYear.
     * @example
     * // Update or create a FiscalYear
     * const fiscalYear = await prisma.fiscalYear.upsert({
     *   create: {
     *     // ... data to create a FiscalYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FiscalYear we want to update
     *   }
     * })
     */
    upsert<T extends FiscalYearUpsertArgs>(args: SelectSubset<T, FiscalYearUpsertArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FiscalYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearCountArgs} args - Arguments to filter FiscalYears to count.
     * @example
     * // Count the number of FiscalYears
     * const count = await prisma.fiscalYear.count({
     *   where: {
     *     // ... the filter for the FiscalYears we want to count
     *   }
     * })
    **/
    count<T extends FiscalYearCountArgs>(
      args?: Subset<T, FiscalYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiscalYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FiscalYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiscalYearAggregateArgs>(args: Subset<T, FiscalYearAggregateArgs>): Prisma.PrismaPromise<GetFiscalYearAggregateType<T>>

    /**
     * Group by FiscalYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FiscalYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FiscalYearGroupByArgs['orderBy'] }
        : { orderBy?: FiscalYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FiscalYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiscalYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FiscalYear model
   */
  readonly fields: FiscalYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FiscalYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FiscalYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journalEntries<T extends FiscalYear$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, FiscalYear$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FiscalYear model
   */
  interface FiscalYearFieldRefs {
    readonly id: FieldRef<"FiscalYear", 'Int'>
    readonly name: FieldRef<"FiscalYear", 'String'>
    readonly startDate: FieldRef<"FiscalYear", 'DateTime'>
    readonly endDate: FieldRef<"FiscalYear", 'DateTime'>
    readonly isActive: FieldRef<"FiscalYear", 'Boolean'>
    readonly isLocked: FieldRef<"FiscalYear", 'Boolean'>
    readonly createdAt: FieldRef<"FiscalYear", 'DateTime'>
    readonly updatedAt: FieldRef<"FiscalYear", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FiscalYear findUnique
   */
  export type FiscalYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear findUniqueOrThrow
   */
  export type FiscalYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear findFirst
   */
  export type FiscalYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalYears.
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalYears.
     */
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * FiscalYear findFirstOrThrow
   */
  export type FiscalYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYear to fetch.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FiscalYears.
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FiscalYears.
     */
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * FiscalYear findMany
   */
  export type FiscalYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter, which FiscalYears to fetch.
     */
    where?: FiscalYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FiscalYears to fetch.
     */
    orderBy?: FiscalYearOrderByWithRelationInput | FiscalYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FiscalYears.
     */
    cursor?: FiscalYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FiscalYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FiscalYears.
     */
    skip?: number
    distinct?: FiscalYearScalarFieldEnum | FiscalYearScalarFieldEnum[]
  }

  /**
   * FiscalYear create
   */
  export type FiscalYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * The data needed to create a FiscalYear.
     */
    data: XOR<FiscalYearCreateInput, FiscalYearUncheckedCreateInput>
  }

  /**
   * FiscalYear createMany
   */
  export type FiscalYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FiscalYears.
     */
    data: FiscalYearCreateManyInput | FiscalYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FiscalYear createManyAndReturn
   */
  export type FiscalYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * The data used to create many FiscalYears.
     */
    data: FiscalYearCreateManyInput | FiscalYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FiscalYear update
   */
  export type FiscalYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * The data needed to update a FiscalYear.
     */
    data: XOR<FiscalYearUpdateInput, FiscalYearUncheckedUpdateInput>
    /**
     * Choose, which FiscalYear to update.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear updateMany
   */
  export type FiscalYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FiscalYears.
     */
    data: XOR<FiscalYearUpdateManyMutationInput, FiscalYearUncheckedUpdateManyInput>
    /**
     * Filter which FiscalYears to update
     */
    where?: FiscalYearWhereInput
    /**
     * Limit how many FiscalYears to update.
     */
    limit?: number
  }

  /**
   * FiscalYear updateManyAndReturn
   */
  export type FiscalYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * The data used to update FiscalYears.
     */
    data: XOR<FiscalYearUpdateManyMutationInput, FiscalYearUncheckedUpdateManyInput>
    /**
     * Filter which FiscalYears to update
     */
    where?: FiscalYearWhereInput
    /**
     * Limit how many FiscalYears to update.
     */
    limit?: number
  }

  /**
   * FiscalYear upsert
   */
  export type FiscalYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * The filter to search for the FiscalYear to update in case it exists.
     */
    where: FiscalYearWhereUniqueInput
    /**
     * In case the FiscalYear found by the `where` argument doesn't exist, create a new FiscalYear with this data.
     */
    create: XOR<FiscalYearCreateInput, FiscalYearUncheckedCreateInput>
    /**
     * In case the FiscalYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FiscalYearUpdateInput, FiscalYearUncheckedUpdateInput>
  }

  /**
   * FiscalYear delete
   */
  export type FiscalYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    /**
     * Filter which FiscalYear to delete.
     */
    where: FiscalYearWhereUniqueInput
  }

  /**
   * FiscalYear deleteMany
   */
  export type FiscalYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FiscalYears to delete
     */
    where?: FiscalYearWhereInput
    /**
     * Limit how many FiscalYears to delete.
     */
    limit?: number
  }

  /**
   * FiscalYear.journalEntries
   */
  export type FiscalYear$journalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * FiscalYear without action
   */
  export type FiscalYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    id: number | null
    exchangeRate: number | null
  }

  export type CurrencySumAggregateOutputType = {
    id: number | null
    exchangeRate: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: number | null
    code: string | null
    symbol: string | null
    isBase: boolean | null
    exchangeRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: number | null
    code: string | null
    symbol: string | null
    isBase: boolean | null
    exchangeRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    code: number
    symbol: number
    isBase: number
    exchangeRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    id?: true
    exchangeRate?: true
  }

  export type CurrencySumAggregateInputType = {
    id?: true
    exchangeRate?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    code?: true
    symbol?: true
    isBase?: true
    exchangeRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    code?: true
    symbol?: true
    isBase?: true
    exchangeRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    code?: true
    symbol?: true
    isBase?: true
    exchangeRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: number
    code: string
    symbol: string
    isBase: boolean
    exchangeRate: number
    createdAt: Date
    updatedAt: Date
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    symbol?: boolean
    isBase?: boolean
    exchangeRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrders?: boolean | Currency$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    symbol?: boolean
    isBase?: boolean
    exchangeRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    symbol?: boolean
    isBase?: boolean
    exchangeRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    id?: boolean
    code?: boolean
    symbol?: boolean
    isBase?: boolean
    exchangeRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "symbol" | "isBase" | "exchangeRate" | "createdAt" | "updatedAt", ExtArgs["result"]["currency"]>
  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrders?: boolean | Currency$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      symbol: string
      isBase: boolean
      exchangeRate: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {CurrencyUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrders<T extends Currency$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Currency$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'Int'>
    readonly code: FieldRef<"Currency", 'String'>
    readonly symbol: FieldRef<"Currency", 'String'>
    readonly isBase: FieldRef<"Currency", 'Boolean'>
    readonly exchangeRate: FieldRef<"Currency", 'Float'>
    readonly createdAt: FieldRef<"Currency", 'DateTime'>
    readonly updatedAt: FieldRef<"Currency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency updateManyAndReturn
   */
  export type CurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency.purchaseOrders
   */
  export type Currency$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _avg: SystemConfigAvgAggregateOutputType | null
    _sum: SystemConfigSumAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigAvgAggregateOutputType = {
    id: number | null
    quantityDecimals: number | null
    amountDecimals: number | null
    rateDecimals: number | null
  }

  export type SystemConfigSumAggregateOutputType = {
    id: number | null
    quantityDecimals: number | null
    amountDecimals: number | null
    rateDecimals: number | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: number | null
    quantityDecimals: number | null
    amountDecimals: number | null
    rateDecimals: number | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: number | null
    quantityDecimals: number | null
    amountDecimals: number | null
    rateDecimals: number | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    quantityDecimals: number
    amountDecimals: number
    rateDecimals: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigAvgAggregateInputType = {
    id?: true
    quantityDecimals?: true
    amountDecimals?: true
    rateDecimals?: true
  }

  export type SystemConfigSumAggregateInputType = {
    id?: true
    quantityDecimals?: true
    amountDecimals?: true
    rateDecimals?: true
  }

  export type SystemConfigMinAggregateInputType = {
    id?: true
    quantityDecimals?: true
    amountDecimals?: true
    rateDecimals?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    quantityDecimals?: true
    amountDecimals?: true
    rateDecimals?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    quantityDecimals?: true
    amountDecimals?: true
    rateDecimals?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _avg?: SystemConfigAvgAggregateInputType
    _sum?: SystemConfigSumAggregateInputType
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: number
    quantityDecimals: number
    amountDecimals: number
    rateDecimals: number
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _avg: SystemConfigAvgAggregateOutputType | null
    _sum: SystemConfigSumAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantityDecimals?: boolean
    amountDecimals?: boolean
    rateDecimals?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantityDecimals?: boolean
    amountDecimals?: boolean
    rateDecimals?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantityDecimals?: boolean
    amountDecimals?: boolean
    rateDecimals?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    quantityDecimals?: boolean
    amountDecimals?: boolean
    rateDecimals?: boolean
    updatedAt?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantityDecimals" | "amountDecimals" | "rateDecimals" | "updatedAt", ExtArgs["result"]["systemConfig"]>

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quantityDecimals: number
      amountDecimals: number
      rateDecimals: number
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'Int'>
    readonly quantityDecimals: FieldRef<"SystemConfig", 'Int'>
    readonly amountDecimals: FieldRef<"SystemConfig", 'Int'>
    readonly rateDecimals: FieldRef<"SystemConfig", 'Int'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    key: number
    value: number
    description: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    key?: true
    value?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    key: string
    value: string
    description: string | null
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>

  export type SystemSettingSelectScalar = {
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "description" | "updatedAt", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const systemSettingWithKeyOnly = await prisma.systemSetting.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `key`
     * const systemSettingWithKeyOnly = await prisma.systemSetting.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `key`
     * const systemSettingWithKeyOnly = await prisma.systemSetting.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly description: FieldRef<"SystemSetting", 'String'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting createManyAndReturn
   */
  export type SystemSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting updateManyAndReturn
   */
  export type SystemSettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    code: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly code: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    unitId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    unitId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    description: string | null
    type: $Enums.ProductType | null
    categoryId: number | null
    unitId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    description: string | null
    type: $Enums.ProductType | null
    categoryId: number | null
    unitId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    type: number
    categoryId: number
    unitId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    categoryId?: true
    unitId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    categoryId?: true
    unitId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    type?: true
    categoryId?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    type?: true
    categoryId?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    type?: true
    categoryId?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    code: string
    description: string | null
    type: $Enums.ProductType
    categoryId: number
    unitId: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "type" | "categoryId" | "unitId" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    unit?: boolean | UnitDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      unit: Prisma.$UnitPayload<ExtArgs>
      variants: Prisma.$VariantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      description: string | null
      type: $Enums.ProductType
      categoryId: number
      unitId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    unit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly categoryId: FieldRef<"Product", 'Int'>
    readonly unitId: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    where?: VariantWhereInput
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    cursor?: VariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Variant
   */

  export type AggregateVariant = {
    _count: VariantCountAggregateOutputType | null
    _avg: VariantAvgAggregateOutputType | null
    _sum: VariantSumAggregateOutputType | null
    _min: VariantMinAggregateOutputType | null
    _max: VariantMaxAggregateOutputType | null
  }

  export type VariantAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    price: number | null
    stock: number | null
  }

  export type VariantSumAggregateOutputType = {
    id: number | null
    productId: number | null
    price: number | null
    stock: number | null
  }

  export type VariantMinAggregateOutputType = {
    id: number | null
    name: string | null
    sku: string | null
    productId: number | null
    color: string | null
    count: string | null
    gsm: string | null
    width: string | null
    shade: string | null
    weave: string | null
    finish: string | null
    type: string | null
    price: number | null
    stock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariantMaxAggregateOutputType = {
    id: number | null
    name: string | null
    sku: string | null
    productId: number | null
    color: string | null
    count: string | null
    gsm: string | null
    width: string | null
    shade: string | null
    weave: string | null
    finish: string | null
    type: string | null
    price: number | null
    stock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariantCountAggregateOutputType = {
    id: number
    name: number
    sku: number
    productId: number
    color: number
    count: number
    gsm: number
    width: number
    shade: number
    weave: number
    finish: number
    type: number
    price: number
    stock: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VariantAvgAggregateInputType = {
    id?: true
    productId?: true
    price?: true
    stock?: true
  }

  export type VariantSumAggregateInputType = {
    id?: true
    productId?: true
    price?: true
    stock?: true
  }

  export type VariantMinAggregateInputType = {
    id?: true
    name?: true
    sku?: true
    productId?: true
    color?: true
    count?: true
    gsm?: true
    width?: true
    shade?: true
    weave?: true
    finish?: true
    type?: true
    price?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariantMaxAggregateInputType = {
    id?: true
    name?: true
    sku?: true
    productId?: true
    color?: true
    count?: true
    gsm?: true
    width?: true
    shade?: true
    weave?: true
    finish?: true
    type?: true
    price?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariantCountAggregateInputType = {
    id?: true
    name?: true
    sku?: true
    productId?: true
    color?: true
    count?: true
    gsm?: true
    width?: true
    shade?: true
    weave?: true
    finish?: true
    type?: true
    price?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variant to aggregate.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Variants
    **/
    _count?: true | VariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariantMaxAggregateInputType
  }

  export type GetVariantAggregateType<T extends VariantAggregateArgs> = {
        [P in keyof T & keyof AggregateVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariant[P]>
      : GetScalarType<T[P], AggregateVariant[P]>
  }




  export type VariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantWhereInput
    orderBy?: VariantOrderByWithAggregationInput | VariantOrderByWithAggregationInput[]
    by: VariantScalarFieldEnum[] | VariantScalarFieldEnum
    having?: VariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariantCountAggregateInputType | true
    _avg?: VariantAvgAggregateInputType
    _sum?: VariantSumAggregateInputType
    _min?: VariantMinAggregateInputType
    _max?: VariantMaxAggregateInputType
  }

  export type VariantGroupByOutputType = {
    id: number
    name: string
    sku: string
    productId: number
    color: string | null
    count: string | null
    gsm: string | null
    width: string | null
    shade: string | null
    weave: string | null
    finish: string | null
    type: string | null
    price: number | null
    stock: number | null
    createdAt: Date
    updatedAt: Date
    _count: VariantCountAggregateOutputType | null
    _avg: VariantAvgAggregateOutputType | null
    _sum: VariantSumAggregateOutputType | null
    _min: VariantMinAggregateOutputType | null
    _max: VariantMaxAggregateOutputType | null
  }

  type GetVariantGroupByPayload<T extends VariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariantGroupByOutputType[P]>
            : GetScalarType<T[P], VariantGroupByOutputType[P]>
        }
      >
    >


  export type VariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sku?: boolean
    productId?: boolean
    color?: boolean
    count?: boolean
    gsm?: boolean
    width?: boolean
    shade?: boolean
    weave?: boolean
    finish?: boolean
    type?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant"]>

  export type VariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sku?: boolean
    productId?: boolean
    color?: boolean
    count?: boolean
    gsm?: boolean
    width?: boolean
    shade?: boolean
    weave?: boolean
    finish?: boolean
    type?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant"]>

  export type VariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sku?: boolean
    productId?: boolean
    color?: boolean
    count?: boolean
    gsm?: boolean
    width?: boolean
    shade?: boolean
    weave?: boolean
    finish?: boolean
    type?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant"]>

  export type VariantSelectScalar = {
    id?: boolean
    name?: boolean
    sku?: boolean
    productId?: boolean
    color?: boolean
    count?: boolean
    gsm?: boolean
    width?: boolean
    shade?: boolean
    weave?: boolean
    finish?: boolean
    type?: boolean
    price?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "sku" | "productId" | "color" | "count" | "gsm" | "width" | "shade" | "weave" | "finish" | "type" | "price" | "stock" | "createdAt" | "updatedAt", ExtArgs["result"]["variant"]>
  export type VariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type VariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type VariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $VariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Variant"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      sku: string
      productId: number
      color: string | null
      count: string | null
      gsm: string | null
      width: string | null
      shade: string | null
      weave: string | null
      finish: string | null
      type: string | null
      price: number | null
      stock: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["variant"]>
    composites: {}
  }

  type VariantGetPayload<S extends boolean | null | undefined | VariantDefaultArgs> = $Result.GetResult<Prisma.$VariantPayload, S>

  type VariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariantCountAggregateInputType | true
    }

  export interface VariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Variant'], meta: { name: 'Variant' } }
    /**
     * Find zero or one Variant that matches the filter.
     * @param {VariantFindUniqueArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariantFindUniqueArgs>(args: SelectSubset<T, VariantFindUniqueArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Variant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariantFindUniqueOrThrowArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariantFindUniqueOrThrowArgs>(args: SelectSubset<T, VariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantFindFirstArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariantFindFirstArgs>(args?: SelectSubset<T, VariantFindFirstArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantFindFirstOrThrowArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariantFindFirstOrThrowArgs>(args?: SelectSubset<T, VariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Variants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variants
     * const variants = await prisma.variant.findMany()
     * 
     * // Get first 10 Variants
     * const variants = await prisma.variant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variantWithIdOnly = await prisma.variant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariantFindManyArgs>(args?: SelectSubset<T, VariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Variant.
     * @param {VariantCreateArgs} args - Arguments to create a Variant.
     * @example
     * // Create one Variant
     * const Variant = await prisma.variant.create({
     *   data: {
     *     // ... data to create a Variant
     *   }
     * })
     * 
     */
    create<T extends VariantCreateArgs>(args: SelectSubset<T, VariantCreateArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Variants.
     * @param {VariantCreateManyArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variant = await prisma.variant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariantCreateManyArgs>(args?: SelectSubset<T, VariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variants and returns the data saved in the database.
     * @param {VariantCreateManyAndReturnArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variant = await prisma.variant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variants and only return the `id`
     * const variantWithIdOnly = await prisma.variant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariantCreateManyAndReturnArgs>(args?: SelectSubset<T, VariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Variant.
     * @param {VariantDeleteArgs} args - Arguments to delete one Variant.
     * @example
     * // Delete one Variant
     * const Variant = await prisma.variant.delete({
     *   where: {
     *     // ... filter to delete one Variant
     *   }
     * })
     * 
     */
    delete<T extends VariantDeleteArgs>(args: SelectSubset<T, VariantDeleteArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Variant.
     * @param {VariantUpdateArgs} args - Arguments to update one Variant.
     * @example
     * // Update one Variant
     * const variant = await prisma.variant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariantUpdateArgs>(args: SelectSubset<T, VariantUpdateArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Variants.
     * @param {VariantDeleteManyArgs} args - Arguments to filter Variants to delete.
     * @example
     * // Delete a few Variants
     * const { count } = await prisma.variant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariantDeleteManyArgs>(args?: SelectSubset<T, VariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variants
     * const variant = await prisma.variant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariantUpdateManyArgs>(args: SelectSubset<T, VariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variants and returns the data updated in the database.
     * @param {VariantUpdateManyAndReturnArgs} args - Arguments to update many Variants.
     * @example
     * // Update many Variants
     * const variant = await prisma.variant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Variants and only return the `id`
     * const variantWithIdOnly = await prisma.variant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariantUpdateManyAndReturnArgs>(args: SelectSubset<T, VariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Variant.
     * @param {VariantUpsertArgs} args - Arguments to update or create a Variant.
     * @example
     * // Update or create a Variant
     * const variant = await prisma.variant.upsert({
     *   create: {
     *     // ... data to create a Variant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variant we want to update
     *   }
     * })
     */
    upsert<T extends VariantUpsertArgs>(args: SelectSubset<T, VariantUpsertArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantCountArgs} args - Arguments to filter Variants to count.
     * @example
     * // Count the number of Variants
     * const count = await prisma.variant.count({
     *   where: {
     *     // ... the filter for the Variants we want to count
     *   }
     * })
    **/
    count<T extends VariantCountArgs>(
      args?: Subset<T, VariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariantAggregateArgs>(args: Subset<T, VariantAggregateArgs>): Prisma.PrismaPromise<GetVariantAggregateType<T>>

    /**
     * Group by Variant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariantGroupByArgs['orderBy'] }
        : { orderBy?: VariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Variant model
   */
  readonly fields: VariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Variant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Variant model
   */
  interface VariantFieldRefs {
    readonly id: FieldRef<"Variant", 'Int'>
    readonly name: FieldRef<"Variant", 'String'>
    readonly sku: FieldRef<"Variant", 'String'>
    readonly productId: FieldRef<"Variant", 'Int'>
    readonly color: FieldRef<"Variant", 'String'>
    readonly count: FieldRef<"Variant", 'String'>
    readonly gsm: FieldRef<"Variant", 'String'>
    readonly width: FieldRef<"Variant", 'String'>
    readonly shade: FieldRef<"Variant", 'String'>
    readonly weave: FieldRef<"Variant", 'String'>
    readonly finish: FieldRef<"Variant", 'String'>
    readonly type: FieldRef<"Variant", 'String'>
    readonly price: FieldRef<"Variant", 'Float'>
    readonly stock: FieldRef<"Variant", 'Float'>
    readonly createdAt: FieldRef<"Variant", 'DateTime'>
    readonly updatedAt: FieldRef<"Variant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Variant findUnique
   */
  export type VariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant findUniqueOrThrow
   */
  export type VariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant findFirst
   */
  export type VariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variants.
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variants.
     */
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Variant findFirstOrThrow
   */
  export type VariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variants.
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variants.
     */
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Variant findMany
   */
  export type VariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variants to fetch.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Variants.
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Variant create
   */
  export type VariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * The data needed to create a Variant.
     */
    data: XOR<VariantCreateInput, VariantUncheckedCreateInput>
  }

  /**
   * Variant createMany
   */
  export type VariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Variants.
     */
    data: VariantCreateManyInput | VariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Variant createManyAndReturn
   */
  export type VariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * The data used to create many Variants.
     */
    data: VariantCreateManyInput | VariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variant update
   */
  export type VariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * The data needed to update a Variant.
     */
    data: XOR<VariantUpdateInput, VariantUncheckedUpdateInput>
    /**
     * Choose, which Variant to update.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant updateMany
   */
  export type VariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Variants.
     */
    data: XOR<VariantUpdateManyMutationInput, VariantUncheckedUpdateManyInput>
    /**
     * Filter which Variants to update
     */
    where?: VariantWhereInput
    /**
     * Limit how many Variants to update.
     */
    limit?: number
  }

  /**
   * Variant updateManyAndReturn
   */
  export type VariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * The data used to update Variants.
     */
    data: XOR<VariantUpdateManyMutationInput, VariantUncheckedUpdateManyInput>
    /**
     * Filter which Variants to update
     */
    where?: VariantWhereInput
    /**
     * Limit how many Variants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variant upsert
   */
  export type VariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * The filter to search for the Variant to update in case it exists.
     */
    where: VariantWhereUniqueInput
    /**
     * In case the Variant found by the `where` argument doesn't exist, create a new Variant with this data.
     */
    create: XOR<VariantCreateInput, VariantUncheckedCreateInput>
    /**
     * In case the Variant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariantUpdateInput, VariantUncheckedUpdateInput>
  }

  /**
   * Variant delete
   */
  export type VariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter which Variant to delete.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant deleteMany
   */
  export type VariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variants to delete
     */
    where?: VariantWhereInput
    /**
     * Limit how many Variants to delete.
     */
    limit?: number
  }

  /**
   * Variant without action
   */
  export type VariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    name: string
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    machines?: boolean | Location$machinesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    machines?: boolean | Location$machinesArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      machines: Prisma.$MachinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    machines<T extends Location$machinesArgs<ExtArgs> = {}>(args?: Subset<T, Location$machinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'Int'>
    readonly name: FieldRef<"Location", 'String'>
    readonly description: FieldRef<"Location", 'String'>
    readonly status: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.machines
   */
  export type Location$machinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    where?: MachineWhereInput
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    cursor?: MachineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    id: number | null
  }

  export type ShiftSumAggregateOutputType = {
    id: number | null
  }

  export type ShiftMinAggregateOutputType = {
    id: number | null
    name: string | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: number | null
    name: string | null
    startTime: string | null
    endTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    id?: true
  }

  export type ShiftSumAggregateInputType = {
    id?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: number
    name: string
    startTime: string
    endTime: string
    createdAt: Date
    updatedAt: Date
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startTime" | "endTime" | "createdAt" | "updatedAt", ExtArgs["result"]["shift"]>

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      startTime: string
      endTime: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts and returns the data updated in the database.
     * @param {ShiftUpdateManyAndReturnArgs} args - Arguments to update many Shifts.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'Int'>
    readonly name: FieldRef<"Shift", 'String'>
    readonly startTime: FieldRef<"Shift", 'String'>
    readonly endTime: FieldRef<"Shift", 'String'>
    readonly createdAt: FieldRef<"Shift", 'DateTime'>
    readonly updatedAt: FieldRef<"Shift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift updateManyAndReturn
   */
  export type ShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to delete.
     */
    limit?: number
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
  }


  /**
   * Model Operator
   */

  export type AggregateOperator = {
    _count: OperatorCountAggregateOutputType | null
    _avg: OperatorAvgAggregateOutputType | null
    _sum: OperatorSumAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  export type OperatorAvgAggregateOutputType = {
    id: number | null
  }

  export type OperatorSumAggregateOutputType = {
    id: number | null
  }

  export type OperatorMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    contact: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    contact: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OperatorCountAggregateOutputType = {
    id: number
    name: number
    code: number
    contact: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OperatorAvgAggregateInputType = {
    id?: true
  }

  export type OperatorSumAggregateInputType = {
    id?: true
  }

  export type OperatorMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    contact?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatorMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    contact?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OperatorCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    contact?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OperatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operator to aggregate.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Operators
    **/
    _count?: true | OperatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorMaxAggregateInputType
  }

  export type GetOperatorAggregateType<T extends OperatorAggregateArgs> = {
        [P in keyof T & keyof AggregateOperator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperator[P]>
      : GetScalarType<T[P], AggregateOperator[P]>
  }




  export type OperatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperatorWhereInput
    orderBy?: OperatorOrderByWithAggregationInput | OperatorOrderByWithAggregationInput[]
    by: OperatorScalarFieldEnum[] | OperatorScalarFieldEnum
    having?: OperatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorCountAggregateInputType | true
    _avg?: OperatorAvgAggregateInputType
    _sum?: OperatorSumAggregateInputType
    _min?: OperatorMinAggregateInputType
    _max?: OperatorMaxAggregateInputType
  }

  export type OperatorGroupByOutputType = {
    id: number
    name: string
    code: string
    contact: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: OperatorCountAggregateOutputType | null
    _avg: OperatorAvgAggregateOutputType | null
    _sum: OperatorSumAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  type GetOperatorGroupByPayload<T extends OperatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorGroupByOutputType[P]>
        }
      >
    >


  export type OperatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    contact?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    contact?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    contact?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["operator"]>

  export type OperatorSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    contact?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OperatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "contact" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["operator"]>

  export type $OperatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Operator"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      contact: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["operator"]>
    composites: {}
  }

  type OperatorGetPayload<S extends boolean | null | undefined | OperatorDefaultArgs> = $Result.GetResult<Prisma.$OperatorPayload, S>

  type OperatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperatorCountAggregateInputType | true
    }

  export interface OperatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Operator'], meta: { name: 'Operator' } }
    /**
     * Find zero or one Operator that matches the filter.
     * @param {OperatorFindUniqueArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperatorFindUniqueArgs>(args: SelectSubset<T, OperatorFindUniqueArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Operator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperatorFindUniqueOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperatorFindUniqueOrThrowArgs>(args: SelectSubset<T, OperatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindFirstArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperatorFindFirstArgs>(args?: SelectSubset<T, OperatorFindFirstArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindFirstOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperatorFindFirstOrThrowArgs>(args?: SelectSubset<T, OperatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operators
     * const operators = await prisma.operator.findMany()
     * 
     * // Get first 10 Operators
     * const operators = await prisma.operator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorWithIdOnly = await prisma.operator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperatorFindManyArgs>(args?: SelectSubset<T, OperatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Operator.
     * @param {OperatorCreateArgs} args - Arguments to create a Operator.
     * @example
     * // Create one Operator
     * const Operator = await prisma.operator.create({
     *   data: {
     *     // ... data to create a Operator
     *   }
     * })
     * 
     */
    create<T extends OperatorCreateArgs>(args: SelectSubset<T, OperatorCreateArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Operators.
     * @param {OperatorCreateManyArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperatorCreateManyArgs>(args?: SelectSubset<T, OperatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operators and returns the data saved in the database.
     * @param {OperatorCreateManyAndReturnArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operators and only return the `id`
     * const operatorWithIdOnly = await prisma.operator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperatorCreateManyAndReturnArgs>(args?: SelectSubset<T, OperatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Operator.
     * @param {OperatorDeleteArgs} args - Arguments to delete one Operator.
     * @example
     * // Delete one Operator
     * const Operator = await prisma.operator.delete({
     *   where: {
     *     // ... filter to delete one Operator
     *   }
     * })
     * 
     */
    delete<T extends OperatorDeleteArgs>(args: SelectSubset<T, OperatorDeleteArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Operator.
     * @param {OperatorUpdateArgs} args - Arguments to update one Operator.
     * @example
     * // Update one Operator
     * const operator = await prisma.operator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperatorUpdateArgs>(args: SelectSubset<T, OperatorUpdateArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Operators.
     * @param {OperatorDeleteManyArgs} args - Arguments to filter Operators to delete.
     * @example
     * // Delete a few Operators
     * const { count } = await prisma.operator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperatorDeleteManyArgs>(args?: SelectSubset<T, OperatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operators
     * const operator = await prisma.operator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperatorUpdateManyArgs>(args: SelectSubset<T, OperatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators and returns the data updated in the database.
     * @param {OperatorUpdateManyAndReturnArgs} args - Arguments to update many Operators.
     * @example
     * // Update many Operators
     * const operator = await prisma.operator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Operators and only return the `id`
     * const operatorWithIdOnly = await prisma.operator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperatorUpdateManyAndReturnArgs>(args: SelectSubset<T, OperatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Operator.
     * @param {OperatorUpsertArgs} args - Arguments to update or create a Operator.
     * @example
     * // Update or create a Operator
     * const operator = await prisma.operator.upsert({
     *   create: {
     *     // ... data to create a Operator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operator we want to update
     *   }
     * })
     */
    upsert<T extends OperatorUpsertArgs>(args: SelectSubset<T, OperatorUpsertArgs<ExtArgs>>): Prisma__OperatorClient<$Result.GetResult<Prisma.$OperatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorCountArgs} args - Arguments to filter Operators to count.
     * @example
     * // Count the number of Operators
     * const count = await prisma.operator.count({
     *   where: {
     *     // ... the filter for the Operators we want to count
     *   }
     * })
    **/
    count<T extends OperatorCountArgs>(
      args?: Subset<T, OperatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorAggregateArgs>(args: Subset<T, OperatorAggregateArgs>): Prisma.PrismaPromise<GetOperatorAggregateType<T>>

    /**
     * Group by Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperatorGroupByArgs['orderBy'] }
        : { orderBy?: OperatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Operator model
   */
  readonly fields: OperatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Operator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Operator model
   */
  interface OperatorFieldRefs {
    readonly id: FieldRef<"Operator", 'Int'>
    readonly name: FieldRef<"Operator", 'String'>
    readonly code: FieldRef<"Operator", 'String'>
    readonly contact: FieldRef<"Operator", 'String'>
    readonly status: FieldRef<"Operator", 'String'>
    readonly createdAt: FieldRef<"Operator", 'DateTime'>
    readonly updatedAt: FieldRef<"Operator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Operator findUnique
   */
  export type OperatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator findUniqueOrThrow
   */
  export type OperatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator findFirst
   */
  export type OperatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator findFirstOrThrow
   */
  export type OperatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Filter, which Operator to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator findMany
   */
  export type OperatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Filter, which Operators to fetch.
     */
    where?: OperatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Operators to fetch.
     */
    orderBy?: OperatorOrderByWithRelationInput | OperatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Operators.
     */
    cursor?: OperatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Operators.
     */
    skip?: number
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * Operator create
   */
  export type OperatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * The data needed to create a Operator.
     */
    data: XOR<OperatorCreateInput, OperatorUncheckedCreateInput>
  }

  /**
   * Operator createMany
   */
  export type OperatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Operators.
     */
    data: OperatorCreateManyInput | OperatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Operator createManyAndReturn
   */
  export type OperatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * The data used to create many Operators.
     */
    data: OperatorCreateManyInput | OperatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Operator update
   */
  export type OperatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * The data needed to update a Operator.
     */
    data: XOR<OperatorUpdateInput, OperatorUncheckedUpdateInput>
    /**
     * Choose, which Operator to update.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator updateMany
   */
  export type OperatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Operators.
     */
    data: XOR<OperatorUpdateManyMutationInput, OperatorUncheckedUpdateManyInput>
    /**
     * Filter which Operators to update
     */
    where?: OperatorWhereInput
    /**
     * Limit how many Operators to update.
     */
    limit?: number
  }

  /**
   * Operator updateManyAndReturn
   */
  export type OperatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * The data used to update Operators.
     */
    data: XOR<OperatorUpdateManyMutationInput, OperatorUncheckedUpdateManyInput>
    /**
     * Filter which Operators to update
     */
    where?: OperatorWhereInput
    /**
     * Limit how many Operators to update.
     */
    limit?: number
  }

  /**
   * Operator upsert
   */
  export type OperatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * The filter to search for the Operator to update in case it exists.
     */
    where: OperatorWhereUniqueInput
    /**
     * In case the Operator found by the `where` argument doesn't exist, create a new Operator with this data.
     */
    create: XOR<OperatorCreateInput, OperatorUncheckedCreateInput>
    /**
     * In case the Operator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperatorUpdateInput, OperatorUncheckedUpdateInput>
  }

  /**
   * Operator delete
   */
  export type OperatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
    /**
     * Filter which Operator to delete.
     */
    where: OperatorWhereUniqueInput
  }

  /**
   * Operator deleteMany
   */
  export type OperatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Operators to delete
     */
    where?: OperatorWhereInput
    /**
     * Limit how many Operators to delete.
     */
    limit?: number
  }

  /**
   * Operator without action
   */
  export type OperatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Operator
     */
    select?: OperatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Operator
     */
    omit?: OperatorOmit<ExtArgs> | null
  }


  /**
   * Model Machine
   */

  export type AggregateMachine = {
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  export type MachineAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
  }

  export type MachineSumAggregateOutputType = {
    id: number | null
    locationId: number | null
  }

  export type MachineMinAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    type: string | null
    status: string | null
    locationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MachineMaxAggregateOutputType = {
    id: number | null
    name: string | null
    code: string | null
    type: string | null
    status: string | null
    locationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MachineCountAggregateOutputType = {
    id: number
    name: number
    code: number
    type: number
    status: number
    locationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MachineAvgAggregateInputType = {
    id?: true
    locationId?: true
  }

  export type MachineSumAggregateInputType = {
    id?: true
    locationId?: true
  }

  export type MachineMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    status?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MachineMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    status?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MachineCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    status?: true
    locationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MachineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machine to aggregate.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Machines
    **/
    _count?: true | MachineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachineMaxAggregateInputType
  }

  export type GetMachineAggregateType<T extends MachineAggregateArgs> = {
        [P in keyof T & keyof AggregateMachine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachine[P]>
      : GetScalarType<T[P], AggregateMachine[P]>
  }




  export type MachineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MachineWhereInput
    orderBy?: MachineOrderByWithAggregationInput | MachineOrderByWithAggregationInput[]
    by: MachineScalarFieldEnum[] | MachineScalarFieldEnum
    having?: MachineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachineCountAggregateInputType | true
    _avg?: MachineAvgAggregateInputType
    _sum?: MachineSumAggregateInputType
    _min?: MachineMinAggregateInputType
    _max?: MachineMaxAggregateInputType
  }

  export type MachineGroupByOutputType = {
    id: number
    name: string
    code: string
    type: string | null
    status: string
    locationId: number | null
    createdAt: Date
    updatedAt: Date
    _count: MachineCountAggregateOutputType | null
    _avg: MachineAvgAggregateOutputType | null
    _sum: MachineSumAggregateOutputType | null
    _min: MachineMinAggregateOutputType | null
    _max: MachineMaxAggregateOutputType | null
  }

  type GetMachineGroupByPayload<T extends MachineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachineGroupByOutputType[P]>
            : GetScalarType<T[P], MachineGroupByOutputType[P]>
        }
      >
    >


  export type MachineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Machine$locationArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Machine$locationArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | Machine$locationArgs<ExtArgs>
  }, ExtArgs["result"]["machine"]>

  export type MachineSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    locationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MachineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "type" | "status" | "locationId" | "createdAt" | "updatedAt", ExtArgs["result"]["machine"]>
  export type MachineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Machine$locationArgs<ExtArgs>
  }
  export type MachineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Machine$locationArgs<ExtArgs>
  }
  export type MachineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | Machine$locationArgs<ExtArgs>
  }

  export type $MachinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Machine"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      code: string
      type: string | null
      status: string
      locationId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["machine"]>
    composites: {}
  }

  type MachineGetPayload<S extends boolean | null | undefined | MachineDefaultArgs> = $Result.GetResult<Prisma.$MachinePayload, S>

  type MachineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MachineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MachineCountAggregateInputType | true
    }

  export interface MachineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Machine'], meta: { name: 'Machine' } }
    /**
     * Find zero or one Machine that matches the filter.
     * @param {MachineFindUniqueArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MachineFindUniqueArgs>(args: SelectSubset<T, MachineFindUniqueArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Machine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MachineFindUniqueOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MachineFindUniqueOrThrowArgs>(args: SelectSubset<T, MachineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MachineFindFirstArgs>(args?: SelectSubset<T, MachineFindFirstArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindFirstOrThrowArgs} args - Arguments to find a Machine
     * @example
     * // Get one Machine
     * const machine = await prisma.machine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MachineFindFirstOrThrowArgs>(args?: SelectSubset<T, MachineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Machines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Machines
     * const machines = await prisma.machine.findMany()
     * 
     * // Get first 10 Machines
     * const machines = await prisma.machine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machineWithIdOnly = await prisma.machine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MachineFindManyArgs>(args?: SelectSubset<T, MachineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Machine.
     * @param {MachineCreateArgs} args - Arguments to create a Machine.
     * @example
     * // Create one Machine
     * const Machine = await prisma.machine.create({
     *   data: {
     *     // ... data to create a Machine
     *   }
     * })
     * 
     */
    create<T extends MachineCreateArgs>(args: SelectSubset<T, MachineCreateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Machines.
     * @param {MachineCreateManyArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machine = await prisma.machine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MachineCreateManyArgs>(args?: SelectSubset<T, MachineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Machines and returns the data saved in the database.
     * @param {MachineCreateManyAndReturnArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machine = await prisma.machine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Machines and only return the `id`
     * const machineWithIdOnly = await prisma.machine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MachineCreateManyAndReturnArgs>(args?: SelectSubset<T, MachineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Machine.
     * @param {MachineDeleteArgs} args - Arguments to delete one Machine.
     * @example
     * // Delete one Machine
     * const Machine = await prisma.machine.delete({
     *   where: {
     *     // ... filter to delete one Machine
     *   }
     * })
     * 
     */
    delete<T extends MachineDeleteArgs>(args: SelectSubset<T, MachineDeleteArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Machine.
     * @param {MachineUpdateArgs} args - Arguments to update one Machine.
     * @example
     * // Update one Machine
     * const machine = await prisma.machine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MachineUpdateArgs>(args: SelectSubset<T, MachineUpdateArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Machines.
     * @param {MachineDeleteManyArgs} args - Arguments to filter Machines to delete.
     * @example
     * // Delete a few Machines
     * const { count } = await prisma.machine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MachineDeleteManyArgs>(args?: SelectSubset<T, MachineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MachineUpdateManyArgs>(args: SelectSubset<T, MachineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines and returns the data updated in the database.
     * @param {MachineUpdateManyAndReturnArgs} args - Arguments to update many Machines.
     * @example
     * // Update many Machines
     * const machine = await prisma.machine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Machines and only return the `id`
     * const machineWithIdOnly = await prisma.machine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MachineUpdateManyAndReturnArgs>(args: SelectSubset<T, MachineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Machine.
     * @param {MachineUpsertArgs} args - Arguments to update or create a Machine.
     * @example
     * // Update or create a Machine
     * const machine = await prisma.machine.upsert({
     *   create: {
     *     // ... data to create a Machine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Machine we want to update
     *   }
     * })
     */
    upsert<T extends MachineUpsertArgs>(args: SelectSubset<T, MachineUpsertArgs<ExtArgs>>): Prisma__MachineClient<$Result.GetResult<Prisma.$MachinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineCountArgs} args - Arguments to filter Machines to count.
     * @example
     * // Count the number of Machines
     * const count = await prisma.machine.count({
     *   where: {
     *     // ... the filter for the Machines we want to count
     *   }
     * })
    **/
    count<T extends MachineCountArgs>(
      args?: Subset<T, MachineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachineAggregateArgs>(args: Subset<T, MachineAggregateArgs>): Prisma.PrismaPromise<GetMachineAggregateType<T>>

    /**
     * Group by Machine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MachineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MachineGroupByArgs['orderBy'] }
        : { orderBy?: MachineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MachineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Machine model
   */
  readonly fields: MachineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Machine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MachineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends Machine$locationArgs<ExtArgs> = {}>(args?: Subset<T, Machine$locationArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Machine model
   */
  interface MachineFieldRefs {
    readonly id: FieldRef<"Machine", 'Int'>
    readonly name: FieldRef<"Machine", 'String'>
    readonly code: FieldRef<"Machine", 'String'>
    readonly type: FieldRef<"Machine", 'String'>
    readonly status: FieldRef<"Machine", 'String'>
    readonly locationId: FieldRef<"Machine", 'Int'>
    readonly createdAt: FieldRef<"Machine", 'DateTime'>
    readonly updatedAt: FieldRef<"Machine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Machine findUnique
   */
  export type MachineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findUniqueOrThrow
   */
  export type MachineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine findFirst
   */
  export type MachineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findFirstOrThrow
   */
  export type MachineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machine to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Machines.
     */
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine findMany
   */
  export type MachineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter, which Machines to fetch.
     */
    where?: MachineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Machines to fetch.
     */
    orderBy?: MachineOrderByWithRelationInput | MachineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Machines.
     */
    cursor?: MachineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Machines.
     */
    skip?: number
    distinct?: MachineScalarFieldEnum | MachineScalarFieldEnum[]
  }

  /**
   * Machine create
   */
  export type MachineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to create a Machine.
     */
    data: XOR<MachineCreateInput, MachineUncheckedCreateInput>
  }

  /**
   * Machine createMany
   */
  export type MachineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Machines.
     */
    data: MachineCreateManyInput | MachineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Machine createManyAndReturn
   */
  export type MachineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * The data used to create many Machines.
     */
    data: MachineCreateManyInput | MachineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Machine update
   */
  export type MachineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The data needed to update a Machine.
     */
    data: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
    /**
     * Choose, which Machine to update.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine updateMany
   */
  export type MachineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to update.
     */
    limit?: number
  }

  /**
   * Machine updateManyAndReturn
   */
  export type MachineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * The data used to update Machines.
     */
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyInput>
    /**
     * Filter which Machines to update
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Machine upsert
   */
  export type MachineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * The filter to search for the Machine to update in case it exists.
     */
    where: MachineWhereUniqueInput
    /**
     * In case the Machine found by the `where` argument doesn't exist, create a new Machine with this data.
     */
    create: XOR<MachineCreateInput, MachineUncheckedCreateInput>
    /**
     * In case the Machine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MachineUpdateInput, MachineUncheckedUpdateInput>
  }

  /**
   * Machine delete
   */
  export type MachineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
    /**
     * Filter which Machine to delete.
     */
    where: MachineWhereUniqueInput
  }

  /**
   * Machine deleteMany
   */
  export type MachineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Machines to delete
     */
    where?: MachineWhereInput
    /**
     * Limit how many Machines to delete.
     */
    limit?: number
  }

  /**
   * Machine.location
   */
  export type Machine$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Machine without action
   */
  export type MachineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Machine
     */
    select?: MachineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Machine
     */
    omit?: MachineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MachineInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    level: number | null
    openingBalance: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    level: number | null
    openingBalance: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    type: $Enums.AccountType | null
    parentId: number | null
    level: number | null
    isPosting: boolean | null
    description: string | null
    openingBalance: number | null
    openingBalanceType: $Enums.BalanceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    type: $Enums.AccountType | null
    parentId: number | null
    level: number | null
    isPosting: boolean | null
    description: string | null
    openingBalance: number | null
    openingBalanceType: $Enums.BalanceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    code: number
    name: number
    type: number
    parentId: number
    level: number
    isPosting: number
    description: number
    openingBalance: number
    openingBalanceType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    parentId?: true
    level?: true
    openingBalance?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    parentId?: true
    level?: true
    openingBalance?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    parentId?: true
    level?: true
    isPosting?: true
    description?: true
    openingBalance?: true
    openingBalanceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    parentId?: true
    level?: true
    isPosting?: true
    description?: true
    openingBalance?: true
    openingBalanceType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    parentId?: true
    level?: true
    isPosting?: true
    description?: true
    openingBalance?: true
    openingBalanceType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    code: string
    name: string
    type: $Enums.AccountType
    parentId: number | null
    level: number
    isPosting: boolean
    description: string | null
    openingBalance: number
    openingBalanceType: $Enums.BalanceType
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    level?: boolean
    isPosting?: boolean
    description?: boolean
    openingBalance?: boolean
    openingBalanceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Account$parentArgs<ExtArgs>
    children?: boolean | Account$childrenArgs<ExtArgs>
    journalLines?: boolean | Account$journalLinesArgs<ExtArgs>
    purchaseOrders?: boolean | Account$purchaseOrdersArgs<ExtArgs>
    purchaseInvoices?: boolean | Account$purchaseInvoicesArgs<ExtArgs>
    purchaseReturns?: boolean | Account$purchaseReturnsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    level?: boolean
    isPosting?: boolean
    description?: boolean
    openingBalance?: boolean
    openingBalanceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Account$parentArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    level?: boolean
    isPosting?: boolean
    description?: boolean
    openingBalance?: boolean
    openingBalanceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Account$parentArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    parentId?: boolean
    level?: boolean
    isPosting?: boolean
    description?: boolean
    openingBalance?: boolean
    openingBalanceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "type" | "parentId" | "level" | "isPosting" | "description" | "openingBalance" | "openingBalanceType" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Account$parentArgs<ExtArgs>
    children?: boolean | Account$childrenArgs<ExtArgs>
    journalLines?: boolean | Account$journalLinesArgs<ExtArgs>
    purchaseOrders?: boolean | Account$purchaseOrdersArgs<ExtArgs>
    purchaseInvoices?: boolean | Account$purchaseInvoicesArgs<ExtArgs>
    purchaseReturns?: boolean | Account$purchaseReturnsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Account$parentArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Account$parentArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      parent: Prisma.$AccountPayload<ExtArgs> | null
      children: Prisma.$AccountPayload<ExtArgs>[]
      journalLines: Prisma.$JournalLinePayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      purchaseInvoices: Prisma.$PurchaseInvoicePayload<ExtArgs>[]
      purchaseReturns: Prisma.$PurchaseReturnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      type: $Enums.AccountType
      parentId: number | null
      level: number
      isPosting: boolean
      description: string | null
      openingBalance: number
      openingBalanceType: $Enums.BalanceType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Account$parentArgs<ExtArgs> = {}>(args?: Subset<T, Account$parentArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Account$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Account$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalLines<T extends Account$journalLinesArgs<ExtArgs> = {}>(args?: Subset<T, Account$journalLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrders<T extends Account$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Account$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoices<T extends Account$purchaseInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Account$purchaseInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturns<T extends Account$purchaseReturnsArgs<ExtArgs> = {}>(args?: Subset<T, Account$purchaseReturnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly code: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'AccountType'>
    readonly parentId: FieldRef<"Account", 'Int'>
    readonly level: FieldRef<"Account", 'Int'>
    readonly isPosting: FieldRef<"Account", 'Boolean'>
    readonly description: FieldRef<"Account", 'String'>
    readonly openingBalance: FieldRef<"Account", 'Float'>
    readonly openingBalanceType: FieldRef<"Account", 'BalanceType'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.parent
   */
  export type Account$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Account.children
   */
  export type Account$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account.journalLines
   */
  export type Account$journalLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * Account.purchaseOrders
   */
  export type Account$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Account.purchaseInvoices
   */
  export type Account$purchaseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * Account.purchaseReturns
   */
  export type Account$purchaseReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    where?: PurchaseReturnWhereInput
    orderBy?: PurchaseReturnOrderByWithRelationInput | PurchaseReturnOrderByWithRelationInput[]
    cursor?: PurchaseReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnScalarFieldEnum | PurchaseReturnScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model JournalEntry
   */

  export type AggregateJournalEntry = {
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  export type JournalEntryAvgAggregateOutputType = {
    id: number | null
    fiscalYearId: number | null
  }

  export type JournalEntrySumAggregateOutputType = {
    id: number | null
    fiscalYearId: number | null
  }

  export type JournalEntryMinAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    type: $Enums.VoucherType | null
    reference: string | null
    narration: string | null
    status: boolean | null
    fiscalYearId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryMaxAggregateOutputType = {
    id: number | null
    number: string | null
    date: Date | null
    type: $Enums.VoucherType | null
    reference: string | null
    narration: string | null
    status: boolean | null
    fiscalYearId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryCountAggregateOutputType = {
    id: number
    number: number
    date: number
    type: number
    reference: number
    narration: number
    status: number
    fiscalYearId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalEntryAvgAggregateInputType = {
    id?: true
    fiscalYearId?: true
  }

  export type JournalEntrySumAggregateInputType = {
    id?: true
    fiscalYearId?: true
  }

  export type JournalEntryMinAggregateInputType = {
    id?: true
    number?: true
    date?: true
    type?: true
    reference?: true
    narration?: true
    status?: true
    fiscalYearId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryMaxAggregateInputType = {
    id?: true
    number?: true
    date?: true
    type?: true
    reference?: true
    narration?: true
    status?: true
    fiscalYearId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryCountAggregateInputType = {
    id?: true
    number?: true
    date?: true
    type?: true
    reference?: true
    narration?: true
    status?: true
    fiscalYearId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntry to aggregate.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalEntries
    **/
    _count?: true | JournalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalEntryMaxAggregateInputType
  }

  export type GetJournalEntryAggregateType<T extends JournalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalEntry[P]>
      : GetScalarType<T[P], AggregateJournalEntry[P]>
  }




  export type JournalEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithAggregationInput | JournalEntryOrderByWithAggregationInput[]
    by: JournalEntryScalarFieldEnum[] | JournalEntryScalarFieldEnum
    having?: JournalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalEntryCountAggregateInputType | true
    _avg?: JournalEntryAvgAggregateInputType
    _sum?: JournalEntrySumAggregateInputType
    _min?: JournalEntryMinAggregateInputType
    _max?: JournalEntryMaxAggregateInputType
  }

  export type JournalEntryGroupByOutputType = {
    id: number
    number: string
    date: Date
    type: $Enums.VoucherType
    reference: string | null
    narration: string | null
    status: boolean
    fiscalYearId: number | null
    createdAt: Date
    updatedAt: Date
    _count: JournalEntryCountAggregateOutputType | null
    _avg: JournalEntryAvgAggregateOutputType | null
    _sum: JournalEntrySumAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  type GetJournalEntryGroupByPayload<T extends JournalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
        }
      >
    >


  export type JournalEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    type?: boolean
    reference?: boolean
    narration?: boolean
    status?: boolean
    fiscalYearId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fiscalYear?: boolean | JournalEntry$fiscalYearArgs<ExtArgs>
    lines?: boolean | JournalEntry$linesArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    type?: boolean
    reference?: boolean
    narration?: boolean
    status?: boolean
    fiscalYearId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fiscalYear?: boolean | JournalEntry$fiscalYearArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    date?: boolean
    type?: boolean
    reference?: boolean
    narration?: boolean
    status?: boolean
    fiscalYearId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fiscalYear?: boolean | JournalEntry$fiscalYearArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectScalar = {
    id?: boolean
    number?: boolean
    date?: boolean
    type?: boolean
    reference?: boolean
    narration?: boolean
    status?: boolean
    fiscalYearId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "date" | "type" | "reference" | "narration" | "status" | "fiscalYearId" | "createdAt" | "updatedAt", ExtArgs["result"]["journalEntry"]>
  export type JournalEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fiscalYear?: boolean | JournalEntry$fiscalYearArgs<ExtArgs>
    lines?: boolean | JournalEntry$linesArgs<ExtArgs>
    _count?: boolean | JournalEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fiscalYear?: boolean | JournalEntry$fiscalYearArgs<ExtArgs>
  }
  export type JournalEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fiscalYear?: boolean | JournalEntry$fiscalYearArgs<ExtArgs>
  }

  export type $JournalEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalEntry"
    objects: {
      fiscalYear: Prisma.$FiscalYearPayload<ExtArgs> | null
      lines: Prisma.$JournalLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      number: string
      date: Date
      type: $Enums.VoucherType
      reference: string | null
      narration: string | null
      status: boolean
      fiscalYearId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalEntry"]>
    composites: {}
  }

  type JournalEntryGetPayload<S extends boolean | null | undefined | JournalEntryDefaultArgs> = $Result.GetResult<Prisma.$JournalEntryPayload, S>

  type JournalEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalEntryCountAggregateInputType | true
    }

  export interface JournalEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalEntry'], meta: { name: 'JournalEntry' } }
    /**
     * Find zero or one JournalEntry that matches the filter.
     * @param {JournalEntryFindUniqueArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalEntryFindUniqueArgs>(args: SelectSubset<T, JournalEntryFindUniqueArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalEntryFindUniqueOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalEntryFindFirstArgs>(args?: SelectSubset<T, JournalEntryFindFirstArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany()
     * 
     * // Get first 10 JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalEntryFindManyArgs>(args?: SelectSubset<T, JournalEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalEntry.
     * @param {JournalEntryCreateArgs} args - Arguments to create a JournalEntry.
     * @example
     * // Create one JournalEntry
     * const JournalEntry = await prisma.journalEntry.create({
     *   data: {
     *     // ... data to create a JournalEntry
     *   }
     * })
     * 
     */
    create<T extends JournalEntryCreateArgs>(args: SelectSubset<T, JournalEntryCreateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalEntries.
     * @param {JournalEntryCreateManyArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalEntryCreateManyArgs>(args?: SelectSubset<T, JournalEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalEntries and returns the data saved in the database.
     * @param {JournalEntryCreateManyAndReturnArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalEntry.
     * @param {JournalEntryDeleteArgs} args - Arguments to delete one JournalEntry.
     * @example
     * // Delete one JournalEntry
     * const JournalEntry = await prisma.journalEntry.delete({
     *   where: {
     *     // ... filter to delete one JournalEntry
     *   }
     * })
     * 
     */
    delete<T extends JournalEntryDeleteArgs>(args: SelectSubset<T, JournalEntryDeleteArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalEntry.
     * @param {JournalEntryUpdateArgs} args - Arguments to update one JournalEntry.
     * @example
     * // Update one JournalEntry
     * const journalEntry = await prisma.journalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalEntryUpdateArgs>(args: SelectSubset<T, JournalEntryUpdateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalEntries.
     * @param {JournalEntryDeleteManyArgs} args - Arguments to filter JournalEntries to delete.
     * @example
     * // Delete a few JournalEntries
     * const { count } = await prisma.journalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalEntryDeleteManyArgs>(args?: SelectSubset<T, JournalEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalEntryUpdateManyArgs>(args: SelectSubset<T, JournalEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries and returns the data updated in the database.
     * @param {JournalEntryUpdateManyAndReturnArgs} args - Arguments to update many JournalEntries.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalEntry.
     * @param {JournalEntryUpsertArgs} args - Arguments to update or create a JournalEntry.
     * @example
     * // Update or create a JournalEntry
     * const journalEntry = await prisma.journalEntry.upsert({
     *   create: {
     *     // ... data to create a JournalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalEntry we want to update
     *   }
     * })
     */
    upsert<T extends JournalEntryUpsertArgs>(args: SelectSubset<T, JournalEntryUpsertArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryCountArgs} args - Arguments to filter JournalEntries to count.
     * @example
     * // Count the number of JournalEntries
     * const count = await prisma.journalEntry.count({
     *   where: {
     *     // ... the filter for the JournalEntries we want to count
     *   }
     * })
    **/
    count<T extends JournalEntryCountArgs>(
      args?: Subset<T, JournalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalEntryAggregateArgs>(args: Subset<T, JournalEntryAggregateArgs>): Prisma.PrismaPromise<GetJournalEntryAggregateType<T>>

    /**
     * Group by JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalEntryGroupByArgs['orderBy'] }
        : { orderBy?: JournalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalEntry model
   */
  readonly fields: JournalEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fiscalYear<T extends JournalEntry$fiscalYearArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntry$fiscalYearArgs<ExtArgs>>): Prisma__FiscalYearClient<$Result.GetResult<Prisma.$FiscalYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends JournalEntry$linesArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntry$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalEntry model
   */
  interface JournalEntryFieldRefs {
    readonly id: FieldRef<"JournalEntry", 'Int'>
    readonly number: FieldRef<"JournalEntry", 'String'>
    readonly date: FieldRef<"JournalEntry", 'DateTime'>
    readonly type: FieldRef<"JournalEntry", 'VoucherType'>
    readonly reference: FieldRef<"JournalEntry", 'String'>
    readonly narration: FieldRef<"JournalEntry", 'String'>
    readonly status: FieldRef<"JournalEntry", 'Boolean'>
    readonly fiscalYearId: FieldRef<"JournalEntry", 'Int'>
    readonly createdAt: FieldRef<"JournalEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalEntry findUnique
   */
  export type JournalEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findUniqueOrThrow
   */
  export type JournalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findFirst
   */
  export type JournalEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findFirstOrThrow
   */
  export type JournalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findMany
   */
  export type JournalEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntries to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry create
   */
  export type JournalEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalEntry.
     */
    data: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
  }

  /**
   * JournalEntry createMany
   */
  export type JournalEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalEntry createManyAndReturn
   */
  export type JournalEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry update
   */
  export type JournalEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalEntry.
     */
    data: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
    /**
     * Choose, which JournalEntry to update.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry updateMany
   */
  export type JournalEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
  }

  /**
   * JournalEntry updateManyAndReturn
   */
  export type JournalEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry upsert
   */
  export type JournalEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalEntry to update in case it exists.
     */
    where: JournalEntryWhereUniqueInput
    /**
     * In case the JournalEntry found by the `where` argument doesn't exist, create a new JournalEntry with this data.
     */
    create: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
    /**
     * In case the JournalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
  }

  /**
   * JournalEntry delete
   */
  export type JournalEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter which JournalEntry to delete.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry deleteMany
   */
  export type JournalEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntries to delete
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to delete.
     */
    limit?: number
  }

  /**
   * JournalEntry.fiscalYear
   */
  export type JournalEntry$fiscalYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalYear
     */
    select?: FiscalYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FiscalYear
     */
    omit?: FiscalYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FiscalYearInclude<ExtArgs> | null
    where?: FiscalYearWhereInput
  }

  /**
   * JournalEntry.lines
   */
  export type JournalEntry$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    cursor?: JournalLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalEntry without action
   */
  export type JournalEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
  }


  /**
   * Model JournalLine
   */

  export type AggregateJournalLine = {
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  export type JournalLineAvgAggregateOutputType = {
    id: number | null
    entryId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
  }

  export type JournalLineSumAggregateOutputType = {
    id: number | null
    entryId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
  }

  export type JournalLineMinAggregateOutputType = {
    id: number | null
    entryId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
    narration: string | null
  }

  export type JournalLineMaxAggregateOutputType = {
    id: number | null
    entryId: number | null
    accountId: number | null
    debit: number | null
    credit: number | null
    narration: string | null
  }

  export type JournalLineCountAggregateOutputType = {
    id: number
    entryId: number
    accountId: number
    debit: number
    credit: number
    narration: number
    _all: number
  }


  export type JournalLineAvgAggregateInputType = {
    id?: true
    entryId?: true
    accountId?: true
    debit?: true
    credit?: true
  }

  export type JournalLineSumAggregateInputType = {
    id?: true
    entryId?: true
    accountId?: true
    debit?: true
    credit?: true
  }

  export type JournalLineMinAggregateInputType = {
    id?: true
    entryId?: true
    accountId?: true
    debit?: true
    credit?: true
    narration?: true
  }

  export type JournalLineMaxAggregateInputType = {
    id?: true
    entryId?: true
    accountId?: true
    debit?: true
    credit?: true
    narration?: true
  }

  export type JournalLineCountAggregateInputType = {
    id?: true
    entryId?: true
    accountId?: true
    debit?: true
    credit?: true
    narration?: true
    _all?: true
  }

  export type JournalLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLine to aggregate.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalLines
    **/
    _count?: true | JournalLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JournalLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JournalLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalLineMaxAggregateInputType
  }

  export type GetJournalLineAggregateType<T extends JournalLineAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalLine[P]>
      : GetScalarType<T[P], AggregateJournalLine[P]>
  }




  export type JournalLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalLineWhereInput
    orderBy?: JournalLineOrderByWithAggregationInput | JournalLineOrderByWithAggregationInput[]
    by: JournalLineScalarFieldEnum[] | JournalLineScalarFieldEnum
    having?: JournalLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalLineCountAggregateInputType | true
    _avg?: JournalLineAvgAggregateInputType
    _sum?: JournalLineSumAggregateInputType
    _min?: JournalLineMinAggregateInputType
    _max?: JournalLineMaxAggregateInputType
  }

  export type JournalLineGroupByOutputType = {
    id: number
    entryId: number
    accountId: number
    debit: number
    credit: number
    narration: string | null
    _count: JournalLineCountAggregateOutputType | null
    _avg: JournalLineAvgAggregateOutputType | null
    _sum: JournalLineSumAggregateOutputType | null
    _min: JournalLineMinAggregateOutputType | null
    _max: JournalLineMaxAggregateOutputType | null
  }

  type GetJournalLineGroupByPayload<T extends JournalLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
            : GetScalarType<T[P], JournalLineGroupByOutputType[P]>
        }
      >
    >


  export type JournalLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entryId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    narration?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entryId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    narration?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entryId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    narration?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalLine"]>

  export type JournalLineSelectScalar = {
    id?: boolean
    entryId?: boolean
    accountId?: boolean
    debit?: boolean
    credit?: boolean
    narration?: boolean
  }

  export type JournalLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entryId" | "accountId" | "debit" | "credit" | "narration", ExtArgs["result"]["journalLine"]>
  export type JournalLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
  }
  export type JournalLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
  }
  export type JournalLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    entry?: boolean | JournalEntryDefaultArgs<ExtArgs>
  }

  export type $JournalLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalLine"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      entry: Prisma.$JournalEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entryId: number
      accountId: number
      debit: number
      credit: number
      narration: string | null
    }, ExtArgs["result"]["journalLine"]>
    composites: {}
  }

  type JournalLineGetPayload<S extends boolean | null | undefined | JournalLineDefaultArgs> = $Result.GetResult<Prisma.$JournalLinePayload, S>

  type JournalLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalLineCountAggregateInputType | true
    }

  export interface JournalLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalLine'], meta: { name: 'JournalLine' } }
    /**
     * Find zero or one JournalLine that matches the filter.
     * @param {JournalLineFindUniqueArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalLineFindUniqueArgs>(args: SelectSubset<T, JournalLineFindUniqueArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalLineFindUniqueOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalLineFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalLineFindFirstArgs>(args?: SelectSubset<T, JournalLineFindFirstArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindFirstOrThrowArgs} args - Arguments to find a JournalLine
     * @example
     * // Get one JournalLine
     * const journalLine = await prisma.journalLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalLineFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalLines
     * const journalLines = await prisma.journalLine.findMany()
     * 
     * // Get first 10 JournalLines
     * const journalLines = await prisma.journalLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalLineFindManyArgs>(args?: SelectSubset<T, JournalLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalLine.
     * @param {JournalLineCreateArgs} args - Arguments to create a JournalLine.
     * @example
     * // Create one JournalLine
     * const JournalLine = await prisma.journalLine.create({
     *   data: {
     *     // ... data to create a JournalLine
     *   }
     * })
     * 
     */
    create<T extends JournalLineCreateArgs>(args: SelectSubset<T, JournalLineCreateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalLines.
     * @param {JournalLineCreateManyArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalLineCreateManyArgs>(args?: SelectSubset<T, JournalLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalLines and returns the data saved in the database.
     * @param {JournalLineCreateManyAndReturnArgs} args - Arguments to create many JournalLines.
     * @example
     * // Create many JournalLines
     * const journalLine = await prisma.journalLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalLines and only return the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalLineCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalLine.
     * @param {JournalLineDeleteArgs} args - Arguments to delete one JournalLine.
     * @example
     * // Delete one JournalLine
     * const JournalLine = await prisma.journalLine.delete({
     *   where: {
     *     // ... filter to delete one JournalLine
     *   }
     * })
     * 
     */
    delete<T extends JournalLineDeleteArgs>(args: SelectSubset<T, JournalLineDeleteArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalLine.
     * @param {JournalLineUpdateArgs} args - Arguments to update one JournalLine.
     * @example
     * // Update one JournalLine
     * const journalLine = await prisma.journalLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalLineUpdateArgs>(args: SelectSubset<T, JournalLineUpdateArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalLines.
     * @param {JournalLineDeleteManyArgs} args - Arguments to filter JournalLines to delete.
     * @example
     * // Delete a few JournalLines
     * const { count } = await prisma.journalLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalLineDeleteManyArgs>(args?: SelectSubset<T, JournalLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalLines
     * const journalLine = await prisma.journalLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalLineUpdateManyArgs>(args: SelectSubset<T, JournalLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalLines and returns the data updated in the database.
     * @param {JournalLineUpdateManyAndReturnArgs} args - Arguments to update many JournalLines.
     * @example
     * // Update many JournalLines
     * const journalLine = await prisma.journalLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalLines and only return the `id`
     * const journalLineWithIdOnly = await prisma.journalLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalLineUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalLine.
     * @param {JournalLineUpsertArgs} args - Arguments to update or create a JournalLine.
     * @example
     * // Update or create a JournalLine
     * const journalLine = await prisma.journalLine.upsert({
     *   create: {
     *     // ... data to create a JournalLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalLine we want to update
     *   }
     * })
     */
    upsert<T extends JournalLineUpsertArgs>(args: SelectSubset<T, JournalLineUpsertArgs<ExtArgs>>): Prisma__JournalLineClient<$Result.GetResult<Prisma.$JournalLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineCountArgs} args - Arguments to filter JournalLines to count.
     * @example
     * // Count the number of JournalLines
     * const count = await prisma.journalLine.count({
     *   where: {
     *     // ... the filter for the JournalLines we want to count
     *   }
     * })
    **/
    count<T extends JournalLineCountArgs>(
      args?: Subset<T, JournalLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalLineAggregateArgs>(args: Subset<T, JournalLineAggregateArgs>): Prisma.PrismaPromise<GetJournalLineAggregateType<T>>

    /**
     * Group by JournalLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalLineGroupByArgs['orderBy'] }
        : { orderBy?: JournalLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalLine model
   */
  readonly fields: JournalLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entry<T extends JournalEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalEntryDefaultArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalLine model
   */
  interface JournalLineFieldRefs {
    readonly id: FieldRef<"JournalLine", 'Int'>
    readonly entryId: FieldRef<"JournalLine", 'Int'>
    readonly accountId: FieldRef<"JournalLine", 'Int'>
    readonly debit: FieldRef<"JournalLine", 'Float'>
    readonly credit: FieldRef<"JournalLine", 'Float'>
    readonly narration: FieldRef<"JournalLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JournalLine findUnique
   */
  export type JournalLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findUniqueOrThrow
   */
  export type JournalLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine findFirst
   */
  export type JournalLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findFirstOrThrow
   */
  export type JournalLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLine to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalLines.
     */
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine findMany
   */
  export type JournalLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter, which JournalLines to fetch.
     */
    where?: JournalLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalLines to fetch.
     */
    orderBy?: JournalLineOrderByWithRelationInput | JournalLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalLines.
     */
    cursor?: JournalLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalLines.
     */
    skip?: number
    distinct?: JournalLineScalarFieldEnum | JournalLineScalarFieldEnum[]
  }

  /**
   * JournalLine create
   */
  export type JournalLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalLine.
     */
    data: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
  }

  /**
   * JournalLine createMany
   */
  export type JournalLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalLine createManyAndReturn
   */
  export type JournalLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * The data used to create many JournalLines.
     */
    data: JournalLineCreateManyInput | JournalLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLine update
   */
  export type JournalLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalLine.
     */
    data: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
    /**
     * Choose, which JournalLine to update.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine updateMany
   */
  export type JournalLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalLines.
     */
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyInput>
    /**
     * Filter which JournalLines to update
     */
    where?: JournalLineWhereInput
    /**
     * Limit how many JournalLines to update.
     */
    limit?: number
  }

  /**
   * JournalLine updateManyAndReturn
   */
  export type JournalLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * The data used to update JournalLines.
     */
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyInput>
    /**
     * Filter which JournalLines to update
     */
    where?: JournalLineWhereInput
    /**
     * Limit how many JournalLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalLine upsert
   */
  export type JournalLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalLine to update in case it exists.
     */
    where: JournalLineWhereUniqueInput
    /**
     * In case the JournalLine found by the `where` argument doesn't exist, create a new JournalLine with this data.
     */
    create: XOR<JournalLineCreateInput, JournalLineUncheckedCreateInput>
    /**
     * In case the JournalLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalLineUpdateInput, JournalLineUncheckedUpdateInput>
  }

  /**
   * JournalLine delete
   */
  export type JournalLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
    /**
     * Filter which JournalLine to delete.
     */
    where: JournalLineWhereUniqueInput
  }

  /**
   * JournalLine deleteMany
   */
  export type JournalLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalLines to delete
     */
    where?: JournalLineWhereInput
    /**
     * Limit how many JournalLines to delete.
     */
    limit?: number
  }

  /**
   * JournalLine without action
   */
  export type JournalLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalLine
     */
    select?: JournalLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalLine
     */
    omit?: JournalLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalLineInclude<ExtArgs> | null
  }


  /**
   * Model VoucherSequence
   */

  export type AggregateVoucherSequence = {
    _count: VoucherSequenceCountAggregateOutputType | null
    _avg: VoucherSequenceAvgAggregateOutputType | null
    _sum: VoucherSequenceSumAggregateOutputType | null
    _min: VoucherSequenceMinAggregateOutputType | null
    _max: VoucherSequenceMaxAggregateOutputType | null
  }

  export type VoucherSequenceAvgAggregateOutputType = {
    id: number | null
    nextValue: number | null
  }

  export type VoucherSequenceSumAggregateOutputType = {
    id: number | null
    nextValue: number | null
  }

  export type VoucherSequenceMinAggregateOutputType = {
    id: number | null
    type: $Enums.VoucherType | null
    prefix: string | null
    nextValue: number | null
    updatedAt: Date | null
  }

  export type VoucherSequenceMaxAggregateOutputType = {
    id: number | null
    type: $Enums.VoucherType | null
    prefix: string | null
    nextValue: number | null
    updatedAt: Date | null
  }

  export type VoucherSequenceCountAggregateOutputType = {
    id: number
    type: number
    prefix: number
    nextValue: number
    updatedAt: number
    _all: number
  }


  export type VoucherSequenceAvgAggregateInputType = {
    id?: true
    nextValue?: true
  }

  export type VoucherSequenceSumAggregateInputType = {
    id?: true
    nextValue?: true
  }

  export type VoucherSequenceMinAggregateInputType = {
    id?: true
    type?: true
    prefix?: true
    nextValue?: true
    updatedAt?: true
  }

  export type VoucherSequenceMaxAggregateInputType = {
    id?: true
    type?: true
    prefix?: true
    nextValue?: true
    updatedAt?: true
  }

  export type VoucherSequenceCountAggregateInputType = {
    id?: true
    type?: true
    prefix?: true
    nextValue?: true
    updatedAt?: true
    _all?: true
  }

  export type VoucherSequenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherSequence to aggregate.
     */
    where?: VoucherSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherSequences to fetch.
     */
    orderBy?: VoucherSequenceOrderByWithRelationInput | VoucherSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoucherSequences
    **/
    _count?: true | VoucherSequenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherSequenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSequenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherSequenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherSequenceMaxAggregateInputType
  }

  export type GetVoucherSequenceAggregateType<T extends VoucherSequenceAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucherSequence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucherSequence[P]>
      : GetScalarType<T[P], AggregateVoucherSequence[P]>
  }




  export type VoucherSequenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherSequenceWhereInput
    orderBy?: VoucherSequenceOrderByWithAggregationInput | VoucherSequenceOrderByWithAggregationInput[]
    by: VoucherSequenceScalarFieldEnum[] | VoucherSequenceScalarFieldEnum
    having?: VoucherSequenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherSequenceCountAggregateInputType | true
    _avg?: VoucherSequenceAvgAggregateInputType
    _sum?: VoucherSequenceSumAggregateInputType
    _min?: VoucherSequenceMinAggregateInputType
    _max?: VoucherSequenceMaxAggregateInputType
  }

  export type VoucherSequenceGroupByOutputType = {
    id: number
    type: $Enums.VoucherType
    prefix: string
    nextValue: number
    updatedAt: Date
    _count: VoucherSequenceCountAggregateOutputType | null
    _avg: VoucherSequenceAvgAggregateOutputType | null
    _sum: VoucherSequenceSumAggregateOutputType | null
    _min: VoucherSequenceMinAggregateOutputType | null
    _max: VoucherSequenceMaxAggregateOutputType | null
  }

  type GetVoucherSequenceGroupByPayload<T extends VoucherSequenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherSequenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherSequenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherSequenceGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherSequenceGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSequenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    prefix?: boolean
    nextValue?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voucherSequence"]>

  export type VoucherSequenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    prefix?: boolean
    nextValue?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voucherSequence"]>

  export type VoucherSequenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    prefix?: boolean
    nextValue?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voucherSequence"]>

  export type VoucherSequenceSelectScalar = {
    id?: boolean
    type?: boolean
    prefix?: boolean
    nextValue?: boolean
    updatedAt?: boolean
  }

  export type VoucherSequenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "prefix" | "nextValue" | "updatedAt", ExtArgs["result"]["voucherSequence"]>

  export type $VoucherSequencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoucherSequence"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.VoucherType
      prefix: string
      nextValue: number
      updatedAt: Date
    }, ExtArgs["result"]["voucherSequence"]>
    composites: {}
  }

  type VoucherSequenceGetPayload<S extends boolean | null | undefined | VoucherSequenceDefaultArgs> = $Result.GetResult<Prisma.$VoucherSequencePayload, S>

  type VoucherSequenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherSequenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherSequenceCountAggregateInputType | true
    }

  export interface VoucherSequenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoucherSequence'], meta: { name: 'VoucherSequence' } }
    /**
     * Find zero or one VoucherSequence that matches the filter.
     * @param {VoucherSequenceFindUniqueArgs} args - Arguments to find a VoucherSequence
     * @example
     * // Get one VoucherSequence
     * const voucherSequence = await prisma.voucherSequence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherSequenceFindUniqueArgs>(args: SelectSubset<T, VoucherSequenceFindUniqueArgs<ExtArgs>>): Prisma__VoucherSequenceClient<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoucherSequence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherSequenceFindUniqueOrThrowArgs} args - Arguments to find a VoucherSequence
     * @example
     * // Get one VoucherSequence
     * const voucherSequence = await prisma.voucherSequence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherSequenceFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherSequenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherSequenceClient<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherSequence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherSequenceFindFirstArgs} args - Arguments to find a VoucherSequence
     * @example
     * // Get one VoucherSequence
     * const voucherSequence = await prisma.voucherSequence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherSequenceFindFirstArgs>(args?: SelectSubset<T, VoucherSequenceFindFirstArgs<ExtArgs>>): Prisma__VoucherSequenceClient<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherSequence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherSequenceFindFirstOrThrowArgs} args - Arguments to find a VoucherSequence
     * @example
     * // Get one VoucherSequence
     * const voucherSequence = await prisma.voucherSequence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherSequenceFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherSequenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherSequenceClient<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoucherSequences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherSequenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoucherSequences
     * const voucherSequences = await prisma.voucherSequence.findMany()
     * 
     * // Get first 10 VoucherSequences
     * const voucherSequences = await prisma.voucherSequence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherSequenceWithIdOnly = await prisma.voucherSequence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherSequenceFindManyArgs>(args?: SelectSubset<T, VoucherSequenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoucherSequence.
     * @param {VoucherSequenceCreateArgs} args - Arguments to create a VoucherSequence.
     * @example
     * // Create one VoucherSequence
     * const VoucherSequence = await prisma.voucherSequence.create({
     *   data: {
     *     // ... data to create a VoucherSequence
     *   }
     * })
     * 
     */
    create<T extends VoucherSequenceCreateArgs>(args: SelectSubset<T, VoucherSequenceCreateArgs<ExtArgs>>): Prisma__VoucherSequenceClient<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoucherSequences.
     * @param {VoucherSequenceCreateManyArgs} args - Arguments to create many VoucherSequences.
     * @example
     * // Create many VoucherSequences
     * const voucherSequence = await prisma.voucherSequence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherSequenceCreateManyArgs>(args?: SelectSubset<T, VoucherSequenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoucherSequences and returns the data saved in the database.
     * @param {VoucherSequenceCreateManyAndReturnArgs} args - Arguments to create many VoucherSequences.
     * @example
     * // Create many VoucherSequences
     * const voucherSequence = await prisma.voucherSequence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoucherSequences and only return the `id`
     * const voucherSequenceWithIdOnly = await prisma.voucherSequence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherSequenceCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherSequenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoucherSequence.
     * @param {VoucherSequenceDeleteArgs} args - Arguments to delete one VoucherSequence.
     * @example
     * // Delete one VoucherSequence
     * const VoucherSequence = await prisma.voucherSequence.delete({
     *   where: {
     *     // ... filter to delete one VoucherSequence
     *   }
     * })
     * 
     */
    delete<T extends VoucherSequenceDeleteArgs>(args: SelectSubset<T, VoucherSequenceDeleteArgs<ExtArgs>>): Prisma__VoucherSequenceClient<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoucherSequence.
     * @param {VoucherSequenceUpdateArgs} args - Arguments to update one VoucherSequence.
     * @example
     * // Update one VoucherSequence
     * const voucherSequence = await prisma.voucherSequence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherSequenceUpdateArgs>(args: SelectSubset<T, VoucherSequenceUpdateArgs<ExtArgs>>): Prisma__VoucherSequenceClient<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoucherSequences.
     * @param {VoucherSequenceDeleteManyArgs} args - Arguments to filter VoucherSequences to delete.
     * @example
     * // Delete a few VoucherSequences
     * const { count } = await prisma.voucherSequence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherSequenceDeleteManyArgs>(args?: SelectSubset<T, VoucherSequenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherSequenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoucherSequences
     * const voucherSequence = await prisma.voucherSequence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherSequenceUpdateManyArgs>(args: SelectSubset<T, VoucherSequenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherSequences and returns the data updated in the database.
     * @param {VoucherSequenceUpdateManyAndReturnArgs} args - Arguments to update many VoucherSequences.
     * @example
     * // Update many VoucherSequences
     * const voucherSequence = await prisma.voucherSequence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoucherSequences and only return the `id`
     * const voucherSequenceWithIdOnly = await prisma.voucherSequence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherSequenceUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherSequenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoucherSequence.
     * @param {VoucherSequenceUpsertArgs} args - Arguments to update or create a VoucherSequence.
     * @example
     * // Update or create a VoucherSequence
     * const voucherSequence = await prisma.voucherSequence.upsert({
     *   create: {
     *     // ... data to create a VoucherSequence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoucherSequence we want to update
     *   }
     * })
     */
    upsert<T extends VoucherSequenceUpsertArgs>(args: SelectSubset<T, VoucherSequenceUpsertArgs<ExtArgs>>): Prisma__VoucherSequenceClient<$Result.GetResult<Prisma.$VoucherSequencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoucherSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherSequenceCountArgs} args - Arguments to filter VoucherSequences to count.
     * @example
     * // Count the number of VoucherSequences
     * const count = await prisma.voucherSequence.count({
     *   where: {
     *     // ... the filter for the VoucherSequences we want to count
     *   }
     * })
    **/
    count<T extends VoucherSequenceCountArgs>(
      args?: Subset<T, VoucherSequenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherSequenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoucherSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherSequenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherSequenceAggregateArgs>(args: Subset<T, VoucherSequenceAggregateArgs>): Prisma.PrismaPromise<GetVoucherSequenceAggregateType<T>>

    /**
     * Group by VoucherSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherSequenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherSequenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherSequenceGroupByArgs['orderBy'] }
        : { orderBy?: VoucherSequenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherSequenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherSequenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoucherSequence model
   */
  readonly fields: VoucherSequenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoucherSequence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherSequenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoucherSequence model
   */
  interface VoucherSequenceFieldRefs {
    readonly id: FieldRef<"VoucherSequence", 'Int'>
    readonly type: FieldRef<"VoucherSequence", 'VoucherType'>
    readonly prefix: FieldRef<"VoucherSequence", 'String'>
    readonly nextValue: FieldRef<"VoucherSequence", 'Int'>
    readonly updatedAt: FieldRef<"VoucherSequence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VoucherSequence findUnique
   */
  export type VoucherSequenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * Filter, which VoucherSequence to fetch.
     */
    where: VoucherSequenceWhereUniqueInput
  }

  /**
   * VoucherSequence findUniqueOrThrow
   */
  export type VoucherSequenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * Filter, which VoucherSequence to fetch.
     */
    where: VoucherSequenceWhereUniqueInput
  }

  /**
   * VoucherSequence findFirst
   */
  export type VoucherSequenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * Filter, which VoucherSequence to fetch.
     */
    where?: VoucherSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherSequences to fetch.
     */
    orderBy?: VoucherSequenceOrderByWithRelationInput | VoucherSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherSequences.
     */
    cursor?: VoucherSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherSequences.
     */
    distinct?: VoucherSequenceScalarFieldEnum | VoucherSequenceScalarFieldEnum[]
  }

  /**
   * VoucherSequence findFirstOrThrow
   */
  export type VoucherSequenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * Filter, which VoucherSequence to fetch.
     */
    where?: VoucherSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherSequences to fetch.
     */
    orderBy?: VoucherSequenceOrderByWithRelationInput | VoucherSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherSequences.
     */
    cursor?: VoucherSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherSequences.
     */
    distinct?: VoucherSequenceScalarFieldEnum | VoucherSequenceScalarFieldEnum[]
  }

  /**
   * VoucherSequence findMany
   */
  export type VoucherSequenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * Filter, which VoucherSequences to fetch.
     */
    where?: VoucherSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherSequences to fetch.
     */
    orderBy?: VoucherSequenceOrderByWithRelationInput | VoucherSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoucherSequences.
     */
    cursor?: VoucherSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherSequences.
     */
    skip?: number
    distinct?: VoucherSequenceScalarFieldEnum | VoucherSequenceScalarFieldEnum[]
  }

  /**
   * VoucherSequence create
   */
  export type VoucherSequenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * The data needed to create a VoucherSequence.
     */
    data: XOR<VoucherSequenceCreateInput, VoucherSequenceUncheckedCreateInput>
  }

  /**
   * VoucherSequence createMany
   */
  export type VoucherSequenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoucherSequences.
     */
    data: VoucherSequenceCreateManyInput | VoucherSequenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoucherSequence createManyAndReturn
   */
  export type VoucherSequenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * The data used to create many VoucherSequences.
     */
    data: VoucherSequenceCreateManyInput | VoucherSequenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoucherSequence update
   */
  export type VoucherSequenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * The data needed to update a VoucherSequence.
     */
    data: XOR<VoucherSequenceUpdateInput, VoucherSequenceUncheckedUpdateInput>
    /**
     * Choose, which VoucherSequence to update.
     */
    where: VoucherSequenceWhereUniqueInput
  }

  /**
   * VoucherSequence updateMany
   */
  export type VoucherSequenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoucherSequences.
     */
    data: XOR<VoucherSequenceUpdateManyMutationInput, VoucherSequenceUncheckedUpdateManyInput>
    /**
     * Filter which VoucherSequences to update
     */
    where?: VoucherSequenceWhereInput
    /**
     * Limit how many VoucherSequences to update.
     */
    limit?: number
  }

  /**
   * VoucherSequence updateManyAndReturn
   */
  export type VoucherSequenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * The data used to update VoucherSequences.
     */
    data: XOR<VoucherSequenceUpdateManyMutationInput, VoucherSequenceUncheckedUpdateManyInput>
    /**
     * Filter which VoucherSequences to update
     */
    where?: VoucherSequenceWhereInput
    /**
     * Limit how many VoucherSequences to update.
     */
    limit?: number
  }

  /**
   * VoucherSequence upsert
   */
  export type VoucherSequenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * The filter to search for the VoucherSequence to update in case it exists.
     */
    where: VoucherSequenceWhereUniqueInput
    /**
     * In case the VoucherSequence found by the `where` argument doesn't exist, create a new VoucherSequence with this data.
     */
    create: XOR<VoucherSequenceCreateInput, VoucherSequenceUncheckedCreateInput>
    /**
     * In case the VoucherSequence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherSequenceUpdateInput, VoucherSequenceUncheckedUpdateInput>
  }

  /**
   * VoucherSequence delete
   */
  export type VoucherSequenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
    /**
     * Filter which VoucherSequence to delete.
     */
    where: VoucherSequenceWhereUniqueInput
  }

  /**
   * VoucherSequence deleteMany
   */
  export type VoucherSequenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherSequences to delete
     */
    where?: VoucherSequenceWhereInput
    /**
     * Limit how many VoucherSequences to delete.
     */
    limit?: number
  }

  /**
   * VoucherSequence without action
   */
  export type VoucherSequenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherSequence
     */
    select?: VoucherSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherSequence
     */
    omit?: VoucherSequenceOmit<ExtArgs> | null
  }


  /**
   * Model ItemGroup
   */

  export type AggregateItemGroup = {
    _count: ItemGroupCountAggregateOutputType | null
    _avg: ItemGroupAvgAggregateOutputType | null
    _sum: ItemGroupSumAggregateOutputType | null
    _min: ItemGroupMinAggregateOutputType | null
    _max: ItemGroupMaxAggregateOutputType | null
  }

  export type ItemGroupAvgAggregateOutputType = {
    companyId: number | null
  }

  export type ItemGroupSumAggregateOutputType = {
    companyId: number | null
  }

  export type ItemGroupMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    status: string | null
    parentId: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemGroupMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    status: string | null
    parentId: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemGroupCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    status: number
    parentId: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemGroupAvgAggregateInputType = {
    companyId?: true
  }

  export type ItemGroupSumAggregateInputType = {
    companyId?: true
  }

  export type ItemGroupMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    status?: true
    parentId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemGroupMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    status?: true
    parentId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemGroupCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    status?: true
    parentId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemGroup to aggregate.
     */
    where?: ItemGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGroups to fetch.
     */
    orderBy?: ItemGroupOrderByWithRelationInput | ItemGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemGroups
    **/
    _count?: true | ItemGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemGroupMaxAggregateInputType
  }

  export type GetItemGroupAggregateType<T extends ItemGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateItemGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemGroup[P]>
      : GetScalarType<T[P], AggregateItemGroup[P]>
  }




  export type ItemGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemGroupWhereInput
    orderBy?: ItemGroupOrderByWithAggregationInput | ItemGroupOrderByWithAggregationInput[]
    by: ItemGroupScalarFieldEnum[] | ItemGroupScalarFieldEnum
    having?: ItemGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemGroupCountAggregateInputType | true
    _avg?: ItemGroupAvgAggregateInputType
    _sum?: ItemGroupSumAggregateInputType
    _min?: ItemGroupMinAggregateInputType
    _max?: ItemGroupMaxAggregateInputType
  }

  export type ItemGroupGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    status: string
    parentId: string | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: ItemGroupCountAggregateOutputType | null
    _avg: ItemGroupAvgAggregateOutputType | null
    _sum: ItemGroupSumAggregateOutputType | null
    _min: ItemGroupMinAggregateOutputType | null
    _max: ItemGroupMaxAggregateOutputType | null
  }

  type GetItemGroupGroupByPayload<T extends ItemGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupGroupByOutputType[P]>
        }
      >
    >


  export type ItemGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    parentId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ItemGroup$parentArgs<ExtArgs>
    children?: boolean | ItemGroup$childrenArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    itemMasters?: boolean | ItemGroup$itemMastersArgs<ExtArgs>
    _count?: boolean | ItemGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemGroup"]>

  export type ItemGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    parentId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ItemGroup$parentArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemGroup"]>

  export type ItemGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    parentId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ItemGroup$parentArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemGroup"]>

  export type ItemGroupSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    parentId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "status" | "parentId" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["itemGroup"]>
  export type ItemGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ItemGroup$parentArgs<ExtArgs>
    children?: boolean | ItemGroup$childrenArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    itemMasters?: boolean | ItemGroup$itemMastersArgs<ExtArgs>
    _count?: boolean | ItemGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ItemGroup$parentArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ItemGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ItemGroup$parentArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ItemGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemGroup"
    objects: {
      parent: Prisma.$ItemGroupPayload<ExtArgs> | null
      children: Prisma.$ItemGroupPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      itemMasters: Prisma.$ItemMasterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      status: string
      parentId: string | null
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemGroup"]>
    composites: {}
  }

  type ItemGroupGetPayload<S extends boolean | null | undefined | ItemGroupDefaultArgs> = $Result.GetResult<Prisma.$ItemGroupPayload, S>

  type ItemGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemGroupCountAggregateInputType | true
    }

  export interface ItemGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemGroup'], meta: { name: 'ItemGroup' } }
    /**
     * Find zero or one ItemGroup that matches the filter.
     * @param {ItemGroupFindUniqueArgs} args - Arguments to find a ItemGroup
     * @example
     * // Get one ItemGroup
     * const itemGroup = await prisma.itemGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemGroupFindUniqueArgs>(args: SelectSubset<T, ItemGroupFindUniqueArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemGroupFindUniqueOrThrowArgs} args - Arguments to find a ItemGroup
     * @example
     * // Get one ItemGroup
     * const itemGroup = await prisma.itemGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupFindFirstArgs} args - Arguments to find a ItemGroup
     * @example
     * // Get one ItemGroup
     * const itemGroup = await prisma.itemGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemGroupFindFirstArgs>(args?: SelectSubset<T, ItemGroupFindFirstArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupFindFirstOrThrowArgs} args - Arguments to find a ItemGroup
     * @example
     * // Get one ItemGroup
     * const itemGroup = await prisma.itemGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemGroups
     * const itemGroups = await prisma.itemGroup.findMany()
     * 
     * // Get first 10 ItemGroups
     * const itemGroups = await prisma.itemGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemGroupWithIdOnly = await prisma.itemGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemGroupFindManyArgs>(args?: SelectSubset<T, ItemGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemGroup.
     * @param {ItemGroupCreateArgs} args - Arguments to create a ItemGroup.
     * @example
     * // Create one ItemGroup
     * const ItemGroup = await prisma.itemGroup.create({
     *   data: {
     *     // ... data to create a ItemGroup
     *   }
     * })
     * 
     */
    create<T extends ItemGroupCreateArgs>(args: SelectSubset<T, ItemGroupCreateArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemGroups.
     * @param {ItemGroupCreateManyArgs} args - Arguments to create many ItemGroups.
     * @example
     * // Create many ItemGroups
     * const itemGroup = await prisma.itemGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemGroupCreateManyArgs>(args?: SelectSubset<T, ItemGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemGroups and returns the data saved in the database.
     * @param {ItemGroupCreateManyAndReturnArgs} args - Arguments to create many ItemGroups.
     * @example
     * // Create many ItemGroups
     * const itemGroup = await prisma.itemGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemGroups and only return the `id`
     * const itemGroupWithIdOnly = await prisma.itemGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemGroup.
     * @param {ItemGroupDeleteArgs} args - Arguments to delete one ItemGroup.
     * @example
     * // Delete one ItemGroup
     * const ItemGroup = await prisma.itemGroup.delete({
     *   where: {
     *     // ... filter to delete one ItemGroup
     *   }
     * })
     * 
     */
    delete<T extends ItemGroupDeleteArgs>(args: SelectSubset<T, ItemGroupDeleteArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemGroup.
     * @param {ItemGroupUpdateArgs} args - Arguments to update one ItemGroup.
     * @example
     * // Update one ItemGroup
     * const itemGroup = await prisma.itemGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemGroupUpdateArgs>(args: SelectSubset<T, ItemGroupUpdateArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemGroups.
     * @param {ItemGroupDeleteManyArgs} args - Arguments to filter ItemGroups to delete.
     * @example
     * // Delete a few ItemGroups
     * const { count } = await prisma.itemGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemGroupDeleteManyArgs>(args?: SelectSubset<T, ItemGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemGroups
     * const itemGroup = await prisma.itemGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemGroupUpdateManyArgs>(args: SelectSubset<T, ItemGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemGroups and returns the data updated in the database.
     * @param {ItemGroupUpdateManyAndReturnArgs} args - Arguments to update many ItemGroups.
     * @example
     * // Update many ItemGroups
     * const itemGroup = await prisma.itemGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemGroups and only return the `id`
     * const itemGroupWithIdOnly = await prisma.itemGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemGroup.
     * @param {ItemGroupUpsertArgs} args - Arguments to update or create a ItemGroup.
     * @example
     * // Update or create a ItemGroup
     * const itemGroup = await prisma.itemGroup.upsert({
     *   create: {
     *     // ... data to create a ItemGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemGroup we want to update
     *   }
     * })
     */
    upsert<T extends ItemGroupUpsertArgs>(args: SelectSubset<T, ItemGroupUpsertArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupCountArgs} args - Arguments to filter ItemGroups to count.
     * @example
     * // Count the number of ItemGroups
     * const count = await prisma.itemGroup.count({
     *   where: {
     *     // ... the filter for the ItemGroups we want to count
     *   }
     * })
    **/
    count<T extends ItemGroupCountArgs>(
      args?: Subset<T, ItemGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemGroupAggregateArgs>(args: Subset<T, ItemGroupAggregateArgs>): Prisma.PrismaPromise<GetItemGroupAggregateType<T>>

    /**
     * Group by ItemGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemGroup model
   */
  readonly fields: ItemGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends ItemGroup$parentArgs<ExtArgs> = {}>(args?: Subset<T, ItemGroup$parentArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends ItemGroup$childrenArgs<ExtArgs> = {}>(args?: Subset<T, ItemGroup$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    itemMasters<T extends ItemGroup$itemMastersArgs<ExtArgs> = {}>(args?: Subset<T, ItemGroup$itemMastersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemGroup model
   */
  interface ItemGroupFieldRefs {
    readonly id: FieldRef<"ItemGroup", 'String'>
    readonly code: FieldRef<"ItemGroup", 'String'>
    readonly name: FieldRef<"ItemGroup", 'String'>
    readonly description: FieldRef<"ItemGroup", 'String'>
    readonly status: FieldRef<"ItemGroup", 'String'>
    readonly parentId: FieldRef<"ItemGroup", 'String'>
    readonly companyId: FieldRef<"ItemGroup", 'Int'>
    readonly createdAt: FieldRef<"ItemGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemGroup findUnique
   */
  export type ItemGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    /**
     * Filter, which ItemGroup to fetch.
     */
    where: ItemGroupWhereUniqueInput
  }

  /**
   * ItemGroup findUniqueOrThrow
   */
  export type ItemGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    /**
     * Filter, which ItemGroup to fetch.
     */
    where: ItemGroupWhereUniqueInput
  }

  /**
   * ItemGroup findFirst
   */
  export type ItemGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    /**
     * Filter, which ItemGroup to fetch.
     */
    where?: ItemGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGroups to fetch.
     */
    orderBy?: ItemGroupOrderByWithRelationInput | ItemGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemGroups.
     */
    cursor?: ItemGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemGroups.
     */
    distinct?: ItemGroupScalarFieldEnum | ItemGroupScalarFieldEnum[]
  }

  /**
   * ItemGroup findFirstOrThrow
   */
  export type ItemGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    /**
     * Filter, which ItemGroup to fetch.
     */
    where?: ItemGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGroups to fetch.
     */
    orderBy?: ItemGroupOrderByWithRelationInput | ItemGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemGroups.
     */
    cursor?: ItemGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemGroups.
     */
    distinct?: ItemGroupScalarFieldEnum | ItemGroupScalarFieldEnum[]
  }

  /**
   * ItemGroup findMany
   */
  export type ItemGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    /**
     * Filter, which ItemGroups to fetch.
     */
    where?: ItemGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGroups to fetch.
     */
    orderBy?: ItemGroupOrderByWithRelationInput | ItemGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemGroups.
     */
    cursor?: ItemGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGroups.
     */
    skip?: number
    distinct?: ItemGroupScalarFieldEnum | ItemGroupScalarFieldEnum[]
  }

  /**
   * ItemGroup create
   */
  export type ItemGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemGroup.
     */
    data: XOR<ItemGroupCreateInput, ItemGroupUncheckedCreateInput>
  }

  /**
   * ItemGroup createMany
   */
  export type ItemGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemGroups.
     */
    data: ItemGroupCreateManyInput | ItemGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemGroup createManyAndReturn
   */
  export type ItemGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * The data used to create many ItemGroups.
     */
    data: ItemGroupCreateManyInput | ItemGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemGroup update
   */
  export type ItemGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemGroup.
     */
    data: XOR<ItemGroupUpdateInput, ItemGroupUncheckedUpdateInput>
    /**
     * Choose, which ItemGroup to update.
     */
    where: ItemGroupWhereUniqueInput
  }

  /**
   * ItemGroup updateMany
   */
  export type ItemGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemGroups.
     */
    data: XOR<ItemGroupUpdateManyMutationInput, ItemGroupUncheckedUpdateManyInput>
    /**
     * Filter which ItemGroups to update
     */
    where?: ItemGroupWhereInput
    /**
     * Limit how many ItemGroups to update.
     */
    limit?: number
  }

  /**
   * ItemGroup updateManyAndReturn
   */
  export type ItemGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * The data used to update ItemGroups.
     */
    data: XOR<ItemGroupUpdateManyMutationInput, ItemGroupUncheckedUpdateManyInput>
    /**
     * Filter which ItemGroups to update
     */
    where?: ItemGroupWhereInput
    /**
     * Limit how many ItemGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemGroup upsert
   */
  export type ItemGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemGroup to update in case it exists.
     */
    where: ItemGroupWhereUniqueInput
    /**
     * In case the ItemGroup found by the `where` argument doesn't exist, create a new ItemGroup with this data.
     */
    create: XOR<ItemGroupCreateInput, ItemGroupUncheckedCreateInput>
    /**
     * In case the ItemGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemGroupUpdateInput, ItemGroupUncheckedUpdateInput>
  }

  /**
   * ItemGroup delete
   */
  export type ItemGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    /**
     * Filter which ItemGroup to delete.
     */
    where: ItemGroupWhereUniqueInput
  }

  /**
   * ItemGroup deleteMany
   */
  export type ItemGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemGroups to delete
     */
    where?: ItemGroupWhereInput
    /**
     * Limit how many ItemGroups to delete.
     */
    limit?: number
  }

  /**
   * ItemGroup.parent
   */
  export type ItemGroup$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    where?: ItemGroupWhereInput
  }

  /**
   * ItemGroup.children
   */
  export type ItemGroup$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
    where?: ItemGroupWhereInput
    orderBy?: ItemGroupOrderByWithRelationInput | ItemGroupOrderByWithRelationInput[]
    cursor?: ItemGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemGroupScalarFieldEnum | ItemGroupScalarFieldEnum[]
  }

  /**
   * ItemGroup.itemMasters
   */
  export type ItemGroup$itemMastersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    where?: ItemMasterWhereInput
    orderBy?: ItemMasterOrderByWithRelationInput | ItemMasterOrderByWithRelationInput[]
    cursor?: ItemMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemMasterScalarFieldEnum | ItemMasterScalarFieldEnum[]
  }

  /**
   * ItemGroup without action
   */
  export type ItemGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGroup
     */
    select?: ItemGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGroup
     */
    omit?: ItemGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGroupInclude<ExtArgs> | null
  }


  /**
   * Model Color
   */

  export type AggregateColor = {
    _count: ColorCountAggregateOutputType | null
    _avg: ColorAvgAggregateOutputType | null
    _sum: ColorSumAggregateOutputType | null
    _min: ColorMinAggregateOutputType | null
    _max: ColorMaxAggregateOutputType | null
  }

  export type ColorAvgAggregateOutputType = {
    companyId: number | null
  }

  export type ColorSumAggregateOutputType = {
    companyId: number | null
  }

  export type ColorMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    pictureUrl: string | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColorMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    pictureUrl: string | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColorCountAggregateOutputType = {
    id: number
    code: number
    name: number
    pictureUrl: number
    status: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ColorAvgAggregateInputType = {
    companyId?: true
  }

  export type ColorSumAggregateInputType = {
    companyId?: true
  }

  export type ColorMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    pictureUrl?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColorMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    pictureUrl?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColorCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    pictureUrl?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ColorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Color to aggregate.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Colors
    **/
    _count?: true | ColorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColorMaxAggregateInputType
  }

  export type GetColorAggregateType<T extends ColorAggregateArgs> = {
        [P in keyof T & keyof AggregateColor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColor[P]>
      : GetScalarType<T[P], AggregateColor[P]>
  }




  export type ColorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColorWhereInput
    orderBy?: ColorOrderByWithAggregationInput | ColorOrderByWithAggregationInput[]
    by: ColorScalarFieldEnum[] | ColorScalarFieldEnum
    having?: ColorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColorCountAggregateInputType | true
    _avg?: ColorAvgAggregateInputType
    _sum?: ColorSumAggregateInputType
    _min?: ColorMinAggregateInputType
    _max?: ColorMaxAggregateInputType
  }

  export type ColorGroupByOutputType = {
    id: string
    code: string
    name: string
    pictureUrl: string | null
    status: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: ColorCountAggregateOutputType | null
    _avg: ColorAvgAggregateOutputType | null
    _sum: ColorSumAggregateOutputType | null
    _min: ColorMinAggregateOutputType | null
    _max: ColorMaxAggregateOutputType | null
  }

  type GetColorGroupByPayload<T extends ColorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColorGroupByOutputType[P]>
            : GetScalarType<T[P], ColorGroupByOutputType[P]>
        }
      >
    >


  export type ColorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    pictureUrl?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | Color$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | Color$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | Color$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | Color$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | ColorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["color"]>

  export type ColorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    pictureUrl?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["color"]>

  export type ColorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    pictureUrl?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["color"]>

  export type ColorSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    pictureUrl?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ColorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "pictureUrl" | "status" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["color"]>
  export type ColorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | Color$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | Color$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | Color$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | Color$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | ColorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ColorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ColorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ColorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Color"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      grnItems: Prisma.$GRNItemPayload<ExtArgs>[]
      purchaseInvoiceItems: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
      purchaseReturnItems: Prisma.$PurchaseReturnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      pictureUrl: string | null
      status: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["color"]>
    composites: {}
  }

  type ColorGetPayload<S extends boolean | null | undefined | ColorDefaultArgs> = $Result.GetResult<Prisma.$ColorPayload, S>

  type ColorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ColorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ColorCountAggregateInputType | true
    }

  export interface ColorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Color'], meta: { name: 'Color' } }
    /**
     * Find zero or one Color that matches the filter.
     * @param {ColorFindUniqueArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColorFindUniqueArgs>(args: SelectSubset<T, ColorFindUniqueArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Color that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ColorFindUniqueOrThrowArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColorFindUniqueOrThrowArgs>(args: SelectSubset<T, ColorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Color that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorFindFirstArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColorFindFirstArgs>(args?: SelectSubset<T, ColorFindFirstArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Color that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorFindFirstOrThrowArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColorFindFirstOrThrowArgs>(args?: SelectSubset<T, ColorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Colors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Colors
     * const colors = await prisma.color.findMany()
     * 
     * // Get first 10 Colors
     * const colors = await prisma.color.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const colorWithIdOnly = await prisma.color.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ColorFindManyArgs>(args?: SelectSubset<T, ColorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Color.
     * @param {ColorCreateArgs} args - Arguments to create a Color.
     * @example
     * // Create one Color
     * const Color = await prisma.color.create({
     *   data: {
     *     // ... data to create a Color
     *   }
     * })
     * 
     */
    create<T extends ColorCreateArgs>(args: SelectSubset<T, ColorCreateArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Colors.
     * @param {ColorCreateManyArgs} args - Arguments to create many Colors.
     * @example
     * // Create many Colors
     * const color = await prisma.color.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColorCreateManyArgs>(args?: SelectSubset<T, ColorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Colors and returns the data saved in the database.
     * @param {ColorCreateManyAndReturnArgs} args - Arguments to create many Colors.
     * @example
     * // Create many Colors
     * const color = await prisma.color.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Colors and only return the `id`
     * const colorWithIdOnly = await prisma.color.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ColorCreateManyAndReturnArgs>(args?: SelectSubset<T, ColorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Color.
     * @param {ColorDeleteArgs} args - Arguments to delete one Color.
     * @example
     * // Delete one Color
     * const Color = await prisma.color.delete({
     *   where: {
     *     // ... filter to delete one Color
     *   }
     * })
     * 
     */
    delete<T extends ColorDeleteArgs>(args: SelectSubset<T, ColorDeleteArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Color.
     * @param {ColorUpdateArgs} args - Arguments to update one Color.
     * @example
     * // Update one Color
     * const color = await prisma.color.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColorUpdateArgs>(args: SelectSubset<T, ColorUpdateArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Colors.
     * @param {ColorDeleteManyArgs} args - Arguments to filter Colors to delete.
     * @example
     * // Delete a few Colors
     * const { count } = await prisma.color.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColorDeleteManyArgs>(args?: SelectSubset<T, ColorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Colors
     * const color = await prisma.color.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColorUpdateManyArgs>(args: SelectSubset<T, ColorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colors and returns the data updated in the database.
     * @param {ColorUpdateManyAndReturnArgs} args - Arguments to update many Colors.
     * @example
     * // Update many Colors
     * const color = await prisma.color.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Colors and only return the `id`
     * const colorWithIdOnly = await prisma.color.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ColorUpdateManyAndReturnArgs>(args: SelectSubset<T, ColorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Color.
     * @param {ColorUpsertArgs} args - Arguments to update or create a Color.
     * @example
     * // Update or create a Color
     * const color = await prisma.color.upsert({
     *   create: {
     *     // ... data to create a Color
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Color we want to update
     *   }
     * })
     */
    upsert<T extends ColorUpsertArgs>(args: SelectSubset<T, ColorUpsertArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorCountArgs} args - Arguments to filter Colors to count.
     * @example
     * // Count the number of Colors
     * const count = await prisma.color.count({
     *   where: {
     *     // ... the filter for the Colors we want to count
     *   }
     * })
    **/
    count<T extends ColorCountArgs>(
      args?: Subset<T, ColorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Color.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColorAggregateArgs>(args: Subset<T, ColorAggregateArgs>): Prisma.PrismaPromise<GetColorAggregateType<T>>

    /**
     * Group by Color.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColorGroupByArgs['orderBy'] }
        : { orderBy?: ColorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Color model
   */
  readonly fields: ColorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Color.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrderItems<T extends Color$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Color$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grnItems<T extends Color$grnItemsArgs<ExtArgs> = {}>(args?: Subset<T, Color$grnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoiceItems<T extends Color$purchaseInvoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Color$purchaseInvoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturnItems<T extends Color$purchaseReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, Color$purchaseReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Color model
   */
  interface ColorFieldRefs {
    readonly id: FieldRef<"Color", 'String'>
    readonly code: FieldRef<"Color", 'String'>
    readonly name: FieldRef<"Color", 'String'>
    readonly pictureUrl: FieldRef<"Color", 'String'>
    readonly status: FieldRef<"Color", 'String'>
    readonly companyId: FieldRef<"Color", 'Int'>
    readonly createdAt: FieldRef<"Color", 'DateTime'>
    readonly updatedAt: FieldRef<"Color", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Color findUnique
   */
  export type ColorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color findUniqueOrThrow
   */
  export type ColorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color findFirst
   */
  export type ColorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colors.
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colors.
     */
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Color findFirstOrThrow
   */
  export type ColorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colors.
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colors.
     */
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Color findMany
   */
  export type ColorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Colors to fetch.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Colors.
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Color create
   */
  export type ColorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * The data needed to create a Color.
     */
    data: XOR<ColorCreateInput, ColorUncheckedCreateInput>
  }

  /**
   * Color createMany
   */
  export type ColorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Colors.
     */
    data: ColorCreateManyInput | ColorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Color createManyAndReturn
   */
  export type ColorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * The data used to create many Colors.
     */
    data: ColorCreateManyInput | ColorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Color update
   */
  export type ColorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * The data needed to update a Color.
     */
    data: XOR<ColorUpdateInput, ColorUncheckedUpdateInput>
    /**
     * Choose, which Color to update.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color updateMany
   */
  export type ColorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Colors.
     */
    data: XOR<ColorUpdateManyMutationInput, ColorUncheckedUpdateManyInput>
    /**
     * Filter which Colors to update
     */
    where?: ColorWhereInput
    /**
     * Limit how many Colors to update.
     */
    limit?: number
  }

  /**
   * Color updateManyAndReturn
   */
  export type ColorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * The data used to update Colors.
     */
    data: XOR<ColorUpdateManyMutationInput, ColorUncheckedUpdateManyInput>
    /**
     * Filter which Colors to update
     */
    where?: ColorWhereInput
    /**
     * Limit how many Colors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Color upsert
   */
  export type ColorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * The filter to search for the Color to update in case it exists.
     */
    where: ColorWhereUniqueInput
    /**
     * In case the Color found by the `where` argument doesn't exist, create a new Color with this data.
     */
    create: XOR<ColorCreateInput, ColorUncheckedCreateInput>
    /**
     * In case the Color was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColorUpdateInput, ColorUncheckedUpdateInput>
  }

  /**
   * Color delete
   */
  export type ColorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter which Color to delete.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color deleteMany
   */
  export type ColorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colors to delete
     */
    where?: ColorWhereInput
    /**
     * Limit how many Colors to delete.
     */
    limit?: number
  }

  /**
   * Color.purchaseOrderItems
   */
  export type Color$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * Color.grnItems
   */
  export type Color$grnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    where?: GRNItemWhereInput
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    cursor?: GRNItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * Color.purchaseInvoiceItems
   */
  export type Color$purchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * Color.purchaseReturnItems
   */
  export type Color$purchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    where?: PurchaseReturnItemWhereInput
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    cursor?: PurchaseReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnItemScalarFieldEnum | PurchaseReturnItemScalarFieldEnum[]
  }

  /**
   * Color without action
   */
  export type ColorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    companyId: number | null
  }

  export type BrandSumAggregateOutputType = {
    companyId: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    code: number
    name: number
    status: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    companyId?: true
  }

  export type BrandSumAggregateInputType = {
    companyId?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: string
    code: string
    name: string
    status: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | Brand$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | Brand$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | Brand$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | Brand$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "status" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | Brand$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | Brand$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | Brand$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | Brand$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type BrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      grnItems: Prisma.$GRNItemPayload<ExtArgs>[]
      purchaseInvoiceItems: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
      purchaseReturnItems: Prisma.$PurchaseReturnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      status: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {BrandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrandUpdateManyAndReturnArgs>(args: SelectSubset<T, BrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrderItems<T extends Brand$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grnItems<T extends Brand$grnItemsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$grnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoiceItems<T extends Brand$purchaseInvoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$purchaseInvoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturnItems<T extends Brand$purchaseReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$purchaseReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'String'>
    readonly code: FieldRef<"Brand", 'String'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly status: FieldRef<"Brand", 'String'>
    readonly companyId: FieldRef<"Brand", 'Int'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
    readonly updatedAt: FieldRef<"Brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand updateManyAndReturn
   */
  export type BrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.purchaseOrderItems
   */
  export type Brand$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * Brand.grnItems
   */
  export type Brand$grnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    where?: GRNItemWhereInput
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    cursor?: GRNItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * Brand.purchaseInvoiceItems
   */
  export type Brand$purchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * Brand.purchaseReturnItems
   */
  export type Brand$purchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    where?: PurchaseReturnItemWhereInput
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    cursor?: PurchaseReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnItemScalarFieldEnum | PurchaseReturnItemScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model ItemGrade
   */

  export type AggregateItemGrade = {
    _count: ItemGradeCountAggregateOutputType | null
    _avg: ItemGradeAvgAggregateOutputType | null
    _sum: ItemGradeSumAggregateOutputType | null
    _min: ItemGradeMinAggregateOutputType | null
    _max: ItemGradeMaxAggregateOutputType | null
  }

  export type ItemGradeAvgAggregateOutputType = {
    companyId: number | null
  }

  export type ItemGradeSumAggregateOutputType = {
    companyId: number | null
  }

  export type ItemGradeMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemGradeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemGradeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    status: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemGradeAvgAggregateInputType = {
    companyId?: true
  }

  export type ItemGradeSumAggregateInputType = {
    companyId?: true
  }

  export type ItemGradeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemGradeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemGradeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemGradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemGrade to aggregate.
     */
    where?: ItemGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGrades to fetch.
     */
    orderBy?: ItemGradeOrderByWithRelationInput | ItemGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemGrades
    **/
    _count?: true | ItemGradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemGradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemGradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemGradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemGradeMaxAggregateInputType
  }

  export type GetItemGradeAggregateType<T extends ItemGradeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemGrade[P]>
      : GetScalarType<T[P], AggregateItemGrade[P]>
  }




  export type ItemGradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemGradeWhereInput
    orderBy?: ItemGradeOrderByWithAggregationInput | ItemGradeOrderByWithAggregationInput[]
    by: ItemGradeScalarFieldEnum[] | ItemGradeScalarFieldEnum
    having?: ItemGradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemGradeCountAggregateInputType | true
    _avg?: ItemGradeAvgAggregateInputType
    _sum?: ItemGradeSumAggregateInputType
    _min?: ItemGradeMinAggregateInputType
    _max?: ItemGradeMaxAggregateInputType
  }

  export type ItemGradeGroupByOutputType = {
    id: string
    code: string
    name: string
    status: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: ItemGradeCountAggregateOutputType | null
    _avg: ItemGradeAvgAggregateOutputType | null
    _sum: ItemGradeSumAggregateOutputType | null
    _min: ItemGradeMinAggregateOutputType | null
    _max: ItemGradeMaxAggregateOutputType | null
  }

  type GetItemGradeGroupByPayload<T extends ItemGradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGradeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGradeGroupByOutputType[P]>
        }
      >
    >


  export type ItemGradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | ItemGrade$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | ItemGrade$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | ItemGrade$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | ItemGrade$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | ItemGradeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemGrade"]>

  export type ItemGradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemGrade"]>

  export type ItemGradeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemGrade"]>

  export type ItemGradeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemGradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "status" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["itemGrade"]>
  export type ItemGradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | ItemGrade$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | ItemGrade$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | ItemGrade$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | ItemGrade$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | ItemGradeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemGradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ItemGradeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ItemGradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemGrade"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      grnItems: Prisma.$GRNItemPayload<ExtArgs>[]
      purchaseInvoiceItems: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
      purchaseReturnItems: Prisma.$PurchaseReturnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      status: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemGrade"]>
    composites: {}
  }

  type ItemGradeGetPayload<S extends boolean | null | undefined | ItemGradeDefaultArgs> = $Result.GetResult<Prisma.$ItemGradePayload, S>

  type ItemGradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemGradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemGradeCountAggregateInputType | true
    }

  export interface ItemGradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemGrade'], meta: { name: 'ItemGrade' } }
    /**
     * Find zero or one ItemGrade that matches the filter.
     * @param {ItemGradeFindUniqueArgs} args - Arguments to find a ItemGrade
     * @example
     * // Get one ItemGrade
     * const itemGrade = await prisma.itemGrade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemGradeFindUniqueArgs>(args: SelectSubset<T, ItemGradeFindUniqueArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemGrade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemGradeFindUniqueOrThrowArgs} args - Arguments to find a ItemGrade
     * @example
     * // Get one ItemGrade
     * const itemGrade = await prisma.itemGrade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemGradeFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemGradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemGrade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGradeFindFirstArgs} args - Arguments to find a ItemGrade
     * @example
     * // Get one ItemGrade
     * const itemGrade = await prisma.itemGrade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemGradeFindFirstArgs>(args?: SelectSubset<T, ItemGradeFindFirstArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemGrade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGradeFindFirstOrThrowArgs} args - Arguments to find a ItemGrade
     * @example
     * // Get one ItemGrade
     * const itemGrade = await prisma.itemGrade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemGradeFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemGradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemGrades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemGrades
     * const itemGrades = await prisma.itemGrade.findMany()
     * 
     * // Get first 10 ItemGrades
     * const itemGrades = await prisma.itemGrade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemGradeWithIdOnly = await prisma.itemGrade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemGradeFindManyArgs>(args?: SelectSubset<T, ItemGradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemGrade.
     * @param {ItemGradeCreateArgs} args - Arguments to create a ItemGrade.
     * @example
     * // Create one ItemGrade
     * const ItemGrade = await prisma.itemGrade.create({
     *   data: {
     *     // ... data to create a ItemGrade
     *   }
     * })
     * 
     */
    create<T extends ItemGradeCreateArgs>(args: SelectSubset<T, ItemGradeCreateArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemGrades.
     * @param {ItemGradeCreateManyArgs} args - Arguments to create many ItemGrades.
     * @example
     * // Create many ItemGrades
     * const itemGrade = await prisma.itemGrade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemGradeCreateManyArgs>(args?: SelectSubset<T, ItemGradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemGrades and returns the data saved in the database.
     * @param {ItemGradeCreateManyAndReturnArgs} args - Arguments to create many ItemGrades.
     * @example
     * // Create many ItemGrades
     * const itemGrade = await prisma.itemGrade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemGrades and only return the `id`
     * const itemGradeWithIdOnly = await prisma.itemGrade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemGradeCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemGradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemGrade.
     * @param {ItemGradeDeleteArgs} args - Arguments to delete one ItemGrade.
     * @example
     * // Delete one ItemGrade
     * const ItemGrade = await prisma.itemGrade.delete({
     *   where: {
     *     // ... filter to delete one ItemGrade
     *   }
     * })
     * 
     */
    delete<T extends ItemGradeDeleteArgs>(args: SelectSubset<T, ItemGradeDeleteArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemGrade.
     * @param {ItemGradeUpdateArgs} args - Arguments to update one ItemGrade.
     * @example
     * // Update one ItemGrade
     * const itemGrade = await prisma.itemGrade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemGradeUpdateArgs>(args: SelectSubset<T, ItemGradeUpdateArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemGrades.
     * @param {ItemGradeDeleteManyArgs} args - Arguments to filter ItemGrades to delete.
     * @example
     * // Delete a few ItemGrades
     * const { count } = await prisma.itemGrade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemGradeDeleteManyArgs>(args?: SelectSubset<T, ItemGradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemGrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemGrades
     * const itemGrade = await prisma.itemGrade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemGradeUpdateManyArgs>(args: SelectSubset<T, ItemGradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemGrades and returns the data updated in the database.
     * @param {ItemGradeUpdateManyAndReturnArgs} args - Arguments to update many ItemGrades.
     * @example
     * // Update many ItemGrades
     * const itemGrade = await prisma.itemGrade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemGrades and only return the `id`
     * const itemGradeWithIdOnly = await prisma.itemGrade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemGradeUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemGradeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemGrade.
     * @param {ItemGradeUpsertArgs} args - Arguments to update or create a ItemGrade.
     * @example
     * // Update or create a ItemGrade
     * const itemGrade = await prisma.itemGrade.upsert({
     *   create: {
     *     // ... data to create a ItemGrade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemGrade we want to update
     *   }
     * })
     */
    upsert<T extends ItemGradeUpsertArgs>(args: SelectSubset<T, ItemGradeUpsertArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemGrades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGradeCountArgs} args - Arguments to filter ItemGrades to count.
     * @example
     * // Count the number of ItemGrades
     * const count = await prisma.itemGrade.count({
     *   where: {
     *     // ... the filter for the ItemGrades we want to count
     *   }
     * })
    **/
    count<T extends ItemGradeCountArgs>(
      args?: Subset<T, ItemGradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemGradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemGrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemGradeAggregateArgs>(args: Subset<T, ItemGradeAggregateArgs>): Prisma.PrismaPromise<GetItemGradeAggregateType<T>>

    /**
     * Group by ItemGrade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGradeGroupByArgs['orderBy'] }
        : { orderBy?: ItemGradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemGrade model
   */
  readonly fields: ItemGradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemGrade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemGradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrderItems<T extends ItemGrade$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemGrade$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grnItems<T extends ItemGrade$grnItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemGrade$grnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoiceItems<T extends ItemGrade$purchaseInvoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemGrade$purchaseInvoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturnItems<T extends ItemGrade$purchaseReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemGrade$purchaseReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemGrade model
   */
  interface ItemGradeFieldRefs {
    readonly id: FieldRef<"ItemGrade", 'String'>
    readonly code: FieldRef<"ItemGrade", 'String'>
    readonly name: FieldRef<"ItemGrade", 'String'>
    readonly status: FieldRef<"ItemGrade", 'String'>
    readonly companyId: FieldRef<"ItemGrade", 'Int'>
    readonly createdAt: FieldRef<"ItemGrade", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemGrade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemGrade findUnique
   */
  export type ItemGradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    /**
     * Filter, which ItemGrade to fetch.
     */
    where: ItemGradeWhereUniqueInput
  }

  /**
   * ItemGrade findUniqueOrThrow
   */
  export type ItemGradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    /**
     * Filter, which ItemGrade to fetch.
     */
    where: ItemGradeWhereUniqueInput
  }

  /**
   * ItemGrade findFirst
   */
  export type ItemGradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    /**
     * Filter, which ItemGrade to fetch.
     */
    where?: ItemGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGrades to fetch.
     */
    orderBy?: ItemGradeOrderByWithRelationInput | ItemGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemGrades.
     */
    cursor?: ItemGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemGrades.
     */
    distinct?: ItemGradeScalarFieldEnum | ItemGradeScalarFieldEnum[]
  }

  /**
   * ItemGrade findFirstOrThrow
   */
  export type ItemGradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    /**
     * Filter, which ItemGrade to fetch.
     */
    where?: ItemGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGrades to fetch.
     */
    orderBy?: ItemGradeOrderByWithRelationInput | ItemGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemGrades.
     */
    cursor?: ItemGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGrades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemGrades.
     */
    distinct?: ItemGradeScalarFieldEnum | ItemGradeScalarFieldEnum[]
  }

  /**
   * ItemGrade findMany
   */
  export type ItemGradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    /**
     * Filter, which ItemGrades to fetch.
     */
    where?: ItemGradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemGrades to fetch.
     */
    orderBy?: ItemGradeOrderByWithRelationInput | ItemGradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemGrades.
     */
    cursor?: ItemGradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemGrades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemGrades.
     */
    skip?: number
    distinct?: ItemGradeScalarFieldEnum | ItemGradeScalarFieldEnum[]
  }

  /**
   * ItemGrade create
   */
  export type ItemGradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemGrade.
     */
    data: XOR<ItemGradeCreateInput, ItemGradeUncheckedCreateInput>
  }

  /**
   * ItemGrade createMany
   */
  export type ItemGradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemGrades.
     */
    data: ItemGradeCreateManyInput | ItemGradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemGrade createManyAndReturn
   */
  export type ItemGradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * The data used to create many ItemGrades.
     */
    data: ItemGradeCreateManyInput | ItemGradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemGrade update
   */
  export type ItemGradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemGrade.
     */
    data: XOR<ItemGradeUpdateInput, ItemGradeUncheckedUpdateInput>
    /**
     * Choose, which ItemGrade to update.
     */
    where: ItemGradeWhereUniqueInput
  }

  /**
   * ItemGrade updateMany
   */
  export type ItemGradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemGrades.
     */
    data: XOR<ItemGradeUpdateManyMutationInput, ItemGradeUncheckedUpdateManyInput>
    /**
     * Filter which ItemGrades to update
     */
    where?: ItemGradeWhereInput
    /**
     * Limit how many ItemGrades to update.
     */
    limit?: number
  }

  /**
   * ItemGrade updateManyAndReturn
   */
  export type ItemGradeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * The data used to update ItemGrades.
     */
    data: XOR<ItemGradeUpdateManyMutationInput, ItemGradeUncheckedUpdateManyInput>
    /**
     * Filter which ItemGrades to update
     */
    where?: ItemGradeWhereInput
    /**
     * Limit how many ItemGrades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemGrade upsert
   */
  export type ItemGradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemGrade to update in case it exists.
     */
    where: ItemGradeWhereUniqueInput
    /**
     * In case the ItemGrade found by the `where` argument doesn't exist, create a new ItemGrade with this data.
     */
    create: XOR<ItemGradeCreateInput, ItemGradeUncheckedCreateInput>
    /**
     * In case the ItemGrade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemGradeUpdateInput, ItemGradeUncheckedUpdateInput>
  }

  /**
   * ItemGrade delete
   */
  export type ItemGradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    /**
     * Filter which ItemGrade to delete.
     */
    where: ItemGradeWhereUniqueInput
  }

  /**
   * ItemGrade deleteMany
   */
  export type ItemGradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemGrades to delete
     */
    where?: ItemGradeWhereInput
    /**
     * Limit how many ItemGrades to delete.
     */
    limit?: number
  }

  /**
   * ItemGrade.purchaseOrderItems
   */
  export type ItemGrade$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * ItemGrade.grnItems
   */
  export type ItemGrade$grnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    where?: GRNItemWhereInput
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    cursor?: GRNItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * ItemGrade.purchaseInvoiceItems
   */
  export type ItemGrade$purchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * ItemGrade.purchaseReturnItems
   */
  export type ItemGrade$purchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    where?: PurchaseReturnItemWhereInput
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    cursor?: PurchaseReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnItemScalarFieldEnum | PurchaseReturnItemScalarFieldEnum[]
  }

  /**
   * ItemGrade without action
   */
  export type ItemGradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
  }


  /**
   * Model PackingUnit
   */

  export type AggregatePackingUnit = {
    _count: PackingUnitCountAggregateOutputType | null
    _avg: PackingUnitAvgAggregateOutputType | null
    _sum: PackingUnitSumAggregateOutputType | null
    _min: PackingUnitMinAggregateOutputType | null
    _max: PackingUnitMaxAggregateOutputType | null
  }

  export type PackingUnitAvgAggregateOutputType = {
    companyId: number | null
  }

  export type PackingUnitSumAggregateOutputType = {
    companyId: number | null
  }

  export type PackingUnitMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    symbol: string | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackingUnitMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    symbol: string | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackingUnitCountAggregateOutputType = {
    id: number
    code: number
    name: number
    symbol: number
    status: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackingUnitAvgAggregateInputType = {
    companyId?: true
  }

  export type PackingUnitSumAggregateInputType = {
    companyId?: true
  }

  export type PackingUnitMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackingUnitMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackingUnitCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    symbol?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackingUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackingUnit to aggregate.
     */
    where?: PackingUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackingUnits to fetch.
     */
    orderBy?: PackingUnitOrderByWithRelationInput | PackingUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackingUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackingUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackingUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackingUnits
    **/
    _count?: true | PackingUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackingUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackingUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackingUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackingUnitMaxAggregateInputType
  }

  export type GetPackingUnitAggregateType<T extends PackingUnitAggregateArgs> = {
        [P in keyof T & keyof AggregatePackingUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackingUnit[P]>
      : GetScalarType<T[P], AggregatePackingUnit[P]>
  }




  export type PackingUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackingUnitWhereInput
    orderBy?: PackingUnitOrderByWithAggregationInput | PackingUnitOrderByWithAggregationInput[]
    by: PackingUnitScalarFieldEnum[] | PackingUnitScalarFieldEnum
    having?: PackingUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackingUnitCountAggregateInputType | true
    _avg?: PackingUnitAvgAggregateInputType
    _sum?: PackingUnitSumAggregateInputType
    _min?: PackingUnitMinAggregateInputType
    _max?: PackingUnitMaxAggregateInputType
  }

  export type PackingUnitGroupByOutputType = {
    id: string
    code: string
    name: string
    symbol: string | null
    status: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: PackingUnitCountAggregateOutputType | null
    _avg: PackingUnitAvgAggregateOutputType | null
    _sum: PackingUnitSumAggregateOutputType | null
    _min: PackingUnitMinAggregateOutputType | null
    _max: PackingUnitMaxAggregateOutputType | null
  }

  type GetPackingUnitGroupByPayload<T extends PackingUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackingUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackingUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackingUnitGroupByOutputType[P]>
            : GetScalarType<T[P], PackingUnitGroupByOutputType[P]>
        }
      >
    >


  export type PackingUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    itemMasters?: boolean | PackingUnit$itemMastersArgs<ExtArgs>
    purchaseOrderItems?: boolean | PackingUnit$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | PackingUnit$grnItemsArgs<ExtArgs>
    _count?: boolean | PackingUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packingUnit"]>

  export type PackingUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packingUnit"]>

  export type PackingUnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packingUnit"]>

  export type PackingUnitSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    symbol?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PackingUnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "symbol" | "status" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["packingUnit"]>
  export type PackingUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    itemMasters?: boolean | PackingUnit$itemMastersArgs<ExtArgs>
    purchaseOrderItems?: boolean | PackingUnit$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | PackingUnit$grnItemsArgs<ExtArgs>
    _count?: boolean | PackingUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PackingUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PackingUnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PackingUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackingUnit"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      itemMasters: Prisma.$ItemMasterPayload<ExtArgs>[]
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      grnItems: Prisma.$GRNItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      symbol: string | null
      status: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["packingUnit"]>
    composites: {}
  }

  type PackingUnitGetPayload<S extends boolean | null | undefined | PackingUnitDefaultArgs> = $Result.GetResult<Prisma.$PackingUnitPayload, S>

  type PackingUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackingUnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackingUnitCountAggregateInputType | true
    }

  export interface PackingUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackingUnit'], meta: { name: 'PackingUnit' } }
    /**
     * Find zero or one PackingUnit that matches the filter.
     * @param {PackingUnitFindUniqueArgs} args - Arguments to find a PackingUnit
     * @example
     * // Get one PackingUnit
     * const packingUnit = await prisma.packingUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackingUnitFindUniqueArgs>(args: SelectSubset<T, PackingUnitFindUniqueArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PackingUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackingUnitFindUniqueOrThrowArgs} args - Arguments to find a PackingUnit
     * @example
     * // Get one PackingUnit
     * const packingUnit = await prisma.packingUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackingUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, PackingUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackingUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackingUnitFindFirstArgs} args - Arguments to find a PackingUnit
     * @example
     * // Get one PackingUnit
     * const packingUnit = await prisma.packingUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackingUnitFindFirstArgs>(args?: SelectSubset<T, PackingUnitFindFirstArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PackingUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackingUnitFindFirstOrThrowArgs} args - Arguments to find a PackingUnit
     * @example
     * // Get one PackingUnit
     * const packingUnit = await prisma.packingUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackingUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, PackingUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PackingUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackingUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackingUnits
     * const packingUnits = await prisma.packingUnit.findMany()
     * 
     * // Get first 10 PackingUnits
     * const packingUnits = await prisma.packingUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packingUnitWithIdOnly = await prisma.packingUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackingUnitFindManyArgs>(args?: SelectSubset<T, PackingUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PackingUnit.
     * @param {PackingUnitCreateArgs} args - Arguments to create a PackingUnit.
     * @example
     * // Create one PackingUnit
     * const PackingUnit = await prisma.packingUnit.create({
     *   data: {
     *     // ... data to create a PackingUnit
     *   }
     * })
     * 
     */
    create<T extends PackingUnitCreateArgs>(args: SelectSubset<T, PackingUnitCreateArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PackingUnits.
     * @param {PackingUnitCreateManyArgs} args - Arguments to create many PackingUnits.
     * @example
     * // Create many PackingUnits
     * const packingUnit = await prisma.packingUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackingUnitCreateManyArgs>(args?: SelectSubset<T, PackingUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PackingUnits and returns the data saved in the database.
     * @param {PackingUnitCreateManyAndReturnArgs} args - Arguments to create many PackingUnits.
     * @example
     * // Create many PackingUnits
     * const packingUnit = await prisma.packingUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PackingUnits and only return the `id`
     * const packingUnitWithIdOnly = await prisma.packingUnit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackingUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, PackingUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PackingUnit.
     * @param {PackingUnitDeleteArgs} args - Arguments to delete one PackingUnit.
     * @example
     * // Delete one PackingUnit
     * const PackingUnit = await prisma.packingUnit.delete({
     *   where: {
     *     // ... filter to delete one PackingUnit
     *   }
     * })
     * 
     */
    delete<T extends PackingUnitDeleteArgs>(args: SelectSubset<T, PackingUnitDeleteArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PackingUnit.
     * @param {PackingUnitUpdateArgs} args - Arguments to update one PackingUnit.
     * @example
     * // Update one PackingUnit
     * const packingUnit = await prisma.packingUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackingUnitUpdateArgs>(args: SelectSubset<T, PackingUnitUpdateArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PackingUnits.
     * @param {PackingUnitDeleteManyArgs} args - Arguments to filter PackingUnits to delete.
     * @example
     * // Delete a few PackingUnits
     * const { count } = await prisma.packingUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackingUnitDeleteManyArgs>(args?: SelectSubset<T, PackingUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackingUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackingUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackingUnits
     * const packingUnit = await prisma.packingUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackingUnitUpdateManyArgs>(args: SelectSubset<T, PackingUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackingUnits and returns the data updated in the database.
     * @param {PackingUnitUpdateManyAndReturnArgs} args - Arguments to update many PackingUnits.
     * @example
     * // Update many PackingUnits
     * const packingUnit = await prisma.packingUnit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PackingUnits and only return the `id`
     * const packingUnitWithIdOnly = await prisma.packingUnit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackingUnitUpdateManyAndReturnArgs>(args: SelectSubset<T, PackingUnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PackingUnit.
     * @param {PackingUnitUpsertArgs} args - Arguments to update or create a PackingUnit.
     * @example
     * // Update or create a PackingUnit
     * const packingUnit = await prisma.packingUnit.upsert({
     *   create: {
     *     // ... data to create a PackingUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackingUnit we want to update
     *   }
     * })
     */
    upsert<T extends PackingUnitUpsertArgs>(args: SelectSubset<T, PackingUnitUpsertArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PackingUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackingUnitCountArgs} args - Arguments to filter PackingUnits to count.
     * @example
     * // Count the number of PackingUnits
     * const count = await prisma.packingUnit.count({
     *   where: {
     *     // ... the filter for the PackingUnits we want to count
     *   }
     * })
    **/
    count<T extends PackingUnitCountArgs>(
      args?: Subset<T, PackingUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackingUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackingUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackingUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackingUnitAggregateArgs>(args: Subset<T, PackingUnitAggregateArgs>): Prisma.PrismaPromise<GetPackingUnitAggregateType<T>>

    /**
     * Group by PackingUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackingUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackingUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackingUnitGroupByArgs['orderBy'] }
        : { orderBy?: PackingUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackingUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackingUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackingUnit model
   */
  readonly fields: PackingUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackingUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackingUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    itemMasters<T extends PackingUnit$itemMastersArgs<ExtArgs> = {}>(args?: Subset<T, PackingUnit$itemMastersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseOrderItems<T extends PackingUnit$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, PackingUnit$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grnItems<T extends PackingUnit$grnItemsArgs<ExtArgs> = {}>(args?: Subset<T, PackingUnit$grnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackingUnit model
   */
  interface PackingUnitFieldRefs {
    readonly id: FieldRef<"PackingUnit", 'String'>
    readonly code: FieldRef<"PackingUnit", 'String'>
    readonly name: FieldRef<"PackingUnit", 'String'>
    readonly symbol: FieldRef<"PackingUnit", 'String'>
    readonly status: FieldRef<"PackingUnit", 'String'>
    readonly companyId: FieldRef<"PackingUnit", 'Int'>
    readonly createdAt: FieldRef<"PackingUnit", 'DateTime'>
    readonly updatedAt: FieldRef<"PackingUnit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PackingUnit findUnique
   */
  export type PackingUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    /**
     * Filter, which PackingUnit to fetch.
     */
    where: PackingUnitWhereUniqueInput
  }

  /**
   * PackingUnit findUniqueOrThrow
   */
  export type PackingUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    /**
     * Filter, which PackingUnit to fetch.
     */
    where: PackingUnitWhereUniqueInput
  }

  /**
   * PackingUnit findFirst
   */
  export type PackingUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    /**
     * Filter, which PackingUnit to fetch.
     */
    where?: PackingUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackingUnits to fetch.
     */
    orderBy?: PackingUnitOrderByWithRelationInput | PackingUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackingUnits.
     */
    cursor?: PackingUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackingUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackingUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackingUnits.
     */
    distinct?: PackingUnitScalarFieldEnum | PackingUnitScalarFieldEnum[]
  }

  /**
   * PackingUnit findFirstOrThrow
   */
  export type PackingUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    /**
     * Filter, which PackingUnit to fetch.
     */
    where?: PackingUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackingUnits to fetch.
     */
    orderBy?: PackingUnitOrderByWithRelationInput | PackingUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackingUnits.
     */
    cursor?: PackingUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackingUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackingUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackingUnits.
     */
    distinct?: PackingUnitScalarFieldEnum | PackingUnitScalarFieldEnum[]
  }

  /**
   * PackingUnit findMany
   */
  export type PackingUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    /**
     * Filter, which PackingUnits to fetch.
     */
    where?: PackingUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackingUnits to fetch.
     */
    orderBy?: PackingUnitOrderByWithRelationInput | PackingUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackingUnits.
     */
    cursor?: PackingUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackingUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackingUnits.
     */
    skip?: number
    distinct?: PackingUnitScalarFieldEnum | PackingUnitScalarFieldEnum[]
  }

  /**
   * PackingUnit create
   */
  export type PackingUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a PackingUnit.
     */
    data: XOR<PackingUnitCreateInput, PackingUnitUncheckedCreateInput>
  }

  /**
   * PackingUnit createMany
   */
  export type PackingUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackingUnits.
     */
    data: PackingUnitCreateManyInput | PackingUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackingUnit createManyAndReturn
   */
  export type PackingUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * The data used to create many PackingUnits.
     */
    data: PackingUnitCreateManyInput | PackingUnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackingUnit update
   */
  export type PackingUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a PackingUnit.
     */
    data: XOR<PackingUnitUpdateInput, PackingUnitUncheckedUpdateInput>
    /**
     * Choose, which PackingUnit to update.
     */
    where: PackingUnitWhereUniqueInput
  }

  /**
   * PackingUnit updateMany
   */
  export type PackingUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackingUnits.
     */
    data: XOR<PackingUnitUpdateManyMutationInput, PackingUnitUncheckedUpdateManyInput>
    /**
     * Filter which PackingUnits to update
     */
    where?: PackingUnitWhereInput
    /**
     * Limit how many PackingUnits to update.
     */
    limit?: number
  }

  /**
   * PackingUnit updateManyAndReturn
   */
  export type PackingUnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * The data used to update PackingUnits.
     */
    data: XOR<PackingUnitUpdateManyMutationInput, PackingUnitUncheckedUpdateManyInput>
    /**
     * Filter which PackingUnits to update
     */
    where?: PackingUnitWhereInput
    /**
     * Limit how many PackingUnits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PackingUnit upsert
   */
  export type PackingUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the PackingUnit to update in case it exists.
     */
    where: PackingUnitWhereUniqueInput
    /**
     * In case the PackingUnit found by the `where` argument doesn't exist, create a new PackingUnit with this data.
     */
    create: XOR<PackingUnitCreateInput, PackingUnitUncheckedCreateInput>
    /**
     * In case the PackingUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackingUnitUpdateInput, PackingUnitUncheckedUpdateInput>
  }

  /**
   * PackingUnit delete
   */
  export type PackingUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    /**
     * Filter which PackingUnit to delete.
     */
    where: PackingUnitWhereUniqueInput
  }

  /**
   * PackingUnit deleteMany
   */
  export type PackingUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackingUnits to delete
     */
    where?: PackingUnitWhereInput
    /**
     * Limit how many PackingUnits to delete.
     */
    limit?: number
  }

  /**
   * PackingUnit.itemMasters
   */
  export type PackingUnit$itemMastersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    where?: ItemMasterWhereInput
    orderBy?: ItemMasterOrderByWithRelationInput | ItemMasterOrderByWithRelationInput[]
    cursor?: ItemMasterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemMasterScalarFieldEnum | ItemMasterScalarFieldEnum[]
  }

  /**
   * PackingUnit.purchaseOrderItems
   */
  export type PackingUnit$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PackingUnit.grnItems
   */
  export type PackingUnit$grnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    where?: GRNItemWhereInput
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    cursor?: GRNItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * PackingUnit without action
   */
  export type PackingUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
  }


  /**
   * Model ItemMaster
   */

  export type AggregateItemMaster = {
    _count: ItemMasterCountAggregateOutputType | null
    _avg: ItemMasterAvgAggregateOutputType | null
    _sum: ItemMasterSumAggregateOutputType | null
    _min: ItemMasterMinAggregateOutputType | null
    _max: ItemMasterMaxAggregateOutputType | null
  }

  export type ItemMasterAvgAggregateOutputType = {
    baseUnitId: number | null
    companyId: number | null
  }

  export type ItemMasterSumAggregateOutputType = {
    baseUnitId: number | null
    companyId: number | null
  }

  export type ItemMasterMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    shortDescription: string | null
    status: string | null
    hsCode: string | null
    imageUrl: string | null
    itemGroupId: string | null
    baseUnitId: number | null
    packingUnitId: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMasterMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    shortDescription: string | null
    status: string | null
    hsCode: string | null
    imageUrl: string | null
    itemGroupId: string | null
    baseUnitId: number | null
    packingUnitId: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMasterCountAggregateOutputType = {
    id: number
    code: number
    name: number
    shortDescription: number
    status: number
    hsCode: number
    imageUrl: number
    itemGroupId: number
    baseUnitId: number
    packingUnitId: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemMasterAvgAggregateInputType = {
    baseUnitId?: true
    companyId?: true
  }

  export type ItemMasterSumAggregateInputType = {
    baseUnitId?: true
    companyId?: true
  }

  export type ItemMasterMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    shortDescription?: true
    status?: true
    hsCode?: true
    imageUrl?: true
    itemGroupId?: true
    baseUnitId?: true
    packingUnitId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMasterMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    shortDescription?: true
    status?: true
    hsCode?: true
    imageUrl?: true
    itemGroupId?: true
    baseUnitId?: true
    packingUnitId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMasterCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    shortDescription?: true
    status?: true
    hsCode?: true
    imageUrl?: true
    itemGroupId?: true
    baseUnitId?: true
    packingUnitId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemMasterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemMaster to aggregate.
     */
    where?: ItemMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMasters to fetch.
     */
    orderBy?: ItemMasterOrderByWithRelationInput | ItemMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemMasters
    **/
    _count?: true | ItemMasterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemMasterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemMasterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMasterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMasterMaxAggregateInputType
  }

  export type GetItemMasterAggregateType<T extends ItemMasterAggregateArgs> = {
        [P in keyof T & keyof AggregateItemMaster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemMaster[P]>
      : GetScalarType<T[P], AggregateItemMaster[P]>
  }




  export type ItemMasterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemMasterWhereInput
    orderBy?: ItemMasterOrderByWithAggregationInput | ItemMasterOrderByWithAggregationInput[]
    by: ItemMasterScalarFieldEnum[] | ItemMasterScalarFieldEnum
    having?: ItemMasterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemMasterCountAggregateInputType | true
    _avg?: ItemMasterAvgAggregateInputType
    _sum?: ItemMasterSumAggregateInputType
    _min?: ItemMasterMinAggregateInputType
    _max?: ItemMasterMaxAggregateInputType
  }

  export type ItemMasterGroupByOutputType = {
    id: string
    code: string
    name: string
    shortDescription: string | null
    status: string
    hsCode: string | null
    imageUrl: string | null
    itemGroupId: string
    baseUnitId: number
    packingUnitId: string | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: ItemMasterCountAggregateOutputType | null
    _avg: ItemMasterAvgAggregateOutputType | null
    _sum: ItemMasterSumAggregateOutputType | null
    _min: ItemMasterMinAggregateOutputType | null
    _max: ItemMasterMaxAggregateOutputType | null
  }

  type GetItemMasterGroupByPayload<T extends ItemMasterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemMasterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemMasterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemMasterGroupByOutputType[P]>
            : GetScalarType<T[P], ItemMasterGroupByOutputType[P]>
        }
      >
    >


  export type ItemMasterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    shortDescription?: boolean
    status?: boolean
    hsCode?: boolean
    imageUrl?: boolean
    itemGroupId?: boolean
    baseUnitId?: boolean
    packingUnitId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itemGroup?: boolean | ItemGroupDefaultArgs<ExtArgs>
    baseUnit?: boolean | UnitDefaultArgs<ExtArgs>
    packingUnit?: boolean | ItemMaster$packingUnitArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | ItemMaster$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | ItemMaster$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | ItemMaster$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | ItemMaster$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | ItemMasterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemMaster"]>

  export type ItemMasterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    shortDescription?: boolean
    status?: boolean
    hsCode?: boolean
    imageUrl?: boolean
    itemGroupId?: boolean
    baseUnitId?: boolean
    packingUnitId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itemGroup?: boolean | ItemGroupDefaultArgs<ExtArgs>
    baseUnit?: boolean | UnitDefaultArgs<ExtArgs>
    packingUnit?: boolean | ItemMaster$packingUnitArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemMaster"]>

  export type ItemMasterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    shortDescription?: boolean
    status?: boolean
    hsCode?: boolean
    imageUrl?: boolean
    itemGroupId?: boolean
    baseUnitId?: boolean
    packingUnitId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itemGroup?: boolean | ItemGroupDefaultArgs<ExtArgs>
    baseUnit?: boolean | UnitDefaultArgs<ExtArgs>
    packingUnit?: boolean | ItemMaster$packingUnitArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemMaster"]>

  export type ItemMasterSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    shortDescription?: boolean
    status?: boolean
    hsCode?: boolean
    imageUrl?: boolean
    itemGroupId?: boolean
    baseUnitId?: boolean
    packingUnitId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemMasterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "shortDescription" | "status" | "hsCode" | "imageUrl" | "itemGroupId" | "baseUnitId" | "packingUnitId" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["itemMaster"]>
  export type ItemMasterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemGroup?: boolean | ItemGroupDefaultArgs<ExtArgs>
    baseUnit?: boolean | UnitDefaultArgs<ExtArgs>
    packingUnit?: boolean | ItemMaster$packingUnitArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    purchaseOrderItems?: boolean | ItemMaster$purchaseOrderItemsArgs<ExtArgs>
    grnItems?: boolean | ItemMaster$grnItemsArgs<ExtArgs>
    purchaseInvoiceItems?: boolean | ItemMaster$purchaseInvoiceItemsArgs<ExtArgs>
    purchaseReturnItems?: boolean | ItemMaster$purchaseReturnItemsArgs<ExtArgs>
    _count?: boolean | ItemMasterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemMasterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemGroup?: boolean | ItemGroupDefaultArgs<ExtArgs>
    baseUnit?: boolean | UnitDefaultArgs<ExtArgs>
    packingUnit?: boolean | ItemMaster$packingUnitArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ItemMasterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemGroup?: boolean | ItemGroupDefaultArgs<ExtArgs>
    baseUnit?: boolean | UnitDefaultArgs<ExtArgs>
    packingUnit?: boolean | ItemMaster$packingUnitArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ItemMasterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemMaster"
    objects: {
      itemGroup: Prisma.$ItemGroupPayload<ExtArgs>
      baseUnit: Prisma.$UnitPayload<ExtArgs>
      packingUnit: Prisma.$PackingUnitPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      purchaseOrderItems: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      grnItems: Prisma.$GRNItemPayload<ExtArgs>[]
      purchaseInvoiceItems: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
      purchaseReturnItems: Prisma.$PurchaseReturnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      shortDescription: string | null
      status: string
      hsCode: string | null
      imageUrl: string | null
      itemGroupId: string
      baseUnitId: number
      packingUnitId: string | null
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemMaster"]>
    composites: {}
  }

  type ItemMasterGetPayload<S extends boolean | null | undefined | ItemMasterDefaultArgs> = $Result.GetResult<Prisma.$ItemMasterPayload, S>

  type ItemMasterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemMasterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemMasterCountAggregateInputType | true
    }

  export interface ItemMasterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemMaster'], meta: { name: 'ItemMaster' } }
    /**
     * Find zero or one ItemMaster that matches the filter.
     * @param {ItemMasterFindUniqueArgs} args - Arguments to find a ItemMaster
     * @example
     * // Get one ItemMaster
     * const itemMaster = await prisma.itemMaster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemMasterFindUniqueArgs>(args: SelectSubset<T, ItemMasterFindUniqueArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemMaster that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemMasterFindUniqueOrThrowArgs} args - Arguments to find a ItemMaster
     * @example
     * // Get one ItemMaster
     * const itemMaster = await prisma.itemMaster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemMasterFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemMasterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemMaster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMasterFindFirstArgs} args - Arguments to find a ItemMaster
     * @example
     * // Get one ItemMaster
     * const itemMaster = await prisma.itemMaster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemMasterFindFirstArgs>(args?: SelectSubset<T, ItemMasterFindFirstArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemMaster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMasterFindFirstOrThrowArgs} args - Arguments to find a ItemMaster
     * @example
     * // Get one ItemMaster
     * const itemMaster = await prisma.itemMaster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemMasterFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemMasterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemMasters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMasterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemMasters
     * const itemMasters = await prisma.itemMaster.findMany()
     * 
     * // Get first 10 ItemMasters
     * const itemMasters = await prisma.itemMaster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemMasterWithIdOnly = await prisma.itemMaster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemMasterFindManyArgs>(args?: SelectSubset<T, ItemMasterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemMaster.
     * @param {ItemMasterCreateArgs} args - Arguments to create a ItemMaster.
     * @example
     * // Create one ItemMaster
     * const ItemMaster = await prisma.itemMaster.create({
     *   data: {
     *     // ... data to create a ItemMaster
     *   }
     * })
     * 
     */
    create<T extends ItemMasterCreateArgs>(args: SelectSubset<T, ItemMasterCreateArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemMasters.
     * @param {ItemMasterCreateManyArgs} args - Arguments to create many ItemMasters.
     * @example
     * // Create many ItemMasters
     * const itemMaster = await prisma.itemMaster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemMasterCreateManyArgs>(args?: SelectSubset<T, ItemMasterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemMasters and returns the data saved in the database.
     * @param {ItemMasterCreateManyAndReturnArgs} args - Arguments to create many ItemMasters.
     * @example
     * // Create many ItemMasters
     * const itemMaster = await prisma.itemMaster.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemMasters and only return the `id`
     * const itemMasterWithIdOnly = await prisma.itemMaster.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemMasterCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemMasterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemMaster.
     * @param {ItemMasterDeleteArgs} args - Arguments to delete one ItemMaster.
     * @example
     * // Delete one ItemMaster
     * const ItemMaster = await prisma.itemMaster.delete({
     *   where: {
     *     // ... filter to delete one ItemMaster
     *   }
     * })
     * 
     */
    delete<T extends ItemMasterDeleteArgs>(args: SelectSubset<T, ItemMasterDeleteArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemMaster.
     * @param {ItemMasterUpdateArgs} args - Arguments to update one ItemMaster.
     * @example
     * // Update one ItemMaster
     * const itemMaster = await prisma.itemMaster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemMasterUpdateArgs>(args: SelectSubset<T, ItemMasterUpdateArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemMasters.
     * @param {ItemMasterDeleteManyArgs} args - Arguments to filter ItemMasters to delete.
     * @example
     * // Delete a few ItemMasters
     * const { count } = await prisma.itemMaster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemMasterDeleteManyArgs>(args?: SelectSubset<T, ItemMasterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMasterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemMasters
     * const itemMaster = await prisma.itemMaster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemMasterUpdateManyArgs>(args: SelectSubset<T, ItemMasterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemMasters and returns the data updated in the database.
     * @param {ItemMasterUpdateManyAndReturnArgs} args - Arguments to update many ItemMasters.
     * @example
     * // Update many ItemMasters
     * const itemMaster = await prisma.itemMaster.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemMasters and only return the `id`
     * const itemMasterWithIdOnly = await prisma.itemMaster.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemMasterUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemMasterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemMaster.
     * @param {ItemMasterUpsertArgs} args - Arguments to update or create a ItemMaster.
     * @example
     * // Update or create a ItemMaster
     * const itemMaster = await prisma.itemMaster.upsert({
     *   create: {
     *     // ... data to create a ItemMaster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemMaster we want to update
     *   }
     * })
     */
    upsert<T extends ItemMasterUpsertArgs>(args: SelectSubset<T, ItemMasterUpsertArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemMasters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMasterCountArgs} args - Arguments to filter ItemMasters to count.
     * @example
     * // Count the number of ItemMasters
     * const count = await prisma.itemMaster.count({
     *   where: {
     *     // ... the filter for the ItemMasters we want to count
     *   }
     * })
    **/
    count<T extends ItemMasterCountArgs>(
      args?: Subset<T, ItemMasterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemMasterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMasterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemMasterAggregateArgs>(args: Subset<T, ItemMasterAggregateArgs>): Prisma.PrismaPromise<GetItemMasterAggregateType<T>>

    /**
     * Group by ItemMaster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemMasterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemMasterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemMasterGroupByArgs['orderBy'] }
        : { orderBy?: ItemMasterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemMasterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemMasterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemMaster model
   */
  readonly fields: ItemMasterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemMaster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemMasterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemGroup<T extends ItemGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemGroupDefaultArgs<ExtArgs>>): Prisma__ItemGroupClient<$Result.GetResult<Prisma.$ItemGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    baseUnit<T extends UnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitDefaultArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    packingUnit<T extends ItemMaster$packingUnitArgs<ExtArgs> = {}>(args?: Subset<T, ItemMaster$packingUnitArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrderItems<T extends ItemMaster$purchaseOrderItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemMaster$purchaseOrderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grnItems<T extends ItemMaster$grnItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemMaster$grnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseInvoiceItems<T extends ItemMaster$purchaseInvoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemMaster$purchaseInvoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturnItems<T extends ItemMaster$purchaseReturnItemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemMaster$purchaseReturnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemMaster model
   */
  interface ItemMasterFieldRefs {
    readonly id: FieldRef<"ItemMaster", 'String'>
    readonly code: FieldRef<"ItemMaster", 'String'>
    readonly name: FieldRef<"ItemMaster", 'String'>
    readonly shortDescription: FieldRef<"ItemMaster", 'String'>
    readonly status: FieldRef<"ItemMaster", 'String'>
    readonly hsCode: FieldRef<"ItemMaster", 'String'>
    readonly imageUrl: FieldRef<"ItemMaster", 'String'>
    readonly itemGroupId: FieldRef<"ItemMaster", 'String'>
    readonly baseUnitId: FieldRef<"ItemMaster", 'Int'>
    readonly packingUnitId: FieldRef<"ItemMaster", 'String'>
    readonly companyId: FieldRef<"ItemMaster", 'Int'>
    readonly createdAt: FieldRef<"ItemMaster", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemMaster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemMaster findUnique
   */
  export type ItemMasterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    /**
     * Filter, which ItemMaster to fetch.
     */
    where: ItemMasterWhereUniqueInput
  }

  /**
   * ItemMaster findUniqueOrThrow
   */
  export type ItemMasterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    /**
     * Filter, which ItemMaster to fetch.
     */
    where: ItemMasterWhereUniqueInput
  }

  /**
   * ItemMaster findFirst
   */
  export type ItemMasterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    /**
     * Filter, which ItemMaster to fetch.
     */
    where?: ItemMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMasters to fetch.
     */
    orderBy?: ItemMasterOrderByWithRelationInput | ItemMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemMasters.
     */
    cursor?: ItemMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemMasters.
     */
    distinct?: ItemMasterScalarFieldEnum | ItemMasterScalarFieldEnum[]
  }

  /**
   * ItemMaster findFirstOrThrow
   */
  export type ItemMasterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    /**
     * Filter, which ItemMaster to fetch.
     */
    where?: ItemMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMasters to fetch.
     */
    orderBy?: ItemMasterOrderByWithRelationInput | ItemMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemMasters.
     */
    cursor?: ItemMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMasters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemMasters.
     */
    distinct?: ItemMasterScalarFieldEnum | ItemMasterScalarFieldEnum[]
  }

  /**
   * ItemMaster findMany
   */
  export type ItemMasterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    /**
     * Filter, which ItemMasters to fetch.
     */
    where?: ItemMasterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemMasters to fetch.
     */
    orderBy?: ItemMasterOrderByWithRelationInput | ItemMasterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemMasters.
     */
    cursor?: ItemMasterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemMasters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemMasters.
     */
    skip?: number
    distinct?: ItemMasterScalarFieldEnum | ItemMasterScalarFieldEnum[]
  }

  /**
   * ItemMaster create
   */
  export type ItemMasterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemMaster.
     */
    data: XOR<ItemMasterCreateInput, ItemMasterUncheckedCreateInput>
  }

  /**
   * ItemMaster createMany
   */
  export type ItemMasterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemMasters.
     */
    data: ItemMasterCreateManyInput | ItemMasterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemMaster createManyAndReturn
   */
  export type ItemMasterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * The data used to create many ItemMasters.
     */
    data: ItemMasterCreateManyInput | ItemMasterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemMaster update
   */
  export type ItemMasterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemMaster.
     */
    data: XOR<ItemMasterUpdateInput, ItemMasterUncheckedUpdateInput>
    /**
     * Choose, which ItemMaster to update.
     */
    where: ItemMasterWhereUniqueInput
  }

  /**
   * ItemMaster updateMany
   */
  export type ItemMasterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemMasters.
     */
    data: XOR<ItemMasterUpdateManyMutationInput, ItemMasterUncheckedUpdateManyInput>
    /**
     * Filter which ItemMasters to update
     */
    where?: ItemMasterWhereInput
    /**
     * Limit how many ItemMasters to update.
     */
    limit?: number
  }

  /**
   * ItemMaster updateManyAndReturn
   */
  export type ItemMasterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * The data used to update ItemMasters.
     */
    data: XOR<ItemMasterUpdateManyMutationInput, ItemMasterUncheckedUpdateManyInput>
    /**
     * Filter which ItemMasters to update
     */
    where?: ItemMasterWhereInput
    /**
     * Limit how many ItemMasters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemMaster upsert
   */
  export type ItemMasterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemMaster to update in case it exists.
     */
    where: ItemMasterWhereUniqueInput
    /**
     * In case the ItemMaster found by the `where` argument doesn't exist, create a new ItemMaster with this data.
     */
    create: XOR<ItemMasterCreateInput, ItemMasterUncheckedCreateInput>
    /**
     * In case the ItemMaster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemMasterUpdateInput, ItemMasterUncheckedUpdateInput>
  }

  /**
   * ItemMaster delete
   */
  export type ItemMasterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    /**
     * Filter which ItemMaster to delete.
     */
    where: ItemMasterWhereUniqueInput
  }

  /**
   * ItemMaster deleteMany
   */
  export type ItemMasterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemMasters to delete
     */
    where?: ItemMasterWhereInput
    /**
     * Limit how many ItemMasters to delete.
     */
    limit?: number
  }

  /**
   * ItemMaster.packingUnit
   */
  export type ItemMaster$packingUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    where?: PackingUnitWhereInput
  }

  /**
   * ItemMaster.purchaseOrderItems
   */
  export type ItemMaster$purchaseOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * ItemMaster.grnItems
   */
  export type ItemMaster$grnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    where?: GRNItemWhereInput
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    cursor?: GRNItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * ItemMaster.purchaseInvoiceItems
   */
  export type ItemMaster$purchaseInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * ItemMaster.purchaseReturnItems
   */
  export type ItemMaster$purchaseReturnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    where?: PurchaseReturnItemWhereInput
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    cursor?: PurchaseReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnItemScalarFieldEnum | PurchaseReturnItemScalarFieldEnum[]
  }

  /**
   * ItemMaster without action
   */
  export type ItemMasterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    accountId: number | null
    warehouseId: number | null
    totalAmount: number | null
    currencyId: number | null
    exchangeRate: number | null
    companyId: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    accountId: number | null
    warehouseId: number | null
    totalAmount: number | null
    currencyId: number | null
    exchangeRate: number | null
    companyId: number | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    poNumber: string | null
    type: $Enums.PurchaseOrderType | null
    status: $Enums.PurchaseOrderStatus | null
    date: Date | null
    accountId: number | null
    partyName: string | null
    warehouseId: number | null
    referenceNo: string | null
    documentDate: Date | null
    fileNo: string | null
    remarks: string | null
    totalAmount: number | null
    currencyId: number | null
    exchangeRate: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    poNumber: string | null
    type: $Enums.PurchaseOrderType | null
    status: $Enums.PurchaseOrderStatus | null
    date: Date | null
    accountId: number | null
    partyName: string | null
    warehouseId: number | null
    referenceNo: string | null
    documentDate: Date | null
    fileNo: string | null
    remarks: string | null
    totalAmount: number | null
    currencyId: number | null
    exchangeRate: number | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    poNumber: number
    type: number
    status: number
    date: number
    accountId: number
    partyName: number
    warehouseId: number
    referenceNo: number
    documentDate: number
    fileNo: number
    remarks: number
    totalAmount: number
    currencyId: number
    exchangeRate: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    accountId?: true
    warehouseId?: true
    totalAmount?: true
    currencyId?: true
    exchangeRate?: true
    companyId?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    accountId?: true
    warehouseId?: true
    totalAmount?: true
    currencyId?: true
    exchangeRate?: true
    companyId?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    poNumber?: true
    type?: true
    status?: true
    date?: true
    accountId?: true
    partyName?: true
    warehouseId?: true
    referenceNo?: true
    documentDate?: true
    fileNo?: true
    remarks?: true
    totalAmount?: true
    currencyId?: true
    exchangeRate?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    poNumber?: true
    type?: true
    status?: true
    date?: true
    accountId?: true
    partyName?: true
    warehouseId?: true
    referenceNo?: true
    documentDate?: true
    fileNo?: true
    remarks?: true
    totalAmount?: true
    currencyId?: true
    exchangeRate?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    poNumber?: true
    type?: true
    status?: true
    date?: true
    accountId?: true
    partyName?: true
    warehouseId?: true
    referenceNo?: true
    documentDate?: true
    fileNo?: true
    remarks?: true
    totalAmount?: true
    currencyId?: true
    exchangeRate?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status: $Enums.PurchaseOrderStatus
    date: Date
    accountId: number | null
    partyName: string | null
    warehouseId: number | null
    referenceNo: string | null
    documentDate: Date | null
    fileNo: string | null
    remarks: string | null
    totalAmount: number
    currencyId: number | null
    exchangeRate: number
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poNumber?: boolean
    type?: boolean
    status?: boolean
    date?: boolean
    accountId?: boolean
    partyName?: boolean
    warehouseId?: boolean
    referenceNo?: boolean
    documentDate?: boolean
    fileNo?: boolean
    remarks?: boolean
    totalAmount?: boolean
    currencyId?: boolean
    exchangeRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | PurchaseOrder$accountArgs<ExtArgs>
    warehouse?: boolean | PurchaseOrder$warehouseArgs<ExtArgs>
    currency?: boolean | PurchaseOrder$currencyArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    grns?: boolean | PurchaseOrder$grnsArgs<ExtArgs>
    invoices?: boolean | PurchaseOrder$invoicesArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poNumber?: boolean
    type?: boolean
    status?: boolean
    date?: boolean
    accountId?: boolean
    partyName?: boolean
    warehouseId?: boolean
    referenceNo?: boolean
    documentDate?: boolean
    fileNo?: boolean
    remarks?: boolean
    totalAmount?: boolean
    currencyId?: boolean
    exchangeRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | PurchaseOrder$accountArgs<ExtArgs>
    warehouse?: boolean | PurchaseOrder$warehouseArgs<ExtArgs>
    currency?: boolean | PurchaseOrder$currencyArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    poNumber?: boolean
    type?: boolean
    status?: boolean
    date?: boolean
    accountId?: boolean
    partyName?: boolean
    warehouseId?: boolean
    referenceNo?: boolean
    documentDate?: boolean
    fileNo?: boolean
    remarks?: boolean
    totalAmount?: boolean
    currencyId?: boolean
    exchangeRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | PurchaseOrder$accountArgs<ExtArgs>
    warehouse?: boolean | PurchaseOrder$warehouseArgs<ExtArgs>
    currency?: boolean | PurchaseOrder$currencyArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    poNumber?: boolean
    type?: boolean
    status?: boolean
    date?: boolean
    accountId?: boolean
    partyName?: boolean
    warehouseId?: boolean
    referenceNo?: boolean
    documentDate?: boolean
    fileNo?: boolean
    remarks?: boolean
    totalAmount?: boolean
    currencyId?: boolean
    exchangeRate?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "poNumber" | "type" | "status" | "date" | "accountId" | "partyName" | "warehouseId" | "referenceNo" | "documentDate" | "fileNo" | "remarks" | "totalAmount" | "currencyId" | "exchangeRate" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | PurchaseOrder$accountArgs<ExtArgs>
    warehouse?: boolean | PurchaseOrder$warehouseArgs<ExtArgs>
    currency?: boolean | PurchaseOrder$currencyArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    grns?: boolean | PurchaseOrder$grnsArgs<ExtArgs>
    invoices?: boolean | PurchaseOrder$invoicesArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | PurchaseOrder$accountArgs<ExtArgs>
    warehouse?: boolean | PurchaseOrder$warehouseArgs<ExtArgs>
    currency?: boolean | PurchaseOrder$currencyArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | PurchaseOrder$accountArgs<ExtArgs>
    warehouse?: boolean | PurchaseOrder$warehouseArgs<ExtArgs>
    currency?: boolean | PurchaseOrder$currencyArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs> | null
      warehouse: Prisma.$WarehousePayload<ExtArgs> | null
      currency: Prisma.$CurrencyPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      items: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
      grns: Prisma.$GRNPayload<ExtArgs>[]
      invoices: Prisma.$PurchaseInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      poNumber: string
      type: $Enums.PurchaseOrderType
      status: $Enums.PurchaseOrderStatus
      date: Date
      accountId: number | null
      partyName: string | null
      warehouseId: number | null
      referenceNo: string | null
      documentDate: Date | null
      fileNo: string | null
      remarks: string | null
      totalAmount: number
      currencyId: number | null
      exchangeRate: number
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends PurchaseOrder$accountArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    warehouse<T extends PurchaseOrder$warehouseArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$warehouseArgs<ExtArgs>>): Prisma__WarehouseClient<$Result.GetResult<Prisma.$WarehousePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    currency<T extends PurchaseOrder$currencyArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$currencyArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grns<T extends PurchaseOrder$grnsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$grnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends PurchaseOrder$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly poNumber: FieldRef<"PurchaseOrder", 'String'>
    readonly type: FieldRef<"PurchaseOrder", 'PurchaseOrderType'>
    readonly status: FieldRef<"PurchaseOrder", 'PurchaseOrderStatus'>
    readonly date: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly accountId: FieldRef<"PurchaseOrder", 'Int'>
    readonly partyName: FieldRef<"PurchaseOrder", 'String'>
    readonly warehouseId: FieldRef<"PurchaseOrder", 'Int'>
    readonly referenceNo: FieldRef<"PurchaseOrder", 'String'>
    readonly documentDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly fileNo: FieldRef<"PurchaseOrder", 'String'>
    readonly remarks: FieldRef<"PurchaseOrder", 'String'>
    readonly totalAmount: FieldRef<"PurchaseOrder", 'Float'>
    readonly currencyId: FieldRef<"PurchaseOrder", 'Int'>
    readonly exchangeRate: FieldRef<"PurchaseOrder", 'Float'>
    readonly companyId: FieldRef<"PurchaseOrder", 'Int'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.account
   */
  export type PurchaseOrder$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * PurchaseOrder.warehouse
   */
  export type PurchaseOrder$warehouseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouse
     */
    select?: WarehouseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Warehouse
     */
    omit?: WarehouseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WarehouseInclude<ExtArgs> | null
    where?: WarehouseWhereInput
  }

  /**
   * PurchaseOrder.currency
   */
  export type PurchaseOrder$currencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
  }

  /**
   * PurchaseOrder.items
   */
  export type PurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.grns
   */
  export type PurchaseOrder$grnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    where?: GRNWhereInput
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    cursor?: GRNWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.invoices
   */
  export type PurchaseOrder$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderItem
   */

  export type AggregatePurchaseOrderItem = {
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  export type PurchaseOrderItemAvgAggregateOutputType = {
    pcs: number | null
    unitSize: number | null
    quantity: number | null
    unitId: number | null
    rate: number | null
    amount: number | null
  }

  export type PurchaseOrderItemSumAggregateOutputType = {
    pcs: number | null
    unitSize: number | null
    quantity: number | null
    unitId: number | null
    rate: number | null
    amount: number | null
  }

  export type PurchaseOrderItemMinAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    itemMasterId: string | null
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    packingUnitId: string | null
    packingType: $Enums.PackingType | null
    pcs: number | null
    unitSize: number | null
    quantity: number | null
    unitId: number | null
    rate: number | null
    amount: number | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderItemMaxAggregateOutputType = {
    id: string | null
    purchaseOrderId: string | null
    itemMasterId: string | null
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    packingUnitId: string | null
    packingType: $Enums.PackingType | null
    pcs: number | null
    unitSize: number | null
    quantity: number | null
    unitId: number | null
    rate: number | null
    amount: number | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderItemCountAggregateOutputType = {
    id: number
    purchaseOrderId: number
    itemMasterId: number
    colorId: number
    brandId: number
    itemGradeId: number
    packingUnitId: number
    packingType: number
    pcs: number
    unitSize: number
    quantity: number
    unitId: number
    rate: number
    amount: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderItemAvgAggregateInputType = {
    pcs?: true
    unitSize?: true
    quantity?: true
    unitId?: true
    rate?: true
    amount?: true
  }

  export type PurchaseOrderItemSumAggregateInputType = {
    pcs?: true
    unitSize?: true
    quantity?: true
    unitId?: true
    rate?: true
    amount?: true
  }

  export type PurchaseOrderItemMinAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    packingUnitId?: true
    packingType?: true
    pcs?: true
    unitSize?: true
    quantity?: true
    unitId?: true
    rate?: true
    amount?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderItemMaxAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    packingUnitId?: true
    packingType?: true
    pcs?: true
    unitSize?: true
    quantity?: true
    unitId?: true
    rate?: true
    amount?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderItemCountAggregateInputType = {
    id?: true
    purchaseOrderId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    packingUnitId?: true
    packingType?: true
    pcs?: true
    unitSize?: true
    quantity?: true
    unitId?: true
    rate?: true
    amount?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItem to aggregate.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderItems
    **/
    _count?: true | PurchaseOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type GetPurchaseOrderItemAggregateType<T extends PurchaseOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
  }




  export type PurchaseOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithAggregationInput | PurchaseOrderItemOrderByWithAggregationInput[]
    by: PurchaseOrderItemScalarFieldEnum[] | PurchaseOrderItemScalarFieldEnum
    having?: PurchaseOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderItemCountAggregateInputType | true
    _avg?: PurchaseOrderItemAvgAggregateInputType
    _sum?: PurchaseOrderItemSumAggregateInputType
    _min?: PurchaseOrderItemMinAggregateInputType
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type PurchaseOrderItemGroupByOutputType = {
    id: string
    purchaseOrderId: string
    itemMasterId: string
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    packingUnitId: string | null
    packingType: $Enums.PackingType | null
    pcs: number | null
    unitSize: number | null
    quantity: number | null
    unitId: number | null
    rate: number
    amount: number
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  type GetPurchaseOrderItemGroupByPayload<T extends PurchaseOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    packingUnitId?: boolean
    packingType?: boolean
    pcs?: boolean
    unitSize?: boolean
    quantity?: boolean
    unitId?: boolean
    rate?: boolean
    amount?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseOrderItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseOrderItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseOrderItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | PurchaseOrderItem$packingUnitArgs<ExtArgs>
    unit?: boolean | PurchaseOrderItem$unitArgs<ExtArgs>
    grnItems?: boolean | PurchaseOrderItem$grnItemsArgs<ExtArgs>
    invoiceItems?: boolean | PurchaseOrderItem$invoiceItemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    packingUnitId?: boolean
    packingType?: boolean
    pcs?: boolean
    unitSize?: boolean
    quantity?: boolean
    unitId?: boolean
    rate?: boolean
    amount?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseOrderItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseOrderItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseOrderItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | PurchaseOrderItem$packingUnitArgs<ExtArgs>
    unit?: boolean | PurchaseOrderItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchaseOrderId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    packingUnitId?: boolean
    packingType?: boolean
    pcs?: boolean
    unitSize?: boolean
    quantity?: boolean
    unitId?: boolean
    rate?: boolean
    amount?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseOrderItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseOrderItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseOrderItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | PurchaseOrderItem$packingUnitArgs<ExtArgs>
    unit?: boolean | PurchaseOrderItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectScalar = {
    id?: boolean
    purchaseOrderId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    packingUnitId?: boolean
    packingType?: boolean
    pcs?: boolean
    unitSize?: boolean
    quantity?: boolean
    unitId?: boolean
    rate?: boolean
    amount?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchaseOrderId" | "itemMasterId" | "colorId" | "brandId" | "itemGradeId" | "packingUnitId" | "packingType" | "pcs" | "unitSize" | "quantity" | "unitId" | "rate" | "amount" | "remarks" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseOrderItem"]>
  export type PurchaseOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseOrderItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseOrderItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseOrderItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | PurchaseOrderItem$packingUnitArgs<ExtArgs>
    unit?: boolean | PurchaseOrderItem$unitArgs<ExtArgs>
    grnItems?: boolean | PurchaseOrderItem$grnItemsArgs<ExtArgs>
    invoiceItems?: boolean | PurchaseOrderItem$invoiceItemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseOrderItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseOrderItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseOrderItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | PurchaseOrderItem$packingUnitArgs<ExtArgs>
    unit?: boolean | PurchaseOrderItem$unitArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseOrderItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseOrderItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseOrderItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | PurchaseOrderItem$packingUnitArgs<ExtArgs>
    unit?: boolean | PurchaseOrderItem$unitArgs<ExtArgs>
  }

  export type $PurchaseOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderItem"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
      itemMaster: Prisma.$ItemMasterPayload<ExtArgs>
      color: Prisma.$ColorPayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs> | null
      itemGrade: Prisma.$ItemGradePayload<ExtArgs> | null
      packingUnit: Prisma.$PackingUnitPayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs> | null
      grnItems: Prisma.$GRNItemPayload<ExtArgs>[]
      invoiceItems: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchaseOrderId: string
      itemMasterId: string
      colorId: string | null
      brandId: string | null
      itemGradeId: string | null
      packingUnitId: string | null
      packingType: $Enums.PackingType | null
      pcs: number | null
      unitSize: number | null
      quantity: number | null
      unitId: number | null
      rate: number
      amount: number
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrderItem"]>
    composites: {}
  }

  type PurchaseOrderItemGetPayload<S extends boolean | null | undefined | PurchaseOrderItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderItemPayload, S>

  type PurchaseOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderItemCountAggregateInputType | true
    }

  export interface PurchaseOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderItem'], meta: { name: 'PurchaseOrderItem' } }
    /**
     * Find zero or one PurchaseOrderItem that matches the filter.
     * @param {PurchaseOrderItemFindUniqueArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderItemFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderItemFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
     * 
     * // Get first 10 PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderItemFindManyArgs>(args?: SelectSubset<T, PurchaseOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrderItem.
     * @param {PurchaseOrderItemCreateArgs} args - Arguments to create a PurchaseOrderItem.
     * @example
     * // Create one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.create({
     *   data: {
     *     // ... data to create a PurchaseOrderItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderItemCreateArgs>(args: SelectSubset<T, PurchaseOrderItemCreateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrderItems.
     * @param {PurchaseOrderItemCreateManyArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderItemCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderItems and returns the data saved in the database.
     * @param {PurchaseOrderItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrderItem.
     * @param {PurchaseOrderItemDeleteArgs} args - Arguments to delete one PurchaseOrderItem.
     * @example
     * // Delete one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderItemDeleteArgs>(args: SelectSubset<T, PurchaseOrderItemDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpdateArgs} args - Arguments to update one PurchaseOrderItem.
     * @example
     * // Update one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderItemUpdateArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrderItems.
     * @param {PurchaseOrderItemDeleteManyArgs} args - Arguments to filter PurchaseOrderItems to delete.
     * @example
     * // Delete a few PurchaseOrderItems
     * const { count } = await prisma.purchaseOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderItemUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems and returns the data updated in the database.
     * @param {PurchaseOrderItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrderItems.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpsertArgs} args - Arguments to update or create a PurchaseOrderItem.
     * @example
     * // Update or create a PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderItemUpsertArgs>(args: SelectSubset<T, PurchaseOrderItemUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemCountArgs} args - Arguments to filter PurchaseOrderItems to count.
     * @example
     * // Count the number of PurchaseOrderItems
     * const count = await prisma.purchaseOrderItem.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderItemCountArgs>(
      args?: Subset<T, PurchaseOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderItemAggregateArgs>(args: Subset<T, PurchaseOrderItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderItemAggregateType<T>>

    /**
     * Group by PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderItem model
   */
  readonly fields: PurchaseOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    itemMaster<T extends ItemMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemMasterDefaultArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    color<T extends PurchaseOrderItem$colorArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderItem$colorArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    brand<T extends PurchaseOrderItem$brandArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderItem$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itemGrade<T extends PurchaseOrderItem$itemGradeArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderItem$itemGradeArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    packingUnit<T extends PurchaseOrderItem$packingUnitArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderItem$packingUnitArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unit<T extends PurchaseOrderItem$unitArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderItem$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    grnItems<T extends PurchaseOrderItem$grnItemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderItem$grnItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoiceItems<T extends PurchaseOrderItem$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderItem$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderItem model
   */
  interface PurchaseOrderItemFieldRefs {
    readonly id: FieldRef<"PurchaseOrderItem", 'String'>
    readonly purchaseOrderId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly itemMasterId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly colorId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly brandId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly itemGradeId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly packingUnitId: FieldRef<"PurchaseOrderItem", 'String'>
    readonly packingType: FieldRef<"PurchaseOrderItem", 'PackingType'>
    readonly pcs: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly unitSize: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly quantity: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly unitId: FieldRef<"PurchaseOrderItem", 'Int'>
    readonly rate: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly amount: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly remarks: FieldRef<"PurchaseOrderItem", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderItem findUnique
   */
  export type PurchaseOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findUniqueOrThrow
   */
  export type PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findFirst
   */
  export type PurchaseOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findFirstOrThrow
   */
  export type PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findMany
   */
  export type PurchaseOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItems to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem create
   */
  export type PurchaseOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
  }

  /**
   * PurchaseOrderItem createMany
   */
  export type PurchaseOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrderItem createManyAndReturn
   */
  export type PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem update
   */
  export type PurchaseOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderItem to update.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem updateMany
   */
  export type PurchaseOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem updateManyAndReturn
   */
  export type PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem upsert
   */
  export type PurchaseOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderItem to update in case it exists.
     */
    where: PurchaseOrderItemWhereUniqueInput
    /**
     * In case the PurchaseOrderItem found by the `where` argument doesn't exist, create a new PurchaseOrderItem with this data.
     */
    create: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
    /**
     * In case the PurchaseOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderItem delete
   */
  export type PurchaseOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderItem to delete.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem deleteMany
   */
  export type PurchaseOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItems to delete
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * Limit how many PurchaseOrderItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrderItem.color
   */
  export type PurchaseOrderItem$colorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    where?: ColorWhereInput
  }

  /**
   * PurchaseOrderItem.brand
   */
  export type PurchaseOrderItem$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * PurchaseOrderItem.itemGrade
   */
  export type PurchaseOrderItem$itemGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    where?: ItemGradeWhereInput
  }

  /**
   * PurchaseOrderItem.packingUnit
   */
  export type PurchaseOrderItem$packingUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    where?: PackingUnitWhereInput
  }

  /**
   * PurchaseOrderItem.unit
   */
  export type PurchaseOrderItem$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * PurchaseOrderItem.grnItems
   */
  export type PurchaseOrderItem$grnItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    where?: GRNItemWhereInput
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    cursor?: GRNItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem.invoiceItems
   */
  export type PurchaseOrderItem$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem without action
   */
  export type PurchaseOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model GRN
   */

  export type AggregateGRN = {
    _count: GRNCountAggregateOutputType | null
    _avg: GRNAvgAggregateOutputType | null
    _sum: GRNSumAggregateOutputType | null
    _min: GRNMinAggregateOutputType | null
    _max: GRNMaxAggregateOutputType | null
  }

  export type GRNAvgAggregateOutputType = {
    companyId: number | null
  }

  export type GRNSumAggregateOutputType = {
    companyId: number | null
  }

  export type GRNMinAggregateOutputType = {
    id: string | null
    grnNumber: string | null
    date: Date | null
    purchaseOrderId: string | null
    lotNo: string | null
    warehouseRefNo: string | null
    remarks: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GRNMaxAggregateOutputType = {
    id: string | null
    grnNumber: string | null
    date: Date | null
    purchaseOrderId: string | null
    lotNo: string | null
    warehouseRefNo: string | null
    remarks: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GRNCountAggregateOutputType = {
    id: number
    grnNumber: number
    date: number
    purchaseOrderId: number
    lotNo: number
    warehouseRefNo: number
    remarks: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GRNAvgAggregateInputType = {
    companyId?: true
  }

  export type GRNSumAggregateInputType = {
    companyId?: true
  }

  export type GRNMinAggregateInputType = {
    id?: true
    grnNumber?: true
    date?: true
    purchaseOrderId?: true
    lotNo?: true
    warehouseRefNo?: true
    remarks?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GRNMaxAggregateInputType = {
    id?: true
    grnNumber?: true
    date?: true
    purchaseOrderId?: true
    lotNo?: true
    warehouseRefNo?: true
    remarks?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GRNCountAggregateInputType = {
    id?: true
    grnNumber?: true
    date?: true
    purchaseOrderId?: true
    lotNo?: true
    warehouseRefNo?: true
    remarks?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GRNAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GRN to aggregate.
     */
    where?: GRNWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNS to fetch.
     */
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GRNWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GRNS
    **/
    _count?: true | GRNCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GRNAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GRNSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GRNMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GRNMaxAggregateInputType
  }

  export type GetGRNAggregateType<T extends GRNAggregateArgs> = {
        [P in keyof T & keyof AggregateGRN]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGRN[P]>
      : GetScalarType<T[P], AggregateGRN[P]>
  }




  export type GRNGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNWhereInput
    orderBy?: GRNOrderByWithAggregationInput | GRNOrderByWithAggregationInput[]
    by: GRNScalarFieldEnum[] | GRNScalarFieldEnum
    having?: GRNScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GRNCountAggregateInputType | true
    _avg?: GRNAvgAggregateInputType
    _sum?: GRNSumAggregateInputType
    _min?: GRNMinAggregateInputType
    _max?: GRNMaxAggregateInputType
  }

  export type GRNGroupByOutputType = {
    id: string
    grnNumber: string
    date: Date
    purchaseOrderId: string
    lotNo: string | null
    warehouseRefNo: string | null
    remarks: string | null
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: GRNCountAggregateOutputType | null
    _avg: GRNAvgAggregateOutputType | null
    _sum: GRNSumAggregateOutputType | null
    _min: GRNMinAggregateOutputType | null
    _max: GRNMaxAggregateOutputType | null
  }

  type GetGRNGroupByPayload<T extends GRNGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GRNGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GRNGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GRNGroupByOutputType[P]>
            : GetScalarType<T[P], GRNGroupByOutputType[P]>
        }
      >
    >


  export type GRNSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grnNumber?: boolean
    date?: boolean
    purchaseOrderId?: boolean
    lotNo?: boolean
    warehouseRefNo?: boolean
    remarks?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | GRN$itemsArgs<ExtArgs>
    purchaseReturns?: boolean | GRN$purchaseReturnsArgs<ExtArgs>
    _count?: boolean | GRNCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gRN"]>

  export type GRNSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grnNumber?: boolean
    date?: boolean
    purchaseOrderId?: boolean
    lotNo?: boolean
    warehouseRefNo?: boolean
    remarks?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gRN"]>

  export type GRNSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grnNumber?: boolean
    date?: boolean
    purchaseOrderId?: boolean
    lotNo?: boolean
    warehouseRefNo?: boolean
    remarks?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gRN"]>

  export type GRNSelectScalar = {
    id?: boolean
    grnNumber?: boolean
    date?: boolean
    purchaseOrderId?: boolean
    lotNo?: boolean
    warehouseRefNo?: boolean
    remarks?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GRNOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "grnNumber" | "date" | "purchaseOrderId" | "lotNo" | "warehouseRefNo" | "remarks" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["gRN"]>
  export type GRNInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | GRN$itemsArgs<ExtArgs>
    purchaseReturns?: boolean | GRN$purchaseReturnsArgs<ExtArgs>
    _count?: boolean | GRNCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GRNIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type GRNIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $GRNPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GRN"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      items: Prisma.$GRNItemPayload<ExtArgs>[]
      purchaseReturns: Prisma.$PurchaseReturnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      grnNumber: string
      date: Date
      purchaseOrderId: string
      lotNo: string | null
      warehouseRefNo: string | null
      remarks: string | null
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gRN"]>
    composites: {}
  }

  type GRNGetPayload<S extends boolean | null | undefined | GRNDefaultArgs> = $Result.GetResult<Prisma.$GRNPayload, S>

  type GRNCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GRNFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GRNCountAggregateInputType | true
    }

  export interface GRNDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GRN'], meta: { name: 'GRN' } }
    /**
     * Find zero or one GRN that matches the filter.
     * @param {GRNFindUniqueArgs} args - Arguments to find a GRN
     * @example
     * // Get one GRN
     * const gRN = await prisma.gRN.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GRNFindUniqueArgs>(args: SelectSubset<T, GRNFindUniqueArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GRN that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GRNFindUniqueOrThrowArgs} args - Arguments to find a GRN
     * @example
     * // Get one GRN
     * const gRN = await prisma.gRN.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GRNFindUniqueOrThrowArgs>(args: SelectSubset<T, GRNFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GRN that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNFindFirstArgs} args - Arguments to find a GRN
     * @example
     * // Get one GRN
     * const gRN = await prisma.gRN.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GRNFindFirstArgs>(args?: SelectSubset<T, GRNFindFirstArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GRN that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNFindFirstOrThrowArgs} args - Arguments to find a GRN
     * @example
     * // Get one GRN
     * const gRN = await prisma.gRN.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GRNFindFirstOrThrowArgs>(args?: SelectSubset<T, GRNFindFirstOrThrowArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GRNS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GRNS
     * const gRNS = await prisma.gRN.findMany()
     * 
     * // Get first 10 GRNS
     * const gRNS = await prisma.gRN.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gRNWithIdOnly = await prisma.gRN.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GRNFindManyArgs>(args?: SelectSubset<T, GRNFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GRN.
     * @param {GRNCreateArgs} args - Arguments to create a GRN.
     * @example
     * // Create one GRN
     * const GRN = await prisma.gRN.create({
     *   data: {
     *     // ... data to create a GRN
     *   }
     * })
     * 
     */
    create<T extends GRNCreateArgs>(args: SelectSubset<T, GRNCreateArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GRNS.
     * @param {GRNCreateManyArgs} args - Arguments to create many GRNS.
     * @example
     * // Create many GRNS
     * const gRN = await prisma.gRN.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GRNCreateManyArgs>(args?: SelectSubset<T, GRNCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GRNS and returns the data saved in the database.
     * @param {GRNCreateManyAndReturnArgs} args - Arguments to create many GRNS.
     * @example
     * // Create many GRNS
     * const gRN = await prisma.gRN.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GRNS and only return the `id`
     * const gRNWithIdOnly = await prisma.gRN.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GRNCreateManyAndReturnArgs>(args?: SelectSubset<T, GRNCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GRN.
     * @param {GRNDeleteArgs} args - Arguments to delete one GRN.
     * @example
     * // Delete one GRN
     * const GRN = await prisma.gRN.delete({
     *   where: {
     *     // ... filter to delete one GRN
     *   }
     * })
     * 
     */
    delete<T extends GRNDeleteArgs>(args: SelectSubset<T, GRNDeleteArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GRN.
     * @param {GRNUpdateArgs} args - Arguments to update one GRN.
     * @example
     * // Update one GRN
     * const gRN = await prisma.gRN.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GRNUpdateArgs>(args: SelectSubset<T, GRNUpdateArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GRNS.
     * @param {GRNDeleteManyArgs} args - Arguments to filter GRNS to delete.
     * @example
     * // Delete a few GRNS
     * const { count } = await prisma.gRN.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GRNDeleteManyArgs>(args?: SelectSubset<T, GRNDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GRNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GRNS
     * const gRN = await prisma.gRN.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GRNUpdateManyArgs>(args: SelectSubset<T, GRNUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GRNS and returns the data updated in the database.
     * @param {GRNUpdateManyAndReturnArgs} args - Arguments to update many GRNS.
     * @example
     * // Update many GRNS
     * const gRN = await prisma.gRN.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GRNS and only return the `id`
     * const gRNWithIdOnly = await prisma.gRN.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GRNUpdateManyAndReturnArgs>(args: SelectSubset<T, GRNUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GRN.
     * @param {GRNUpsertArgs} args - Arguments to update or create a GRN.
     * @example
     * // Update or create a GRN
     * const gRN = await prisma.gRN.upsert({
     *   create: {
     *     // ... data to create a GRN
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GRN we want to update
     *   }
     * })
     */
    upsert<T extends GRNUpsertArgs>(args: SelectSubset<T, GRNUpsertArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GRNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNCountArgs} args - Arguments to filter GRNS to count.
     * @example
     * // Count the number of GRNS
     * const count = await prisma.gRN.count({
     *   where: {
     *     // ... the filter for the GRNS we want to count
     *   }
     * })
    **/
    count<T extends GRNCountArgs>(
      args?: Subset<T, GRNCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GRNCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GRN.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GRNAggregateArgs>(args: Subset<T, GRNAggregateArgs>): Prisma.PrismaPromise<GetGRNAggregateType<T>>

    /**
     * Group by GRN.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GRNGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GRNGroupByArgs['orderBy'] }
        : { orderBy?: GRNGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GRNGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGRNGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GRN model
   */
  readonly fields: GRNFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GRN.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GRNClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends GRN$itemsArgs<ExtArgs> = {}>(args?: Subset<T, GRN$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturns<T extends GRN$purchaseReturnsArgs<ExtArgs> = {}>(args?: Subset<T, GRN$purchaseReturnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GRN model
   */
  interface GRNFieldRefs {
    readonly id: FieldRef<"GRN", 'String'>
    readonly grnNumber: FieldRef<"GRN", 'String'>
    readonly date: FieldRef<"GRN", 'DateTime'>
    readonly purchaseOrderId: FieldRef<"GRN", 'String'>
    readonly lotNo: FieldRef<"GRN", 'String'>
    readonly warehouseRefNo: FieldRef<"GRN", 'String'>
    readonly remarks: FieldRef<"GRN", 'String'>
    readonly companyId: FieldRef<"GRN", 'Int'>
    readonly createdAt: FieldRef<"GRN", 'DateTime'>
    readonly updatedAt: FieldRef<"GRN", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GRN findUnique
   */
  export type GRNFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRN to fetch.
     */
    where: GRNWhereUniqueInput
  }

  /**
   * GRN findUniqueOrThrow
   */
  export type GRNFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRN to fetch.
     */
    where: GRNWhereUniqueInput
  }

  /**
   * GRN findFirst
   */
  export type GRNFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRN to fetch.
     */
    where?: GRNWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNS to fetch.
     */
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GRNS.
     */
    cursor?: GRNWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GRNS.
     */
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * GRN findFirstOrThrow
   */
  export type GRNFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRN to fetch.
     */
    where?: GRNWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNS to fetch.
     */
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GRNS.
     */
    cursor?: GRNWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GRNS.
     */
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * GRN findMany
   */
  export type GRNFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRNS to fetch.
     */
    where?: GRNWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNS to fetch.
     */
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GRNS.
     */
    cursor?: GRNWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNS.
     */
    skip?: number
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * GRN create
   */
  export type GRNCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * The data needed to create a GRN.
     */
    data: XOR<GRNCreateInput, GRNUncheckedCreateInput>
  }

  /**
   * GRN createMany
   */
  export type GRNCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GRNS.
     */
    data: GRNCreateManyInput | GRNCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GRN createManyAndReturn
   */
  export type GRNCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * The data used to create many GRNS.
     */
    data: GRNCreateManyInput | GRNCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GRN update
   */
  export type GRNUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * The data needed to update a GRN.
     */
    data: XOR<GRNUpdateInput, GRNUncheckedUpdateInput>
    /**
     * Choose, which GRN to update.
     */
    where: GRNWhereUniqueInput
  }

  /**
   * GRN updateMany
   */
  export type GRNUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GRNS.
     */
    data: XOR<GRNUpdateManyMutationInput, GRNUncheckedUpdateManyInput>
    /**
     * Filter which GRNS to update
     */
    where?: GRNWhereInput
    /**
     * Limit how many GRNS to update.
     */
    limit?: number
  }

  /**
   * GRN updateManyAndReturn
   */
  export type GRNUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * The data used to update GRNS.
     */
    data: XOR<GRNUpdateManyMutationInput, GRNUncheckedUpdateManyInput>
    /**
     * Filter which GRNS to update
     */
    where?: GRNWhereInput
    /**
     * Limit how many GRNS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GRN upsert
   */
  export type GRNUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * The filter to search for the GRN to update in case it exists.
     */
    where: GRNWhereUniqueInput
    /**
     * In case the GRN found by the `where` argument doesn't exist, create a new GRN with this data.
     */
    create: XOR<GRNCreateInput, GRNUncheckedCreateInput>
    /**
     * In case the GRN was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GRNUpdateInput, GRNUncheckedUpdateInput>
  }

  /**
   * GRN delete
   */
  export type GRNDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter which GRN to delete.
     */
    where: GRNWhereUniqueInput
  }

  /**
   * GRN deleteMany
   */
  export type GRNDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GRNS to delete
     */
    where?: GRNWhereInput
    /**
     * Limit how many GRNS to delete.
     */
    limit?: number
  }

  /**
   * GRN.items
   */
  export type GRN$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    where?: GRNItemWhereInput
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    cursor?: GRNItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * GRN.purchaseReturns
   */
  export type GRN$purchaseReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    where?: PurchaseReturnWhereInput
    orderBy?: PurchaseReturnOrderByWithRelationInput | PurchaseReturnOrderByWithRelationInput[]
    cursor?: PurchaseReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnScalarFieldEnum | PurchaseReturnScalarFieldEnum[]
  }

  /**
   * GRN without action
   */
  export type GRNDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
  }


  /**
   * Model GRNItem
   */

  export type AggregateGRNItem = {
    _count: GRNItemCountAggregateOutputType | null
    _avg: GRNItemAvgAggregateOutputType | null
    _sum: GRNItemSumAggregateOutputType | null
    _min: GRNItemMinAggregateOutputType | null
    _max: GRNItemMaxAggregateOutputType | null
  }

  export type GRNItemAvgAggregateOutputType = {
    receivedQty: number | null
    pcs: number | null
    unitSize: number | null
    unitId: number | null
  }

  export type GRNItemSumAggregateOutputType = {
    receivedQty: number | null
    pcs: number | null
    unitSize: number | null
    unitId: number | null
  }

  export type GRNItemMinAggregateOutputType = {
    id: string | null
    grnId: string | null
    purchaseOrderItemId: string | null
    itemMasterId: string | null
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    packingUnitId: string | null
    receivedQty: number | null
    pcs: number | null
    unitSize: number | null
    packingType: $Enums.PackingType | null
    unitId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GRNItemMaxAggregateOutputType = {
    id: string | null
    grnId: string | null
    purchaseOrderItemId: string | null
    itemMasterId: string | null
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    packingUnitId: string | null
    receivedQty: number | null
    pcs: number | null
    unitSize: number | null
    packingType: $Enums.PackingType | null
    unitId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GRNItemCountAggregateOutputType = {
    id: number
    grnId: number
    purchaseOrderItemId: number
    itemMasterId: number
    colorId: number
    brandId: number
    itemGradeId: number
    packingUnitId: number
    receivedQty: number
    pcs: number
    unitSize: number
    packingType: number
    unitId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GRNItemAvgAggregateInputType = {
    receivedQty?: true
    pcs?: true
    unitSize?: true
    unitId?: true
  }

  export type GRNItemSumAggregateInputType = {
    receivedQty?: true
    pcs?: true
    unitSize?: true
    unitId?: true
  }

  export type GRNItemMinAggregateInputType = {
    id?: true
    grnId?: true
    purchaseOrderItemId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    packingUnitId?: true
    receivedQty?: true
    pcs?: true
    unitSize?: true
    packingType?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GRNItemMaxAggregateInputType = {
    id?: true
    grnId?: true
    purchaseOrderItemId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    packingUnitId?: true
    receivedQty?: true
    pcs?: true
    unitSize?: true
    packingType?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GRNItemCountAggregateInputType = {
    id?: true
    grnId?: true
    purchaseOrderItemId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    packingUnitId?: true
    receivedQty?: true
    pcs?: true
    unitSize?: true
    packingType?: true
    unitId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GRNItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GRNItem to aggregate.
     */
    where?: GRNItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNItems to fetch.
     */
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GRNItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GRNItems
    **/
    _count?: true | GRNItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GRNItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GRNItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GRNItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GRNItemMaxAggregateInputType
  }

  export type GetGRNItemAggregateType<T extends GRNItemAggregateArgs> = {
        [P in keyof T & keyof AggregateGRNItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGRNItem[P]>
      : GetScalarType<T[P], AggregateGRNItem[P]>
  }




  export type GRNItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNItemWhereInput
    orderBy?: GRNItemOrderByWithAggregationInput | GRNItemOrderByWithAggregationInput[]
    by: GRNItemScalarFieldEnum[] | GRNItemScalarFieldEnum
    having?: GRNItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GRNItemCountAggregateInputType | true
    _avg?: GRNItemAvgAggregateInputType
    _sum?: GRNItemSumAggregateInputType
    _min?: GRNItemMinAggregateInputType
    _max?: GRNItemMaxAggregateInputType
  }

  export type GRNItemGroupByOutputType = {
    id: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    packingUnitId: string | null
    receivedQty: number
    pcs: number | null
    unitSize: number | null
    packingType: $Enums.PackingType | null
    unitId: number | null
    createdAt: Date
    updatedAt: Date
    _count: GRNItemCountAggregateOutputType | null
    _avg: GRNItemAvgAggregateOutputType | null
    _sum: GRNItemSumAggregateOutputType | null
    _min: GRNItemMinAggregateOutputType | null
    _max: GRNItemMaxAggregateOutputType | null
  }

  type GetGRNItemGroupByPayload<T extends GRNItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GRNItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GRNItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GRNItemGroupByOutputType[P]>
            : GetScalarType<T[P], GRNItemGroupByOutputType[P]>
        }
      >
    >


  export type GRNItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grnId?: boolean
    purchaseOrderItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    packingUnitId?: boolean
    receivedQty?: boolean
    pcs?: boolean
    unitSize?: boolean
    packingType?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grn?: boolean | GRNDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseOrderItemDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | GRNItem$colorArgs<ExtArgs>
    brand?: boolean | GRNItem$brandArgs<ExtArgs>
    itemGrade?: boolean | GRNItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | GRNItem$packingUnitArgs<ExtArgs>
    unit?: boolean | GRNItem$unitArgs<ExtArgs>
    invoiceItems?: boolean | GRNItem$invoiceItemsArgs<ExtArgs>
    _count?: boolean | GRNItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gRNItem"]>

  export type GRNItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grnId?: boolean
    purchaseOrderItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    packingUnitId?: boolean
    receivedQty?: boolean
    pcs?: boolean
    unitSize?: boolean
    packingType?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grn?: boolean | GRNDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseOrderItemDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | GRNItem$colorArgs<ExtArgs>
    brand?: boolean | GRNItem$brandArgs<ExtArgs>
    itemGrade?: boolean | GRNItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | GRNItem$packingUnitArgs<ExtArgs>
    unit?: boolean | GRNItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["gRNItem"]>

  export type GRNItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grnId?: boolean
    purchaseOrderItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    packingUnitId?: boolean
    receivedQty?: boolean
    pcs?: boolean
    unitSize?: boolean
    packingType?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    grn?: boolean | GRNDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseOrderItemDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | GRNItem$colorArgs<ExtArgs>
    brand?: boolean | GRNItem$brandArgs<ExtArgs>
    itemGrade?: boolean | GRNItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | GRNItem$packingUnitArgs<ExtArgs>
    unit?: boolean | GRNItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["gRNItem"]>

  export type GRNItemSelectScalar = {
    id?: boolean
    grnId?: boolean
    purchaseOrderItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    packingUnitId?: boolean
    receivedQty?: boolean
    pcs?: boolean
    unitSize?: boolean
    packingType?: boolean
    unitId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GRNItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "grnId" | "purchaseOrderItemId" | "itemMasterId" | "colorId" | "brandId" | "itemGradeId" | "packingUnitId" | "receivedQty" | "pcs" | "unitSize" | "packingType" | "unitId" | "createdAt" | "updatedAt", ExtArgs["result"]["gRNItem"]>
  export type GRNItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grn?: boolean | GRNDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseOrderItemDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | GRNItem$colorArgs<ExtArgs>
    brand?: boolean | GRNItem$brandArgs<ExtArgs>
    itemGrade?: boolean | GRNItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | GRNItem$packingUnitArgs<ExtArgs>
    unit?: boolean | GRNItem$unitArgs<ExtArgs>
    invoiceItems?: boolean | GRNItem$invoiceItemsArgs<ExtArgs>
    _count?: boolean | GRNItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GRNItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grn?: boolean | GRNDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseOrderItemDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | GRNItem$colorArgs<ExtArgs>
    brand?: boolean | GRNItem$brandArgs<ExtArgs>
    itemGrade?: boolean | GRNItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | GRNItem$packingUnitArgs<ExtArgs>
    unit?: boolean | GRNItem$unitArgs<ExtArgs>
  }
  export type GRNItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grn?: boolean | GRNDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseOrderItemDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | GRNItem$colorArgs<ExtArgs>
    brand?: boolean | GRNItem$brandArgs<ExtArgs>
    itemGrade?: boolean | GRNItem$itemGradeArgs<ExtArgs>
    packingUnit?: boolean | GRNItem$packingUnitArgs<ExtArgs>
    unit?: boolean | GRNItem$unitArgs<ExtArgs>
  }

  export type $GRNItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GRNItem"
    objects: {
      grn: Prisma.$GRNPayload<ExtArgs>
      purchaseOrderItem: Prisma.$PurchaseOrderItemPayload<ExtArgs>
      itemMaster: Prisma.$ItemMasterPayload<ExtArgs>
      color: Prisma.$ColorPayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs> | null
      itemGrade: Prisma.$ItemGradePayload<ExtArgs> | null
      packingUnit: Prisma.$PackingUnitPayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs> | null
      invoiceItems: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      grnId: string
      purchaseOrderItemId: string
      itemMasterId: string
      colorId: string | null
      brandId: string | null
      itemGradeId: string | null
      packingUnitId: string | null
      receivedQty: number
      pcs: number | null
      unitSize: number | null
      packingType: $Enums.PackingType | null
      unitId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gRNItem"]>
    composites: {}
  }

  type GRNItemGetPayload<S extends boolean | null | undefined | GRNItemDefaultArgs> = $Result.GetResult<Prisma.$GRNItemPayload, S>

  type GRNItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GRNItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GRNItemCountAggregateInputType | true
    }

  export interface GRNItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GRNItem'], meta: { name: 'GRNItem' } }
    /**
     * Find zero or one GRNItem that matches the filter.
     * @param {GRNItemFindUniqueArgs} args - Arguments to find a GRNItem
     * @example
     * // Get one GRNItem
     * const gRNItem = await prisma.gRNItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GRNItemFindUniqueArgs>(args: SelectSubset<T, GRNItemFindUniqueArgs<ExtArgs>>): Prisma__GRNItemClient<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GRNItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GRNItemFindUniqueOrThrowArgs} args - Arguments to find a GRNItem
     * @example
     * // Get one GRNItem
     * const gRNItem = await prisma.gRNItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GRNItemFindUniqueOrThrowArgs>(args: SelectSubset<T, GRNItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GRNItemClient<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GRNItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNItemFindFirstArgs} args - Arguments to find a GRNItem
     * @example
     * // Get one GRNItem
     * const gRNItem = await prisma.gRNItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GRNItemFindFirstArgs>(args?: SelectSubset<T, GRNItemFindFirstArgs<ExtArgs>>): Prisma__GRNItemClient<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GRNItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNItemFindFirstOrThrowArgs} args - Arguments to find a GRNItem
     * @example
     * // Get one GRNItem
     * const gRNItem = await prisma.gRNItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GRNItemFindFirstOrThrowArgs>(args?: SelectSubset<T, GRNItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__GRNItemClient<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GRNItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GRNItems
     * const gRNItems = await prisma.gRNItem.findMany()
     * 
     * // Get first 10 GRNItems
     * const gRNItems = await prisma.gRNItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gRNItemWithIdOnly = await prisma.gRNItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GRNItemFindManyArgs>(args?: SelectSubset<T, GRNItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GRNItem.
     * @param {GRNItemCreateArgs} args - Arguments to create a GRNItem.
     * @example
     * // Create one GRNItem
     * const GRNItem = await prisma.gRNItem.create({
     *   data: {
     *     // ... data to create a GRNItem
     *   }
     * })
     * 
     */
    create<T extends GRNItemCreateArgs>(args: SelectSubset<T, GRNItemCreateArgs<ExtArgs>>): Prisma__GRNItemClient<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GRNItems.
     * @param {GRNItemCreateManyArgs} args - Arguments to create many GRNItems.
     * @example
     * // Create many GRNItems
     * const gRNItem = await prisma.gRNItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GRNItemCreateManyArgs>(args?: SelectSubset<T, GRNItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GRNItems and returns the data saved in the database.
     * @param {GRNItemCreateManyAndReturnArgs} args - Arguments to create many GRNItems.
     * @example
     * // Create many GRNItems
     * const gRNItem = await prisma.gRNItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GRNItems and only return the `id`
     * const gRNItemWithIdOnly = await prisma.gRNItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GRNItemCreateManyAndReturnArgs>(args?: SelectSubset<T, GRNItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GRNItem.
     * @param {GRNItemDeleteArgs} args - Arguments to delete one GRNItem.
     * @example
     * // Delete one GRNItem
     * const GRNItem = await prisma.gRNItem.delete({
     *   where: {
     *     // ... filter to delete one GRNItem
     *   }
     * })
     * 
     */
    delete<T extends GRNItemDeleteArgs>(args: SelectSubset<T, GRNItemDeleteArgs<ExtArgs>>): Prisma__GRNItemClient<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GRNItem.
     * @param {GRNItemUpdateArgs} args - Arguments to update one GRNItem.
     * @example
     * // Update one GRNItem
     * const gRNItem = await prisma.gRNItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GRNItemUpdateArgs>(args: SelectSubset<T, GRNItemUpdateArgs<ExtArgs>>): Prisma__GRNItemClient<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GRNItems.
     * @param {GRNItemDeleteManyArgs} args - Arguments to filter GRNItems to delete.
     * @example
     * // Delete a few GRNItems
     * const { count } = await prisma.gRNItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GRNItemDeleteManyArgs>(args?: SelectSubset<T, GRNItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GRNItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GRNItems
     * const gRNItem = await prisma.gRNItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GRNItemUpdateManyArgs>(args: SelectSubset<T, GRNItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GRNItems and returns the data updated in the database.
     * @param {GRNItemUpdateManyAndReturnArgs} args - Arguments to update many GRNItems.
     * @example
     * // Update many GRNItems
     * const gRNItem = await prisma.gRNItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GRNItems and only return the `id`
     * const gRNItemWithIdOnly = await prisma.gRNItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GRNItemUpdateManyAndReturnArgs>(args: SelectSubset<T, GRNItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GRNItem.
     * @param {GRNItemUpsertArgs} args - Arguments to update or create a GRNItem.
     * @example
     * // Update or create a GRNItem
     * const gRNItem = await prisma.gRNItem.upsert({
     *   create: {
     *     // ... data to create a GRNItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GRNItem we want to update
     *   }
     * })
     */
    upsert<T extends GRNItemUpsertArgs>(args: SelectSubset<T, GRNItemUpsertArgs<ExtArgs>>): Prisma__GRNItemClient<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GRNItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNItemCountArgs} args - Arguments to filter GRNItems to count.
     * @example
     * // Count the number of GRNItems
     * const count = await prisma.gRNItem.count({
     *   where: {
     *     // ... the filter for the GRNItems we want to count
     *   }
     * })
    **/
    count<T extends GRNItemCountArgs>(
      args?: Subset<T, GRNItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GRNItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GRNItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GRNItemAggregateArgs>(args: Subset<T, GRNItemAggregateArgs>): Prisma.PrismaPromise<GetGRNItemAggregateType<T>>

    /**
     * Group by GRNItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GRNItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GRNItemGroupByArgs['orderBy'] }
        : { orderBy?: GRNItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GRNItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGRNItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GRNItem model
   */
  readonly fields: GRNItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GRNItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GRNItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    grn<T extends GRNDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GRNDefaultArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrderItem<T extends PurchaseOrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderItemDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    itemMaster<T extends ItemMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemMasterDefaultArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    color<T extends GRNItem$colorArgs<ExtArgs> = {}>(args?: Subset<T, GRNItem$colorArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    brand<T extends GRNItem$brandArgs<ExtArgs> = {}>(args?: Subset<T, GRNItem$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itemGrade<T extends GRNItem$itemGradeArgs<ExtArgs> = {}>(args?: Subset<T, GRNItem$itemGradeArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    packingUnit<T extends GRNItem$packingUnitArgs<ExtArgs> = {}>(args?: Subset<T, GRNItem$packingUnitArgs<ExtArgs>>): Prisma__PackingUnitClient<$Result.GetResult<Prisma.$PackingUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unit<T extends GRNItem$unitArgs<ExtArgs> = {}>(args?: Subset<T, GRNItem$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoiceItems<T extends GRNItem$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, GRNItem$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GRNItem model
   */
  interface GRNItemFieldRefs {
    readonly id: FieldRef<"GRNItem", 'String'>
    readonly grnId: FieldRef<"GRNItem", 'String'>
    readonly purchaseOrderItemId: FieldRef<"GRNItem", 'String'>
    readonly itemMasterId: FieldRef<"GRNItem", 'String'>
    readonly colorId: FieldRef<"GRNItem", 'String'>
    readonly brandId: FieldRef<"GRNItem", 'String'>
    readonly itemGradeId: FieldRef<"GRNItem", 'String'>
    readonly packingUnitId: FieldRef<"GRNItem", 'String'>
    readonly receivedQty: FieldRef<"GRNItem", 'Float'>
    readonly pcs: FieldRef<"GRNItem", 'Float'>
    readonly unitSize: FieldRef<"GRNItem", 'Float'>
    readonly packingType: FieldRef<"GRNItem", 'PackingType'>
    readonly unitId: FieldRef<"GRNItem", 'Int'>
    readonly createdAt: FieldRef<"GRNItem", 'DateTime'>
    readonly updatedAt: FieldRef<"GRNItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GRNItem findUnique
   */
  export type GRNItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    /**
     * Filter, which GRNItem to fetch.
     */
    where: GRNItemWhereUniqueInput
  }

  /**
   * GRNItem findUniqueOrThrow
   */
  export type GRNItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    /**
     * Filter, which GRNItem to fetch.
     */
    where: GRNItemWhereUniqueInput
  }

  /**
   * GRNItem findFirst
   */
  export type GRNItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    /**
     * Filter, which GRNItem to fetch.
     */
    where?: GRNItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNItems to fetch.
     */
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GRNItems.
     */
    cursor?: GRNItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GRNItems.
     */
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * GRNItem findFirstOrThrow
   */
  export type GRNItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    /**
     * Filter, which GRNItem to fetch.
     */
    where?: GRNItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNItems to fetch.
     */
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GRNItems.
     */
    cursor?: GRNItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GRNItems.
     */
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * GRNItem findMany
   */
  export type GRNItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    /**
     * Filter, which GRNItems to fetch.
     */
    where?: GRNItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNItems to fetch.
     */
    orderBy?: GRNItemOrderByWithRelationInput | GRNItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GRNItems.
     */
    cursor?: GRNItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNItems.
     */
    skip?: number
    distinct?: GRNItemScalarFieldEnum | GRNItemScalarFieldEnum[]
  }

  /**
   * GRNItem create
   */
  export type GRNItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    /**
     * The data needed to create a GRNItem.
     */
    data: XOR<GRNItemCreateInput, GRNItemUncheckedCreateInput>
  }

  /**
   * GRNItem createMany
   */
  export type GRNItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GRNItems.
     */
    data: GRNItemCreateManyInput | GRNItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GRNItem createManyAndReturn
   */
  export type GRNItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * The data used to create many GRNItems.
     */
    data: GRNItemCreateManyInput | GRNItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GRNItem update
   */
  export type GRNItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    /**
     * The data needed to update a GRNItem.
     */
    data: XOR<GRNItemUpdateInput, GRNItemUncheckedUpdateInput>
    /**
     * Choose, which GRNItem to update.
     */
    where: GRNItemWhereUniqueInput
  }

  /**
   * GRNItem updateMany
   */
  export type GRNItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GRNItems.
     */
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyInput>
    /**
     * Filter which GRNItems to update
     */
    where?: GRNItemWhereInput
    /**
     * Limit how many GRNItems to update.
     */
    limit?: number
  }

  /**
   * GRNItem updateManyAndReturn
   */
  export type GRNItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * The data used to update GRNItems.
     */
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyInput>
    /**
     * Filter which GRNItems to update
     */
    where?: GRNItemWhereInput
    /**
     * Limit how many GRNItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GRNItem upsert
   */
  export type GRNItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    /**
     * The filter to search for the GRNItem to update in case it exists.
     */
    where: GRNItemWhereUniqueInput
    /**
     * In case the GRNItem found by the `where` argument doesn't exist, create a new GRNItem with this data.
     */
    create: XOR<GRNItemCreateInput, GRNItemUncheckedCreateInput>
    /**
     * In case the GRNItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GRNItemUpdateInput, GRNItemUncheckedUpdateInput>
  }

  /**
   * GRNItem delete
   */
  export type GRNItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    /**
     * Filter which GRNItem to delete.
     */
    where: GRNItemWhereUniqueInput
  }

  /**
   * GRNItem deleteMany
   */
  export type GRNItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GRNItems to delete
     */
    where?: GRNItemWhereInput
    /**
     * Limit how many GRNItems to delete.
     */
    limit?: number
  }

  /**
   * GRNItem.color
   */
  export type GRNItem$colorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    where?: ColorWhereInput
  }

  /**
   * GRNItem.brand
   */
  export type GRNItem$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * GRNItem.itemGrade
   */
  export type GRNItem$itemGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    where?: ItemGradeWhereInput
  }

  /**
   * GRNItem.packingUnit
   */
  export type GRNItem$packingUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackingUnit
     */
    select?: PackingUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PackingUnit
     */
    omit?: PackingUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackingUnitInclude<ExtArgs> | null
    where?: PackingUnitWhereInput
  }

  /**
   * GRNItem.unit
   */
  export type GRNItem$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * GRNItem.invoiceItems
   */
  export type GRNItem$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * GRNItem without action
   */
  export type GRNItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseInvoice
   */

  export type AggregatePurchaseInvoice = {
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  export type PurchaseInvoiceAvgAggregateOutputType = {
    accountId: number | null
    totalAmount: number | null
    companyId: number | null
  }

  export type PurchaseInvoiceSumAggregateOutputType = {
    accountId: number | null
    totalAmount: number | null
    companyId: number | null
  }

  export type PurchaseInvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    date: Date | null
    supplierInvoiceNo: string | null
    remarks: string | null
    purchaseOrderId: string | null
    accountId: number | null
    totalAmount: number | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    date: Date | null
    supplierInvoiceNo: string | null
    remarks: string | null
    purchaseOrderId: string | null
    accountId: number | null
    totalAmount: number | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    date: number
    supplierInvoiceNo: number
    remarks: number
    purchaseOrderId: number
    accountId: number
    totalAmount: number
    status: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseInvoiceAvgAggregateInputType = {
    accountId?: true
    totalAmount?: true
    companyId?: true
  }

  export type PurchaseInvoiceSumAggregateInputType = {
    accountId?: true
    totalAmount?: true
    companyId?: true
  }

  export type PurchaseInvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    date?: true
    supplierInvoiceNo?: true
    remarks?: true
    purchaseOrderId?: true
    accountId?: true
    totalAmount?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    date?: true
    supplierInvoiceNo?: true
    remarks?: true
    purchaseOrderId?: true
    accountId?: true
    totalAmount?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    date?: true
    supplierInvoiceNo?: true
    remarks?: true
    purchaseOrderId?: true
    accountId?: true
    totalAmount?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoice to aggregate.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseInvoices
    **/
    _count?: true | PurchaseInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type GetPurchaseInvoiceAggregateType<T extends PurchaseInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
      : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
  }




  export type PurchaseInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithAggregationInput | PurchaseInvoiceOrderByWithAggregationInput[]
    by: PurchaseInvoiceScalarFieldEnum[] | PurchaseInvoiceScalarFieldEnum
    having?: PurchaseInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseInvoiceCountAggregateInputType | true
    _avg?: PurchaseInvoiceAvgAggregateInputType
    _sum?: PurchaseInvoiceSumAggregateInputType
    _min?: PurchaseInvoiceMinAggregateInputType
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type PurchaseInvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    date: Date
    supplierInvoiceNo: string | null
    remarks: string | null
    purchaseOrderId: string | null
    accountId: number | null
    totalAmount: number
    status: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  type GetPurchaseInvoiceGroupByPayload<T extends PurchaseInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    supplierInvoiceNo?: boolean
    remarks?: boolean
    purchaseOrderId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseInvoice$purchaseOrderArgs<ExtArgs>
    account?: boolean | PurchaseInvoice$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | PurchaseInvoice$itemsArgs<ExtArgs>
    purchaseReturns?: boolean | PurchaseInvoice$purchaseReturnsArgs<ExtArgs>
    _count?: boolean | PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    supplierInvoiceNo?: boolean
    remarks?: boolean
    purchaseOrderId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseInvoice$purchaseOrderArgs<ExtArgs>
    account?: boolean | PurchaseInvoice$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    supplierInvoiceNo?: boolean
    remarks?: boolean
    purchaseOrderId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseOrder?: boolean | PurchaseInvoice$purchaseOrderArgs<ExtArgs>
    account?: boolean | PurchaseInvoice$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    date?: boolean
    supplierInvoiceNo?: boolean
    remarks?: boolean
    purchaseOrderId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "date" | "supplierInvoiceNo" | "remarks" | "purchaseOrderId" | "accountId" | "totalAmount" | "status" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseInvoice"]>
  export type PurchaseInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseInvoice$purchaseOrderArgs<ExtArgs>
    account?: boolean | PurchaseInvoice$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | PurchaseInvoice$itemsArgs<ExtArgs>
    purchaseReturns?: boolean | PurchaseInvoice$purchaseReturnsArgs<ExtArgs>
    _count?: boolean | PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseInvoice$purchaseOrderArgs<ExtArgs>
    account?: boolean | PurchaseInvoice$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrder?: boolean | PurchaseInvoice$purchaseOrderArgs<ExtArgs>
    account?: boolean | PurchaseInvoice$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PurchaseInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseInvoice"
    objects: {
      purchaseOrder: Prisma.$PurchaseOrderPayload<ExtArgs> | null
      account: Prisma.$AccountPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      items: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
      purchaseReturns: Prisma.$PurchaseReturnPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      date: Date
      supplierInvoiceNo: string | null
      remarks: string | null
      purchaseOrderId: string | null
      accountId: number | null
      totalAmount: number
      status: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseInvoice"]>
    composites: {}
  }

  type PurchaseInvoiceGetPayload<S extends boolean | null | undefined | PurchaseInvoiceDefaultArgs> = $Result.GetResult<Prisma.$PurchaseInvoicePayload, S>

  type PurchaseInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseInvoiceCountAggregateInputType | true
    }

  export interface PurchaseInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseInvoice'], meta: { name: 'PurchaseInvoice' } }
    /**
     * Find zero or one PurchaseInvoice that matches the filter.
     * @param {PurchaseInvoiceFindUniqueArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseInvoiceFindUniqueArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseInvoiceFindUniqueOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseInvoiceFindFirstArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
     * 
     * // Get first 10 PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseInvoiceFindManyArgs>(args?: SelectSubset<T, PurchaseInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseInvoice.
     * @param {PurchaseInvoiceCreateArgs} args - Arguments to create a PurchaseInvoice.
     * @example
     * // Create one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.create({
     *   data: {
     *     // ... data to create a PurchaseInvoice
     *   }
     * })
     * 
     */
    create<T extends PurchaseInvoiceCreateArgs>(args: SelectSubset<T, PurchaseInvoiceCreateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseInvoices.
     * @param {PurchaseInvoiceCreateManyArgs} args - Arguments to create many PurchaseInvoices.
     * @example
     * // Create many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseInvoiceCreateManyArgs>(args?: SelectSubset<T, PurchaseInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseInvoices and returns the data saved in the database.
     * @param {PurchaseInvoiceCreateManyAndReturnArgs} args - Arguments to create many PurchaseInvoices.
     * @example
     * // Create many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseInvoices and only return the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseInvoice.
     * @param {PurchaseInvoiceDeleteArgs} args - Arguments to delete one PurchaseInvoice.
     * @example
     * // Delete one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.delete({
     *   where: {
     *     // ... filter to delete one PurchaseInvoice
     *   }
     * })
     * 
     */
    delete<T extends PurchaseInvoiceDeleteArgs>(args: SelectSubset<T, PurchaseInvoiceDeleteArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpdateArgs} args - Arguments to update one PurchaseInvoice.
     * @example
     * // Update one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseInvoiceUpdateArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseInvoices.
     * @param {PurchaseInvoiceDeleteManyArgs} args - Arguments to filter PurchaseInvoices to delete.
     * @example
     * // Delete a few PurchaseInvoices
     * const { count } = await prisma.purchaseInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseInvoiceDeleteManyArgs>(args?: SelectSubset<T, PurchaseInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseInvoiceUpdateManyArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoices and returns the data updated in the database.
     * @param {PurchaseInvoiceUpdateManyAndReturnArgs} args - Arguments to update many PurchaseInvoices.
     * @example
     * // Update many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseInvoices and only return the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpsertArgs} args - Arguments to update or create a PurchaseInvoice.
     * @example
     * // Update or create a PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.upsert({
     *   create: {
     *     // ... data to create a PurchaseInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseInvoice we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseInvoiceUpsertArgs>(args: SelectSubset<T, PurchaseInvoiceUpsertArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceCountArgs} args - Arguments to filter PurchaseInvoices to count.
     * @example
     * // Count the number of PurchaseInvoices
     * const count = await prisma.purchaseInvoice.count({
     *   where: {
     *     // ... the filter for the PurchaseInvoices we want to count
     *   }
     * })
    **/
    count<T extends PurchaseInvoiceCountArgs>(
      args?: Subset<T, PurchaseInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseInvoiceAggregateArgs>(args: Subset<T, PurchaseInvoiceAggregateArgs>): Prisma.PrismaPromise<GetPurchaseInvoiceAggregateType<T>>

    /**
     * Group by PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseInvoice model
   */
  readonly fields: PurchaseInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseOrder<T extends PurchaseInvoice$purchaseOrderArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$purchaseOrderArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    account<T extends PurchaseInvoice$accountArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchaseReturns<T extends PurchaseInvoice$purchaseReturnsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$purchaseReturnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseInvoice model
   */
  interface PurchaseInvoiceFieldRefs {
    readonly id: FieldRef<"PurchaseInvoice", 'String'>
    readonly invoiceNumber: FieldRef<"PurchaseInvoice", 'String'>
    readonly date: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly supplierInvoiceNo: FieldRef<"PurchaseInvoice", 'String'>
    readonly remarks: FieldRef<"PurchaseInvoice", 'String'>
    readonly purchaseOrderId: FieldRef<"PurchaseInvoice", 'String'>
    readonly accountId: FieldRef<"PurchaseInvoice", 'Int'>
    readonly totalAmount: FieldRef<"PurchaseInvoice", 'Float'>
    readonly status: FieldRef<"PurchaseInvoice", 'String'>
    readonly companyId: FieldRef<"PurchaseInvoice", 'Int'>
    readonly createdAt: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseInvoice findUnique
   */
  export type PurchaseInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findUniqueOrThrow
   */
  export type PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findFirst
   */
  export type PurchaseInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findFirstOrThrow
   */
  export type PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findMany
   */
  export type PurchaseInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoices to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice create
   */
  export type PurchaseInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
  }

  /**
   * PurchaseInvoice createMany
   */
  export type PurchaseInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseInvoices.
     */
    data: PurchaseInvoiceCreateManyInput | PurchaseInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseInvoice createManyAndReturn
   */
  export type PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseInvoices.
     */
    data: PurchaseInvoiceCreateManyInput | PurchaseInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoice update
   */
  export type PurchaseInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
    /**
     * Choose, which PurchaseInvoice to update.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice updateMany
   */
  export type PurchaseInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseInvoices.
     */
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoices to update
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to update.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice updateManyAndReturn
   */
  export type PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseInvoices.
     */
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoices to update
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoice upsert
   */
  export type PurchaseInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseInvoice to update in case it exists.
     */
    where: PurchaseInvoiceWhereUniqueInput
    /**
     * In case the PurchaseInvoice found by the `where` argument doesn't exist, create a new PurchaseInvoice with this data.
     */
    create: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
    /**
     * In case the PurchaseInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
  }

  /**
   * PurchaseInvoice delete
   */
  export type PurchaseInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter which PurchaseInvoice to delete.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice deleteMany
   */
  export type PurchaseInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoices to delete
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to delete.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice.purchaseOrder
   */
  export type PurchaseInvoice$purchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseInvoice.account
   */
  export type PurchaseInvoice$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * PurchaseInvoice.items
   */
  export type PurchaseInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice.purchaseReturns
   */
  export type PurchaseInvoice$purchaseReturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    where?: PurchaseReturnWhereInput
    orderBy?: PurchaseReturnOrderByWithRelationInput | PurchaseReturnOrderByWithRelationInput[]
    cursor?: PurchaseReturnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnScalarFieldEnum | PurchaseReturnScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice without action
   */
  export type PurchaseInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseInvoiceItem
   */

  export type AggregatePurchaseInvoiceItem = {
    _count: PurchaseInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseInvoiceItemSumAggregateOutputType | null
    _min: PurchaseInvoiceItemMinAggregateOutputType | null
    _max: PurchaseInvoiceItemMaxAggregateOutputType | null
  }

  export type PurchaseInvoiceItemAvgAggregateOutputType = {
    unitId: number | null
    invoicedQty: number | null
    rate: number | null
    amount: number | null
  }

  export type PurchaseInvoiceItemSumAggregateOutputType = {
    unitId: number | null
    invoicedQty: number | null
    rate: number | null
    amount: number | null
  }

  export type PurchaseInvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    purchaseOrderItemId: string | null
    grnItemId: string | null
    itemMasterId: string | null
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    unitId: number | null
    invoicedQty: number | null
    rate: number | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    purchaseOrderItemId: string | null
    grnItemId: string | null
    itemMasterId: string | null
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    unitId: number | null
    invoicedQty: number | null
    rate: number | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    purchaseOrderItemId: number
    grnItemId: number
    itemMasterId: number
    colorId: number
    brandId: number
    itemGradeId: number
    unitId: number
    invoicedQty: number
    rate: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseInvoiceItemAvgAggregateInputType = {
    unitId?: true
    invoicedQty?: true
    rate?: true
    amount?: true
  }

  export type PurchaseInvoiceItemSumAggregateInputType = {
    unitId?: true
    invoicedQty?: true
    rate?: true
    amount?: true
  }

  export type PurchaseInvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    purchaseOrderItemId?: true
    grnItemId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    unitId?: true
    invoicedQty?: true
    rate?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    purchaseOrderItemId?: true
    grnItemId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    unitId?: true
    invoicedQty?: true
    rate?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    purchaseOrderItemId?: true
    grnItemId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    unitId?: true
    invoicedQty?: true
    rate?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoiceItem to aggregate.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseInvoiceItems
    **/
    _count?: true | PurchaseInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseInvoiceItemMaxAggregateInputType
  }

  export type GetPurchaseInvoiceItemAggregateType<T extends PurchaseInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseInvoiceItem[P]>
      : GetScalarType<T[P], AggregatePurchaseInvoiceItem[P]>
  }




  export type PurchaseInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithAggregationInput | PurchaseInvoiceItemOrderByWithAggregationInput[]
    by: PurchaseInvoiceItemScalarFieldEnum[] | PurchaseInvoiceItemScalarFieldEnum
    having?: PurchaseInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseInvoiceItemCountAggregateInputType | true
    _avg?: PurchaseInvoiceItemAvgAggregateInputType
    _sum?: PurchaseInvoiceItemSumAggregateInputType
    _min?: PurchaseInvoiceItemMinAggregateInputType
    _max?: PurchaseInvoiceItemMaxAggregateInputType
  }

  export type PurchaseInvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    purchaseOrderItemId: string | null
    grnItemId: string | null
    itemMasterId: string | null
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    unitId: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseInvoiceItemSumAggregateOutputType | null
    _min: PurchaseInvoiceItemMinAggregateOutputType | null
    _max: PurchaseInvoiceItemMaxAggregateOutputType | null
  }

  type GetPurchaseInvoiceItemGroupByPayload<T extends PurchaseInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    purchaseOrderItemId?: boolean
    grnItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    unitId?: boolean
    invoicedQty?: boolean
    rate?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseInvoiceItem$purchaseOrderItemArgs<ExtArgs>
    grnItem?: boolean | PurchaseInvoiceItem$grnItemArgs<ExtArgs>
    itemMaster?: boolean | PurchaseInvoiceItem$itemMasterArgs<ExtArgs>
    color?: boolean | PurchaseInvoiceItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseInvoiceItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseInvoiceItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseInvoiceItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>

  export type PurchaseInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    purchaseOrderItemId?: boolean
    grnItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    unitId?: boolean
    invoicedQty?: boolean
    rate?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseInvoiceItem$purchaseOrderItemArgs<ExtArgs>
    grnItem?: boolean | PurchaseInvoiceItem$grnItemArgs<ExtArgs>
    itemMaster?: boolean | PurchaseInvoiceItem$itemMasterArgs<ExtArgs>
    color?: boolean | PurchaseInvoiceItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseInvoiceItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseInvoiceItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseInvoiceItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>

  export type PurchaseInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    purchaseOrderItemId?: boolean
    grnItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    unitId?: boolean
    invoicedQty?: boolean
    rate?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseInvoiceItem$purchaseOrderItemArgs<ExtArgs>
    grnItem?: boolean | PurchaseInvoiceItem$grnItemArgs<ExtArgs>
    itemMaster?: boolean | PurchaseInvoiceItem$itemMasterArgs<ExtArgs>
    color?: boolean | PurchaseInvoiceItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseInvoiceItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseInvoiceItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseInvoiceItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>

  export type PurchaseInvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    purchaseOrderItemId?: boolean
    grnItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    unitId?: boolean
    invoicedQty?: boolean
    rate?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "purchaseOrderItemId" | "grnItemId" | "itemMasterId" | "colorId" | "brandId" | "itemGradeId" | "unitId" | "invoicedQty" | "rate" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseInvoiceItem"]>
  export type PurchaseInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseInvoiceItem$purchaseOrderItemArgs<ExtArgs>
    grnItem?: boolean | PurchaseInvoiceItem$grnItemArgs<ExtArgs>
    itemMaster?: boolean | PurchaseInvoiceItem$itemMasterArgs<ExtArgs>
    color?: boolean | PurchaseInvoiceItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseInvoiceItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseInvoiceItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseInvoiceItem$unitArgs<ExtArgs>
  }
  export type PurchaseInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseInvoiceItem$purchaseOrderItemArgs<ExtArgs>
    grnItem?: boolean | PurchaseInvoiceItem$grnItemArgs<ExtArgs>
    itemMaster?: boolean | PurchaseInvoiceItem$itemMasterArgs<ExtArgs>
    color?: boolean | PurchaseInvoiceItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseInvoiceItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseInvoiceItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseInvoiceItem$unitArgs<ExtArgs>
  }
  export type PurchaseInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    purchaseOrderItem?: boolean | PurchaseInvoiceItem$purchaseOrderItemArgs<ExtArgs>
    grnItem?: boolean | PurchaseInvoiceItem$grnItemArgs<ExtArgs>
    itemMaster?: boolean | PurchaseInvoiceItem$itemMasterArgs<ExtArgs>
    color?: boolean | PurchaseInvoiceItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseInvoiceItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseInvoiceItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseInvoiceItem$unitArgs<ExtArgs>
  }

  export type $PurchaseInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseInvoiceItem"
    objects: {
      invoice: Prisma.$PurchaseInvoicePayload<ExtArgs>
      purchaseOrderItem: Prisma.$PurchaseOrderItemPayload<ExtArgs> | null
      grnItem: Prisma.$GRNItemPayload<ExtArgs> | null
      itemMaster: Prisma.$ItemMasterPayload<ExtArgs> | null
      color: Prisma.$ColorPayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs> | null
      itemGrade: Prisma.$ItemGradePayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      purchaseOrderItemId: string | null
      grnItemId: string | null
      itemMasterId: string | null
      colorId: string | null
      brandId: string | null
      itemGradeId: string | null
      unitId: number | null
      invoicedQty: number
      rate: number
      amount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseInvoiceItem"]>
    composites: {}
  }

  type PurchaseInvoiceItemGetPayload<S extends boolean | null | undefined | PurchaseInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseInvoiceItemPayload, S>

  type PurchaseInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseInvoiceItemCountAggregateInputType | true
    }

  export interface PurchaseInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseInvoiceItem'], meta: { name: 'PurchaseInvoiceItem' } }
    /**
     * Find zero or one PurchaseInvoiceItem that matches the filter.
     * @param {PurchaseInvoiceItemFindUniqueArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseInvoiceItemFindUniqueArgs>(args: SelectSubset<T, PurchaseInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindFirstArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseInvoiceItemFindFirstArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseInvoiceItems
     * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany()
     * 
     * // Get first 10 PurchaseInvoiceItems
     * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseInvoiceItemFindManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemCreateArgs} args - Arguments to create a PurchaseInvoiceItem.
     * @example
     * // Create one PurchaseInvoiceItem
     * const PurchaseInvoiceItem = await prisma.purchaseInvoiceItem.create({
     *   data: {
     *     // ... data to create a PurchaseInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseInvoiceItemCreateArgs>(args: SelectSubset<T, PurchaseInvoiceItemCreateArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseInvoiceItems.
     * @param {PurchaseInvoiceItemCreateManyArgs} args - Arguments to create many PurchaseInvoiceItems.
     * @example
     * // Create many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseInvoiceItemCreateManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseInvoiceItems and returns the data saved in the database.
     * @param {PurchaseInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseInvoiceItems.
     * @example
     * // Create many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseInvoiceItems and only return the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemDeleteArgs} args - Arguments to delete one PurchaseInvoiceItem.
     * @example
     * // Delete one PurchaseInvoiceItem
     * const PurchaseInvoiceItem = await prisma.purchaseInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseInvoiceItemDeleteArgs>(args: SelectSubset<T, PurchaseInvoiceItemDeleteArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemUpdateArgs} args - Arguments to update one PurchaseInvoiceItem.
     * @example
     * // Update one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseInvoiceItemUpdateArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseInvoiceItems.
     * @param {PurchaseInvoiceItemDeleteManyArgs} args - Arguments to filter PurchaseInvoiceItems to delete.
     * @example
     * // Delete a few PurchaseInvoiceItems
     * const { count } = await prisma.purchaseInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseInvoiceItemUpdateManyArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoiceItems and returns the data updated in the database.
     * @param {PurchaseInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseInvoiceItems.
     * @example
     * // Update many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseInvoiceItems and only return the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemUpsertArgs} args - Arguments to update or create a PurchaseInvoiceItem.
     * @example
     * // Update or create a PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseInvoiceItemUpsertArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpsertArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemCountArgs} args - Arguments to filter PurchaseInvoiceItems to count.
     * @example
     * // Count the number of PurchaseInvoiceItems
     * const count = await prisma.purchaseInvoiceItem.count({
     *   where: {
     *     // ... the filter for the PurchaseInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseInvoiceItemCountArgs>(
      args?: Subset<T, PurchaseInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseInvoiceItemAggregateArgs>(args: Subset<T, PurchaseInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseInvoiceItemAggregateType<T>>

    /**
     * Group by PurchaseInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseInvoiceItem model
   */
  readonly fields: PurchaseInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends PurchaseInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceDefaultArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseOrderItem<T extends PurchaseInvoiceItem$purchaseOrderItemArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceItem$purchaseOrderItemArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    grnItem<T extends PurchaseInvoiceItem$grnItemArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceItem$grnItemArgs<ExtArgs>>): Prisma__GRNItemClient<$Result.GetResult<Prisma.$GRNItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itemMaster<T extends PurchaseInvoiceItem$itemMasterArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceItem$itemMasterArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    color<T extends PurchaseInvoiceItem$colorArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceItem$colorArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    brand<T extends PurchaseInvoiceItem$brandArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceItem$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itemGrade<T extends PurchaseInvoiceItem$itemGradeArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceItem$itemGradeArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unit<T extends PurchaseInvoiceItem$unitArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceItem$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseInvoiceItem model
   */
  interface PurchaseInvoiceItemFieldRefs {
    readonly id: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly purchaseOrderItemId: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly grnItemId: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly itemMasterId: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly colorId: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly brandId: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly itemGradeId: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly unitId: FieldRef<"PurchaseInvoiceItem", 'Int'>
    readonly invoicedQty: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly rate: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly amount: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly createdAt: FieldRef<"PurchaseInvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseInvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseInvoiceItem findUnique
   */
  export type PurchaseInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem findUniqueOrThrow
   */
  export type PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem findFirst
   */
  export type PurchaseInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoiceItems.
     */
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem findFirstOrThrow
   */
  export type PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoiceItems.
     */
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem findMany
   */
  export type PurchaseInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItems to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem create
   */
  export type PurchaseInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseInvoiceItem.
     */
    data: XOR<PurchaseInvoiceItemCreateInput, PurchaseInvoiceItemUncheckedCreateInput>
  }

  /**
   * PurchaseInvoiceItem createMany
   */
  export type PurchaseInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseInvoiceItems.
     */
    data: PurchaseInvoiceItemCreateManyInput | PurchaseInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseInvoiceItem createManyAndReturn
   */
  export type PurchaseInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseInvoiceItems.
     */
    data: PurchaseInvoiceItemCreateManyInput | PurchaseInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceItem update
   */
  export type PurchaseInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseInvoiceItem.
     */
    data: XOR<PurchaseInvoiceItemUpdateInput, PurchaseInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseInvoiceItem to update.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem updateMany
   */
  export type PurchaseInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseInvoiceItems.
     */
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoiceItems to update
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseInvoiceItem updateManyAndReturn
   */
  export type PurchaseInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseInvoiceItems.
     */
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoiceItems to update
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceItem upsert
   */
  export type PurchaseInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseInvoiceItem to update in case it exists.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
    /**
     * In case the PurchaseInvoiceItem found by the `where` argument doesn't exist, create a new PurchaseInvoiceItem with this data.
     */
    create: XOR<PurchaseInvoiceItemCreateInput, PurchaseInvoiceItemUncheckedCreateInput>
    /**
     * In case the PurchaseInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseInvoiceItemUpdateInput, PurchaseInvoiceItemUncheckedUpdateInput>
  }

  /**
   * PurchaseInvoiceItem delete
   */
  export type PurchaseInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseInvoiceItem to delete.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem deleteMany
   */
  export type PurchaseInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoiceItems to delete
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseInvoiceItem.purchaseOrderItem
   */
  export type PurchaseInvoiceItem$purchaseOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrderItem
     */
    omit?: PurchaseOrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseInvoiceItem.grnItem
   */
  export type PurchaseInvoiceItem$grnItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRNItem
     */
    select?: GRNItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRNItem
     */
    omit?: GRNItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNItemInclude<ExtArgs> | null
    where?: GRNItemWhereInput
  }

  /**
   * PurchaseInvoiceItem.itemMaster
   */
  export type PurchaseInvoiceItem$itemMasterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemMaster
     */
    select?: ItemMasterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemMaster
     */
    omit?: ItemMasterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemMasterInclude<ExtArgs> | null
    where?: ItemMasterWhereInput
  }

  /**
   * PurchaseInvoiceItem.color
   */
  export type PurchaseInvoiceItem$colorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    where?: ColorWhereInput
  }

  /**
   * PurchaseInvoiceItem.brand
   */
  export type PurchaseInvoiceItem$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * PurchaseInvoiceItem.itemGrade
   */
  export type PurchaseInvoiceItem$itemGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    where?: ItemGradeWhereInput
  }

  /**
   * PurchaseInvoiceItem.unit
   */
  export type PurchaseInvoiceItem$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * PurchaseInvoiceItem without action
   */
  export type PurchaseInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseReturn
   */

  export type AggregatePurchaseReturn = {
    _count: PurchaseReturnCountAggregateOutputType | null
    _avg: PurchaseReturnAvgAggregateOutputType | null
    _sum: PurchaseReturnSumAggregateOutputType | null
    _min: PurchaseReturnMinAggregateOutputType | null
    _max: PurchaseReturnMaxAggregateOutputType | null
  }

  export type PurchaseReturnAvgAggregateOutputType = {
    accountId: number | null
    totalAmount: number | null
    companyId: number | null
  }

  export type PurchaseReturnSumAggregateOutputType = {
    accountId: number | null
    totalAmount: number | null
    companyId: number | null
  }

  export type PurchaseReturnMinAggregateOutputType = {
    id: string | null
    returnNumber: string | null
    date: Date | null
    remarks: string | null
    purchaseInvoiceId: string | null
    grnId: string | null
    accountId: number | null
    totalAmount: number | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseReturnMaxAggregateOutputType = {
    id: string | null
    returnNumber: string | null
    date: Date | null
    remarks: string | null
    purchaseInvoiceId: string | null
    grnId: string | null
    accountId: number | null
    totalAmount: number | null
    status: string | null
    companyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseReturnCountAggregateOutputType = {
    id: number
    returnNumber: number
    date: number
    remarks: number
    purchaseInvoiceId: number
    grnId: number
    accountId: number
    totalAmount: number
    status: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseReturnAvgAggregateInputType = {
    accountId?: true
    totalAmount?: true
    companyId?: true
  }

  export type PurchaseReturnSumAggregateInputType = {
    accountId?: true
    totalAmount?: true
    companyId?: true
  }

  export type PurchaseReturnMinAggregateInputType = {
    id?: true
    returnNumber?: true
    date?: true
    remarks?: true
    purchaseInvoiceId?: true
    grnId?: true
    accountId?: true
    totalAmount?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseReturnMaxAggregateInputType = {
    id?: true
    returnNumber?: true
    date?: true
    remarks?: true
    purchaseInvoiceId?: true
    grnId?: true
    accountId?: true
    totalAmount?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseReturnCountAggregateInputType = {
    id?: true
    returnNumber?: true
    date?: true
    remarks?: true
    purchaseInvoiceId?: true
    grnId?: true
    accountId?: true
    totalAmount?: true
    status?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseReturnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturn to aggregate.
     */
    where?: PurchaseReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturns to fetch.
     */
    orderBy?: PurchaseReturnOrderByWithRelationInput | PurchaseReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseReturns
    **/
    _count?: true | PurchaseReturnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseReturnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseReturnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseReturnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseReturnMaxAggregateInputType
  }

  export type GetPurchaseReturnAggregateType<T extends PurchaseReturnAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseReturn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseReturn[P]>
      : GetScalarType<T[P], AggregatePurchaseReturn[P]>
  }




  export type PurchaseReturnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnWhereInput
    orderBy?: PurchaseReturnOrderByWithAggregationInput | PurchaseReturnOrderByWithAggregationInput[]
    by: PurchaseReturnScalarFieldEnum[] | PurchaseReturnScalarFieldEnum
    having?: PurchaseReturnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseReturnCountAggregateInputType | true
    _avg?: PurchaseReturnAvgAggregateInputType
    _sum?: PurchaseReturnSumAggregateInputType
    _min?: PurchaseReturnMinAggregateInputType
    _max?: PurchaseReturnMaxAggregateInputType
  }

  export type PurchaseReturnGroupByOutputType = {
    id: string
    returnNumber: string
    date: Date
    remarks: string | null
    purchaseInvoiceId: string | null
    grnId: string | null
    accountId: number | null
    totalAmount: number
    status: string
    companyId: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseReturnCountAggregateOutputType | null
    _avg: PurchaseReturnAvgAggregateOutputType | null
    _sum: PurchaseReturnSumAggregateOutputType | null
    _min: PurchaseReturnMinAggregateOutputType | null
    _max: PurchaseReturnMaxAggregateOutputType | null
  }

  type GetPurchaseReturnGroupByPayload<T extends PurchaseReturnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseReturnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseReturnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseReturnGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseReturnGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseReturnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNumber?: boolean
    date?: boolean
    remarks?: boolean
    purchaseInvoiceId?: boolean
    grnId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseInvoice?: boolean | PurchaseReturn$purchaseInvoiceArgs<ExtArgs>
    grn?: boolean | PurchaseReturn$grnArgs<ExtArgs>
    account?: boolean | PurchaseReturn$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | PurchaseReturn$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseReturnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturn"]>

  export type PurchaseReturnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNumber?: boolean
    date?: boolean
    remarks?: boolean
    purchaseInvoiceId?: boolean
    grnId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseInvoice?: boolean | PurchaseReturn$purchaseInvoiceArgs<ExtArgs>
    grn?: boolean | PurchaseReturn$grnArgs<ExtArgs>
    account?: boolean | PurchaseReturn$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturn"]>

  export type PurchaseReturnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNumber?: boolean
    date?: boolean
    remarks?: boolean
    purchaseInvoiceId?: boolean
    grnId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseInvoice?: boolean | PurchaseReturn$purchaseInvoiceArgs<ExtArgs>
    grn?: boolean | PurchaseReturn$grnArgs<ExtArgs>
    account?: boolean | PurchaseReturn$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturn"]>

  export type PurchaseReturnSelectScalar = {
    id?: boolean
    returnNumber?: boolean
    date?: boolean
    remarks?: boolean
    purchaseInvoiceId?: boolean
    grnId?: boolean
    accountId?: boolean
    totalAmount?: boolean
    status?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseReturnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "returnNumber" | "date" | "remarks" | "purchaseInvoiceId" | "grnId" | "accountId" | "totalAmount" | "status" | "companyId" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseReturn"]>
  export type PurchaseReturnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseInvoice?: boolean | PurchaseReturn$purchaseInvoiceArgs<ExtArgs>
    grn?: boolean | PurchaseReturn$grnArgs<ExtArgs>
    account?: boolean | PurchaseReturn$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    items?: boolean | PurchaseReturn$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseReturnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseReturnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseInvoice?: boolean | PurchaseReturn$purchaseInvoiceArgs<ExtArgs>
    grn?: boolean | PurchaseReturn$grnArgs<ExtArgs>
    account?: boolean | PurchaseReturn$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type PurchaseReturnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseInvoice?: boolean | PurchaseReturn$purchaseInvoiceArgs<ExtArgs>
    grn?: boolean | PurchaseReturn$grnArgs<ExtArgs>
    account?: boolean | PurchaseReturn$accountArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $PurchaseReturnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseReturn"
    objects: {
      purchaseInvoice: Prisma.$PurchaseInvoicePayload<ExtArgs> | null
      grn: Prisma.$GRNPayload<ExtArgs> | null
      account: Prisma.$AccountPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      items: Prisma.$PurchaseReturnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      returnNumber: string
      date: Date
      remarks: string | null
      purchaseInvoiceId: string | null
      grnId: string | null
      accountId: number | null
      totalAmount: number
      status: string
      companyId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseReturn"]>
    composites: {}
  }

  type PurchaseReturnGetPayload<S extends boolean | null | undefined | PurchaseReturnDefaultArgs> = $Result.GetResult<Prisma.$PurchaseReturnPayload, S>

  type PurchaseReturnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseReturnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseReturnCountAggregateInputType | true
    }

  export interface PurchaseReturnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseReturn'], meta: { name: 'PurchaseReturn' } }
    /**
     * Find zero or one PurchaseReturn that matches the filter.
     * @param {PurchaseReturnFindUniqueArgs} args - Arguments to find a PurchaseReturn
     * @example
     * // Get one PurchaseReturn
     * const purchaseReturn = await prisma.purchaseReturn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseReturnFindUniqueArgs>(args: SelectSubset<T, PurchaseReturnFindUniqueArgs<ExtArgs>>): Prisma__PurchaseReturnClient<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseReturn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseReturnFindUniqueOrThrowArgs} args - Arguments to find a PurchaseReturn
     * @example
     * // Get one PurchaseReturn
     * const purchaseReturn = await prisma.purchaseReturn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseReturnFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseReturnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnClient<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnFindFirstArgs} args - Arguments to find a PurchaseReturn
     * @example
     * // Get one PurchaseReturn
     * const purchaseReturn = await prisma.purchaseReturn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseReturnFindFirstArgs>(args?: SelectSubset<T, PurchaseReturnFindFirstArgs<ExtArgs>>): Prisma__PurchaseReturnClient<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnFindFirstOrThrowArgs} args - Arguments to find a PurchaseReturn
     * @example
     * // Get one PurchaseReturn
     * const purchaseReturn = await prisma.purchaseReturn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseReturnFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseReturnFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnClient<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseReturns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseReturns
     * const purchaseReturns = await prisma.purchaseReturn.findMany()
     * 
     * // Get first 10 PurchaseReturns
     * const purchaseReturns = await prisma.purchaseReturn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseReturnWithIdOnly = await prisma.purchaseReturn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseReturnFindManyArgs>(args?: SelectSubset<T, PurchaseReturnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseReturn.
     * @param {PurchaseReturnCreateArgs} args - Arguments to create a PurchaseReturn.
     * @example
     * // Create one PurchaseReturn
     * const PurchaseReturn = await prisma.purchaseReturn.create({
     *   data: {
     *     // ... data to create a PurchaseReturn
     *   }
     * })
     * 
     */
    create<T extends PurchaseReturnCreateArgs>(args: SelectSubset<T, PurchaseReturnCreateArgs<ExtArgs>>): Prisma__PurchaseReturnClient<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseReturns.
     * @param {PurchaseReturnCreateManyArgs} args - Arguments to create many PurchaseReturns.
     * @example
     * // Create many PurchaseReturns
     * const purchaseReturn = await prisma.purchaseReturn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseReturnCreateManyArgs>(args?: SelectSubset<T, PurchaseReturnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseReturns and returns the data saved in the database.
     * @param {PurchaseReturnCreateManyAndReturnArgs} args - Arguments to create many PurchaseReturns.
     * @example
     * // Create many PurchaseReturns
     * const purchaseReturn = await prisma.purchaseReturn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseReturns and only return the `id`
     * const purchaseReturnWithIdOnly = await prisma.purchaseReturn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseReturnCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseReturnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseReturn.
     * @param {PurchaseReturnDeleteArgs} args - Arguments to delete one PurchaseReturn.
     * @example
     * // Delete one PurchaseReturn
     * const PurchaseReturn = await prisma.purchaseReturn.delete({
     *   where: {
     *     // ... filter to delete one PurchaseReturn
     *   }
     * })
     * 
     */
    delete<T extends PurchaseReturnDeleteArgs>(args: SelectSubset<T, PurchaseReturnDeleteArgs<ExtArgs>>): Prisma__PurchaseReturnClient<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseReturn.
     * @param {PurchaseReturnUpdateArgs} args - Arguments to update one PurchaseReturn.
     * @example
     * // Update one PurchaseReturn
     * const purchaseReturn = await prisma.purchaseReturn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseReturnUpdateArgs>(args: SelectSubset<T, PurchaseReturnUpdateArgs<ExtArgs>>): Prisma__PurchaseReturnClient<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseReturns.
     * @param {PurchaseReturnDeleteManyArgs} args - Arguments to filter PurchaseReturns to delete.
     * @example
     * // Delete a few PurchaseReturns
     * const { count } = await prisma.purchaseReturn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseReturnDeleteManyArgs>(args?: SelectSubset<T, PurchaseReturnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseReturns
     * const purchaseReturn = await prisma.purchaseReturn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseReturnUpdateManyArgs>(args: SelectSubset<T, PurchaseReturnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturns and returns the data updated in the database.
     * @param {PurchaseReturnUpdateManyAndReturnArgs} args - Arguments to update many PurchaseReturns.
     * @example
     * // Update many PurchaseReturns
     * const purchaseReturn = await prisma.purchaseReturn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseReturns and only return the `id`
     * const purchaseReturnWithIdOnly = await prisma.purchaseReturn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseReturnUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseReturnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseReturn.
     * @param {PurchaseReturnUpsertArgs} args - Arguments to update or create a PurchaseReturn.
     * @example
     * // Update or create a PurchaseReturn
     * const purchaseReturn = await prisma.purchaseReturn.upsert({
     *   create: {
     *     // ... data to create a PurchaseReturn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseReturn we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseReturnUpsertArgs>(args: SelectSubset<T, PurchaseReturnUpsertArgs<ExtArgs>>): Prisma__PurchaseReturnClient<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseReturns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnCountArgs} args - Arguments to filter PurchaseReturns to count.
     * @example
     * // Count the number of PurchaseReturns
     * const count = await prisma.purchaseReturn.count({
     *   where: {
     *     // ... the filter for the PurchaseReturns we want to count
     *   }
     * })
    **/
    count<T extends PurchaseReturnCountArgs>(
      args?: Subset<T, PurchaseReturnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseReturnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseReturnAggregateArgs>(args: Subset<T, PurchaseReturnAggregateArgs>): Prisma.PrismaPromise<GetPurchaseReturnAggregateType<T>>

    /**
     * Group by PurchaseReturn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseReturnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseReturnGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseReturnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseReturnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseReturnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseReturn model
   */
  readonly fields: PurchaseReturnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseReturn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseReturnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseInvoice<T extends PurchaseReturn$purchaseInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturn$purchaseInvoiceArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    grn<T extends PurchaseReturn$grnArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturn$grnArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    account<T extends PurchaseReturn$accountArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturn$accountArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseReturn$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturn$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseReturn model
   */
  interface PurchaseReturnFieldRefs {
    readonly id: FieldRef<"PurchaseReturn", 'String'>
    readonly returnNumber: FieldRef<"PurchaseReturn", 'String'>
    readonly date: FieldRef<"PurchaseReturn", 'DateTime'>
    readonly remarks: FieldRef<"PurchaseReturn", 'String'>
    readonly purchaseInvoiceId: FieldRef<"PurchaseReturn", 'String'>
    readonly grnId: FieldRef<"PurchaseReturn", 'String'>
    readonly accountId: FieldRef<"PurchaseReturn", 'Int'>
    readonly totalAmount: FieldRef<"PurchaseReturn", 'Float'>
    readonly status: FieldRef<"PurchaseReturn", 'String'>
    readonly companyId: FieldRef<"PurchaseReturn", 'Int'>
    readonly createdAt: FieldRef<"PurchaseReturn", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseReturn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseReturn findUnique
   */
  export type PurchaseReturnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturn to fetch.
     */
    where: PurchaseReturnWhereUniqueInput
  }

  /**
   * PurchaseReturn findUniqueOrThrow
   */
  export type PurchaseReturnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturn to fetch.
     */
    where: PurchaseReturnWhereUniqueInput
  }

  /**
   * PurchaseReturn findFirst
   */
  export type PurchaseReturnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturn to fetch.
     */
    where?: PurchaseReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturns to fetch.
     */
    orderBy?: PurchaseReturnOrderByWithRelationInput | PurchaseReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturns.
     */
    cursor?: PurchaseReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturns.
     */
    distinct?: PurchaseReturnScalarFieldEnum | PurchaseReturnScalarFieldEnum[]
  }

  /**
   * PurchaseReturn findFirstOrThrow
   */
  export type PurchaseReturnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturn to fetch.
     */
    where?: PurchaseReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturns to fetch.
     */
    orderBy?: PurchaseReturnOrderByWithRelationInput | PurchaseReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturns.
     */
    cursor?: PurchaseReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturns.
     */
    distinct?: PurchaseReturnScalarFieldEnum | PurchaseReturnScalarFieldEnum[]
  }

  /**
   * PurchaseReturn findMany
   */
  export type PurchaseReturnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturns to fetch.
     */
    where?: PurchaseReturnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturns to fetch.
     */
    orderBy?: PurchaseReturnOrderByWithRelationInput | PurchaseReturnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseReturns.
     */
    cursor?: PurchaseReturnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturns.
     */
    skip?: number
    distinct?: PurchaseReturnScalarFieldEnum | PurchaseReturnScalarFieldEnum[]
  }

  /**
   * PurchaseReturn create
   */
  export type PurchaseReturnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseReturn.
     */
    data: XOR<PurchaseReturnCreateInput, PurchaseReturnUncheckedCreateInput>
  }

  /**
   * PurchaseReturn createMany
   */
  export type PurchaseReturnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseReturns.
     */
    data: PurchaseReturnCreateManyInput | PurchaseReturnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseReturn createManyAndReturn
   */
  export type PurchaseReturnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseReturns.
     */
    data: PurchaseReturnCreateManyInput | PurchaseReturnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturn update
   */
  export type PurchaseReturnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseReturn.
     */
    data: XOR<PurchaseReturnUpdateInput, PurchaseReturnUncheckedUpdateInput>
    /**
     * Choose, which PurchaseReturn to update.
     */
    where: PurchaseReturnWhereUniqueInput
  }

  /**
   * PurchaseReturn updateMany
   */
  export type PurchaseReturnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseReturns.
     */
    data: XOR<PurchaseReturnUpdateManyMutationInput, PurchaseReturnUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturns to update
     */
    where?: PurchaseReturnWhereInput
    /**
     * Limit how many PurchaseReturns to update.
     */
    limit?: number
  }

  /**
   * PurchaseReturn updateManyAndReturn
   */
  export type PurchaseReturnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseReturns.
     */
    data: XOR<PurchaseReturnUpdateManyMutationInput, PurchaseReturnUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturns to update
     */
    where?: PurchaseReturnWhereInput
    /**
     * Limit how many PurchaseReturns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturn upsert
   */
  export type PurchaseReturnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseReturn to update in case it exists.
     */
    where: PurchaseReturnWhereUniqueInput
    /**
     * In case the PurchaseReturn found by the `where` argument doesn't exist, create a new PurchaseReturn with this data.
     */
    create: XOR<PurchaseReturnCreateInput, PurchaseReturnUncheckedCreateInput>
    /**
     * In case the PurchaseReturn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseReturnUpdateInput, PurchaseReturnUncheckedUpdateInput>
  }

  /**
   * PurchaseReturn delete
   */
  export type PurchaseReturnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
    /**
     * Filter which PurchaseReturn to delete.
     */
    where: PurchaseReturnWhereUniqueInput
  }

  /**
   * PurchaseReturn deleteMany
   */
  export type PurchaseReturnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturns to delete
     */
    where?: PurchaseReturnWhereInput
    /**
     * Limit how many PurchaseReturns to delete.
     */
    limit?: number
  }

  /**
   * PurchaseReturn.purchaseInvoice
   */
  export type PurchaseReturn$purchaseInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
  }

  /**
   * PurchaseReturn.grn
   */
  export type PurchaseReturn$grnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    where?: GRNWhereInput
  }

  /**
   * PurchaseReturn.account
   */
  export type PurchaseReturn$accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * PurchaseReturn.items
   */
  export type PurchaseReturn$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    where?: PurchaseReturnItemWhereInput
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    cursor?: PurchaseReturnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnItemScalarFieldEnum | PurchaseReturnItemScalarFieldEnum[]
  }

  /**
   * PurchaseReturn without action
   */
  export type PurchaseReturnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturn
     */
    select?: PurchaseReturnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturn
     */
    omit?: PurchaseReturnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseReturnItem
   */

  export type AggregatePurchaseReturnItem = {
    _count: PurchaseReturnItemCountAggregateOutputType | null
    _avg: PurchaseReturnItemAvgAggregateOutputType | null
    _sum: PurchaseReturnItemSumAggregateOutputType | null
    _min: PurchaseReturnItemMinAggregateOutputType | null
    _max: PurchaseReturnItemMaxAggregateOutputType | null
  }

  export type PurchaseReturnItemAvgAggregateOutputType = {
    unitId: number | null
    returnedQty: number | null
    rate: number | null
    amount: number | null
  }

  export type PurchaseReturnItemSumAggregateOutputType = {
    unitId: number | null
    returnedQty: number | null
    rate: number | null
    amount: number | null
  }

  export type PurchaseReturnItemMinAggregateOutputType = {
    id: string | null
    returnId: string | null
    purchaseInvoiceItemId: string | null
    grnItemId: string | null
    itemMasterId: string | null
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    unitId: number | null
    returnedQty: number | null
    rate: number | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseReturnItemMaxAggregateOutputType = {
    id: string | null
    returnId: string | null
    purchaseInvoiceItemId: string | null
    grnItemId: string | null
    itemMasterId: string | null
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    unitId: number | null
    returnedQty: number | null
    rate: number | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseReturnItemCountAggregateOutputType = {
    id: number
    returnId: number
    purchaseInvoiceItemId: number
    grnItemId: number
    itemMasterId: number
    colorId: number
    brandId: number
    itemGradeId: number
    unitId: number
    returnedQty: number
    rate: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseReturnItemAvgAggregateInputType = {
    unitId?: true
    returnedQty?: true
    rate?: true
    amount?: true
  }

  export type PurchaseReturnItemSumAggregateInputType = {
    unitId?: true
    returnedQty?: true
    rate?: true
    amount?: true
  }

  export type PurchaseReturnItemMinAggregateInputType = {
    id?: true
    returnId?: true
    purchaseInvoiceItemId?: true
    grnItemId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    unitId?: true
    returnedQty?: true
    rate?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseReturnItemMaxAggregateInputType = {
    id?: true
    returnId?: true
    purchaseInvoiceItemId?: true
    grnItemId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    unitId?: true
    returnedQty?: true
    rate?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseReturnItemCountAggregateInputType = {
    id?: true
    returnId?: true
    purchaseInvoiceItemId?: true
    grnItemId?: true
    itemMasterId?: true
    colorId?: true
    brandId?: true
    itemGradeId?: true
    unitId?: true
    returnedQty?: true
    rate?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseReturnItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturnItem to aggregate.
     */
    where?: PurchaseReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnItems to fetch.
     */
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseReturnItems
    **/
    _count?: true | PurchaseReturnItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseReturnItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseReturnItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseReturnItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseReturnItemMaxAggregateInputType
  }

  export type GetPurchaseReturnItemAggregateType<T extends PurchaseReturnItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseReturnItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseReturnItem[P]>
      : GetScalarType<T[P], AggregatePurchaseReturnItem[P]>
  }




  export type PurchaseReturnItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnItemWhereInput
    orderBy?: PurchaseReturnItemOrderByWithAggregationInput | PurchaseReturnItemOrderByWithAggregationInput[]
    by: PurchaseReturnItemScalarFieldEnum[] | PurchaseReturnItemScalarFieldEnum
    having?: PurchaseReturnItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseReturnItemCountAggregateInputType | true
    _avg?: PurchaseReturnItemAvgAggregateInputType
    _sum?: PurchaseReturnItemSumAggregateInputType
    _min?: PurchaseReturnItemMinAggregateInputType
    _max?: PurchaseReturnItemMaxAggregateInputType
  }

  export type PurchaseReturnItemGroupByOutputType = {
    id: string
    returnId: string
    purchaseInvoiceItemId: string | null
    grnItemId: string | null
    itemMasterId: string
    colorId: string | null
    brandId: string | null
    itemGradeId: string | null
    unitId: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseReturnItemCountAggregateOutputType | null
    _avg: PurchaseReturnItemAvgAggregateOutputType | null
    _sum: PurchaseReturnItemSumAggregateOutputType | null
    _min: PurchaseReturnItemMinAggregateOutputType | null
    _max: PurchaseReturnItemMaxAggregateOutputType | null
  }

  type GetPurchaseReturnItemGroupByPayload<T extends PurchaseReturnItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseReturnItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseReturnItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseReturnItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseReturnItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseReturnItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnId?: boolean
    purchaseInvoiceItemId?: boolean
    grnItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    unitId?: boolean
    returnedQty?: boolean
    rate?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    return?: boolean | PurchaseReturnDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseReturnItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseReturnItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseReturnItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseReturnItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnItem"]>

  export type PurchaseReturnItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnId?: boolean
    purchaseInvoiceItemId?: boolean
    grnItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    unitId?: boolean
    returnedQty?: boolean
    rate?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    return?: boolean | PurchaseReturnDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseReturnItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseReturnItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseReturnItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseReturnItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnItem"]>

  export type PurchaseReturnItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnId?: boolean
    purchaseInvoiceItemId?: boolean
    grnItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    unitId?: boolean
    returnedQty?: boolean
    rate?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    return?: boolean | PurchaseReturnDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseReturnItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseReturnItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseReturnItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseReturnItem$unitArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnItem"]>

  export type PurchaseReturnItemSelectScalar = {
    id?: boolean
    returnId?: boolean
    purchaseInvoiceItemId?: boolean
    grnItemId?: boolean
    itemMasterId?: boolean
    colorId?: boolean
    brandId?: boolean
    itemGradeId?: boolean
    unitId?: boolean
    returnedQty?: boolean
    rate?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseReturnItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "returnId" | "purchaseInvoiceItemId" | "grnItemId" | "itemMasterId" | "colorId" | "brandId" | "itemGradeId" | "unitId" | "returnedQty" | "rate" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseReturnItem"]>
  export type PurchaseReturnItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    return?: boolean | PurchaseReturnDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseReturnItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseReturnItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseReturnItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseReturnItem$unitArgs<ExtArgs>
  }
  export type PurchaseReturnItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    return?: boolean | PurchaseReturnDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseReturnItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseReturnItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseReturnItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseReturnItem$unitArgs<ExtArgs>
  }
  export type PurchaseReturnItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    return?: boolean | PurchaseReturnDefaultArgs<ExtArgs>
    itemMaster?: boolean | ItemMasterDefaultArgs<ExtArgs>
    color?: boolean | PurchaseReturnItem$colorArgs<ExtArgs>
    brand?: boolean | PurchaseReturnItem$brandArgs<ExtArgs>
    itemGrade?: boolean | PurchaseReturnItem$itemGradeArgs<ExtArgs>
    unit?: boolean | PurchaseReturnItem$unitArgs<ExtArgs>
  }

  export type $PurchaseReturnItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseReturnItem"
    objects: {
      return: Prisma.$PurchaseReturnPayload<ExtArgs>
      itemMaster: Prisma.$ItemMasterPayload<ExtArgs>
      color: Prisma.$ColorPayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs> | null
      itemGrade: Prisma.$ItemGradePayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      returnId: string
      purchaseInvoiceItemId: string | null
      grnItemId: string | null
      itemMasterId: string
      colorId: string | null
      brandId: string | null
      itemGradeId: string | null
      unitId: number | null
      returnedQty: number
      rate: number
      amount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseReturnItem"]>
    composites: {}
  }

  type PurchaseReturnItemGetPayload<S extends boolean | null | undefined | PurchaseReturnItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseReturnItemPayload, S>

  type PurchaseReturnItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseReturnItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseReturnItemCountAggregateInputType | true
    }

  export interface PurchaseReturnItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseReturnItem'], meta: { name: 'PurchaseReturnItem' } }
    /**
     * Find zero or one PurchaseReturnItem that matches the filter.
     * @param {PurchaseReturnItemFindUniqueArgs} args - Arguments to find a PurchaseReturnItem
     * @example
     * // Get one PurchaseReturnItem
     * const purchaseReturnItem = await prisma.purchaseReturnItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseReturnItemFindUniqueArgs>(args: SelectSubset<T, PurchaseReturnItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseReturnItemClient<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseReturnItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseReturnItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseReturnItem
     * @example
     * // Get one PurchaseReturnItem
     * const purchaseReturnItem = await prisma.purchaseReturnItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseReturnItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseReturnItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnItemClient<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturnItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemFindFirstArgs} args - Arguments to find a PurchaseReturnItem
     * @example
     * // Get one PurchaseReturnItem
     * const purchaseReturnItem = await prisma.purchaseReturnItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseReturnItemFindFirstArgs>(args?: SelectSubset<T, PurchaseReturnItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseReturnItemClient<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturnItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseReturnItem
     * @example
     * // Get one PurchaseReturnItem
     * const purchaseReturnItem = await prisma.purchaseReturnItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseReturnItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseReturnItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnItemClient<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseReturnItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseReturnItems
     * const purchaseReturnItems = await prisma.purchaseReturnItem.findMany()
     * 
     * // Get first 10 PurchaseReturnItems
     * const purchaseReturnItems = await prisma.purchaseReturnItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseReturnItemWithIdOnly = await prisma.purchaseReturnItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseReturnItemFindManyArgs>(args?: SelectSubset<T, PurchaseReturnItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseReturnItem.
     * @param {PurchaseReturnItemCreateArgs} args - Arguments to create a PurchaseReturnItem.
     * @example
     * // Create one PurchaseReturnItem
     * const PurchaseReturnItem = await prisma.purchaseReturnItem.create({
     *   data: {
     *     // ... data to create a PurchaseReturnItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseReturnItemCreateArgs>(args: SelectSubset<T, PurchaseReturnItemCreateArgs<ExtArgs>>): Prisma__PurchaseReturnItemClient<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseReturnItems.
     * @param {PurchaseReturnItemCreateManyArgs} args - Arguments to create many PurchaseReturnItems.
     * @example
     * // Create many PurchaseReturnItems
     * const purchaseReturnItem = await prisma.purchaseReturnItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseReturnItemCreateManyArgs>(args?: SelectSubset<T, PurchaseReturnItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseReturnItems and returns the data saved in the database.
     * @param {PurchaseReturnItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseReturnItems.
     * @example
     * // Create many PurchaseReturnItems
     * const purchaseReturnItem = await prisma.purchaseReturnItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseReturnItems and only return the `id`
     * const purchaseReturnItemWithIdOnly = await prisma.purchaseReturnItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseReturnItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseReturnItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseReturnItem.
     * @param {PurchaseReturnItemDeleteArgs} args - Arguments to delete one PurchaseReturnItem.
     * @example
     * // Delete one PurchaseReturnItem
     * const PurchaseReturnItem = await prisma.purchaseReturnItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseReturnItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseReturnItemDeleteArgs>(args: SelectSubset<T, PurchaseReturnItemDeleteArgs<ExtArgs>>): Prisma__PurchaseReturnItemClient<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseReturnItem.
     * @param {PurchaseReturnItemUpdateArgs} args - Arguments to update one PurchaseReturnItem.
     * @example
     * // Update one PurchaseReturnItem
     * const purchaseReturnItem = await prisma.purchaseReturnItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseReturnItemUpdateArgs>(args: SelectSubset<T, PurchaseReturnItemUpdateArgs<ExtArgs>>): Prisma__PurchaseReturnItemClient<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseReturnItems.
     * @param {PurchaseReturnItemDeleteManyArgs} args - Arguments to filter PurchaseReturnItems to delete.
     * @example
     * // Delete a few PurchaseReturnItems
     * const { count } = await prisma.purchaseReturnItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseReturnItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseReturnItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseReturnItems
     * const purchaseReturnItem = await prisma.purchaseReturnItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseReturnItemUpdateManyArgs>(args: SelectSubset<T, PurchaseReturnItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturnItems and returns the data updated in the database.
     * @param {PurchaseReturnItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseReturnItems.
     * @example
     * // Update many PurchaseReturnItems
     * const purchaseReturnItem = await prisma.purchaseReturnItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseReturnItems and only return the `id`
     * const purchaseReturnItemWithIdOnly = await prisma.purchaseReturnItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseReturnItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseReturnItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseReturnItem.
     * @param {PurchaseReturnItemUpsertArgs} args - Arguments to update or create a PurchaseReturnItem.
     * @example
     * // Update or create a PurchaseReturnItem
     * const purchaseReturnItem = await prisma.purchaseReturnItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseReturnItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseReturnItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseReturnItemUpsertArgs>(args: SelectSubset<T, PurchaseReturnItemUpsertArgs<ExtArgs>>): Prisma__PurchaseReturnItemClient<$Result.GetResult<Prisma.$PurchaseReturnItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseReturnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemCountArgs} args - Arguments to filter PurchaseReturnItems to count.
     * @example
     * // Count the number of PurchaseReturnItems
     * const count = await prisma.purchaseReturnItem.count({
     *   where: {
     *     // ... the filter for the PurchaseReturnItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseReturnItemCountArgs>(
      args?: Subset<T, PurchaseReturnItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseReturnItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseReturnItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseReturnItemAggregateArgs>(args: Subset<T, PurchaseReturnItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseReturnItemAggregateType<T>>

    /**
     * Group by PurchaseReturnItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseReturnItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseReturnItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseReturnItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseReturnItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseReturnItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseReturnItem model
   */
  readonly fields: PurchaseReturnItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseReturnItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseReturnItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    return<T extends PurchaseReturnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturnDefaultArgs<ExtArgs>>): Prisma__PurchaseReturnClient<$Result.GetResult<Prisma.$PurchaseReturnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    itemMaster<T extends ItemMasterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemMasterDefaultArgs<ExtArgs>>): Prisma__ItemMasterClient<$Result.GetResult<Prisma.$ItemMasterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    color<T extends PurchaseReturnItem$colorArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturnItem$colorArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    brand<T extends PurchaseReturnItem$brandArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturnItem$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itemGrade<T extends PurchaseReturnItem$itemGradeArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturnItem$itemGradeArgs<ExtArgs>>): Prisma__ItemGradeClient<$Result.GetResult<Prisma.$ItemGradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unit<T extends PurchaseReturnItem$unitArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturnItem$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseReturnItem model
   */
  interface PurchaseReturnItemFieldRefs {
    readonly id: FieldRef<"PurchaseReturnItem", 'String'>
    readonly returnId: FieldRef<"PurchaseReturnItem", 'String'>
    readonly purchaseInvoiceItemId: FieldRef<"PurchaseReturnItem", 'String'>
    readonly grnItemId: FieldRef<"PurchaseReturnItem", 'String'>
    readonly itemMasterId: FieldRef<"PurchaseReturnItem", 'String'>
    readonly colorId: FieldRef<"PurchaseReturnItem", 'String'>
    readonly brandId: FieldRef<"PurchaseReturnItem", 'String'>
    readonly itemGradeId: FieldRef<"PurchaseReturnItem", 'String'>
    readonly unitId: FieldRef<"PurchaseReturnItem", 'Int'>
    readonly returnedQty: FieldRef<"PurchaseReturnItem", 'Float'>
    readonly rate: FieldRef<"PurchaseReturnItem", 'Float'>
    readonly amount: FieldRef<"PurchaseReturnItem", 'Float'>
    readonly createdAt: FieldRef<"PurchaseReturnItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseReturnItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseReturnItem findUnique
   */
  export type PurchaseReturnItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItem to fetch.
     */
    where: PurchaseReturnItemWhereUniqueInput
  }

  /**
   * PurchaseReturnItem findUniqueOrThrow
   */
  export type PurchaseReturnItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItem to fetch.
     */
    where: PurchaseReturnItemWhereUniqueInput
  }

  /**
   * PurchaseReturnItem findFirst
   */
  export type PurchaseReturnItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItem to fetch.
     */
    where?: PurchaseReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnItems to fetch.
     */
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturnItems.
     */
    cursor?: PurchaseReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturnItems.
     */
    distinct?: PurchaseReturnItemScalarFieldEnum | PurchaseReturnItemScalarFieldEnum[]
  }

  /**
   * PurchaseReturnItem findFirstOrThrow
   */
  export type PurchaseReturnItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItem to fetch.
     */
    where?: PurchaseReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnItems to fetch.
     */
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturnItems.
     */
    cursor?: PurchaseReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturnItems.
     */
    distinct?: PurchaseReturnItemScalarFieldEnum | PurchaseReturnItemScalarFieldEnum[]
  }

  /**
   * PurchaseReturnItem findMany
   */
  export type PurchaseReturnItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnItems to fetch.
     */
    where?: PurchaseReturnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnItems to fetch.
     */
    orderBy?: PurchaseReturnItemOrderByWithRelationInput | PurchaseReturnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseReturnItems.
     */
    cursor?: PurchaseReturnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnItems.
     */
    skip?: number
    distinct?: PurchaseReturnItemScalarFieldEnum | PurchaseReturnItemScalarFieldEnum[]
  }

  /**
   * PurchaseReturnItem create
   */
  export type PurchaseReturnItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseReturnItem.
     */
    data: XOR<PurchaseReturnItemCreateInput, PurchaseReturnItemUncheckedCreateInput>
  }

  /**
   * PurchaseReturnItem createMany
   */
  export type PurchaseReturnItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseReturnItems.
     */
    data: PurchaseReturnItemCreateManyInput | PurchaseReturnItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseReturnItem createManyAndReturn
   */
  export type PurchaseReturnItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseReturnItems.
     */
    data: PurchaseReturnItemCreateManyInput | PurchaseReturnItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturnItem update
   */
  export type PurchaseReturnItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseReturnItem.
     */
    data: XOR<PurchaseReturnItemUpdateInput, PurchaseReturnItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseReturnItem to update.
     */
    where: PurchaseReturnItemWhereUniqueInput
  }

  /**
   * PurchaseReturnItem updateMany
   */
  export type PurchaseReturnItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseReturnItems.
     */
    data: XOR<PurchaseReturnItemUpdateManyMutationInput, PurchaseReturnItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturnItems to update
     */
    where?: PurchaseReturnItemWhereInput
    /**
     * Limit how many PurchaseReturnItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseReturnItem updateManyAndReturn
   */
  export type PurchaseReturnItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseReturnItems.
     */
    data: XOR<PurchaseReturnItemUpdateManyMutationInput, PurchaseReturnItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturnItems to update
     */
    where?: PurchaseReturnItemWhereInput
    /**
     * Limit how many PurchaseReturnItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturnItem upsert
   */
  export type PurchaseReturnItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseReturnItem to update in case it exists.
     */
    where: PurchaseReturnItemWhereUniqueInput
    /**
     * In case the PurchaseReturnItem found by the `where` argument doesn't exist, create a new PurchaseReturnItem with this data.
     */
    create: XOR<PurchaseReturnItemCreateInput, PurchaseReturnItemUncheckedCreateInput>
    /**
     * In case the PurchaseReturnItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseReturnItemUpdateInput, PurchaseReturnItemUncheckedUpdateInput>
  }

  /**
   * PurchaseReturnItem delete
   */
  export type PurchaseReturnItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseReturnItem to delete.
     */
    where: PurchaseReturnItemWhereUniqueInput
  }

  /**
   * PurchaseReturnItem deleteMany
   */
  export type PurchaseReturnItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturnItems to delete
     */
    where?: PurchaseReturnItemWhereInput
    /**
     * Limit how many PurchaseReturnItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseReturnItem.color
   */
  export type PurchaseReturnItem$colorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    where?: ColorWhereInput
  }

  /**
   * PurchaseReturnItem.brand
   */
  export type PurchaseReturnItem$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * PurchaseReturnItem.itemGrade
   */
  export type PurchaseReturnItem$itemGradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemGrade
     */
    select?: ItemGradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemGrade
     */
    omit?: ItemGradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemGradeInclude<ExtArgs> | null
    where?: ItemGradeWhereInput
  }

  /**
   * PurchaseReturnItem.unit
   */
  export type PurchaseReturnItem$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * PurchaseReturnItem without action
   */
  export type PurchaseReturnItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnItem
     */
    select?: PurchaseReturnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnItem
     */
    omit?: PurchaseReturnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    image: 'image',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    firstLogin: 'firstLogin',
    forcePasswordChange: 'forcePasswordChange',
    isActive: 'isActive',
    departmentId: 'departmentId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AuditAccessScalarFieldEnum: {
    id: 'id',
    seniorId: 'seniorId',
    juniorId: 'juniorId'
  };

  export type AuditAccessScalarFieldEnum = (typeof AuditAccessScalarFieldEnum)[keyof typeof AuditAccessScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    action: 'action',
    resource: 'resource',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    roleId: 'roleId',
    permissionId: 'permissionId',
    assignedAt: 'assignedAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId',
    assignedAt: 'assignedAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    published: 'published',
    authorId: 'authorId'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    isRevoked: 'isRevoked',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    module: 'module',
    resourceId: 'resourceId',
    before: 'before',
    after: 'after',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const WarehouseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    contactPerson: 'contactPerson',
    contactNumbers: 'contactNumbers',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehouseScalarFieldEnum = (typeof WarehouseScalarFieldEnum)[keyof typeof WarehouseScalarFieldEnum]


  export const UserWarehouseScalarFieldEnum: {
    userId: 'userId',
    warehouseId: 'warehouseId',
    assignedAt: 'assignedAt'
  };

  export type UserWarehouseScalarFieldEnum = (typeof UserWarehouseScalarFieldEnum)[keyof typeof UserWarehouseScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    symbol: 'symbol',
    unitType: 'unitType',
    isBase: 'isBase',
    status: 'status',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const UnitConversionScalarFieldEnum: {
    id: 'id',
    fromUnitId: 'fromUnitId',
    toUnitId: 'toUnitId',
    conversionRate: 'conversionRate',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitConversionScalarFieldEnum = (typeof UnitConversionScalarFieldEnum)[keyof typeof UnitConversionScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    legalName: 'legalName',
    tradeName: 'tradeName',
    address: 'address',
    country: 'country',
    phone: 'phone',
    email: 'email',
    taxId: 'taxId',
    logoUrl: 'logoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const FiscalYearScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    isLocked: 'isLocked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FiscalYearScalarFieldEnum = (typeof FiscalYearScalarFieldEnum)[keyof typeof FiscalYearScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    symbol: 'symbol',
    isBase: 'isBase',
    exchangeRate: 'exchangeRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    quantityDecimals: 'quantityDecimals',
    amountDecimals: 'amountDecimals',
    rateDecimals: 'rateDecimals',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    key: 'key',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    type: 'type',
    categoryId: 'categoryId',
    unitId: 'unitId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const VariantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    sku: 'sku',
    productId: 'productId',
    color: 'color',
    count: 'count',
    gsm: 'gsm',
    width: 'width',
    shade: 'shade',
    weave: 'weave',
    finish: 'finish',
    type: 'type',
    price: 'price',
    stock: 'stock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VariantScalarFieldEnum = (typeof VariantScalarFieldEnum)[keyof typeof VariantScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const OperatorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    contact: 'contact',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OperatorScalarFieldEnum = (typeof OperatorScalarFieldEnum)[keyof typeof OperatorScalarFieldEnum]


  export const MachineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    type: 'type',
    status: 'status',
    locationId: 'locationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MachineScalarFieldEnum = (typeof MachineScalarFieldEnum)[keyof typeof MachineScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    type: 'type',
    parentId: 'parentId',
    level: 'level',
    isPosting: 'isPosting',
    description: 'description',
    openingBalance: 'openingBalance',
    openingBalanceType: 'openingBalanceType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const JournalEntryScalarFieldEnum: {
    id: 'id',
    number: 'number',
    date: 'date',
    type: 'type',
    reference: 'reference',
    narration: 'narration',
    status: 'status',
    fiscalYearId: 'fiscalYearId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


  export const JournalLineScalarFieldEnum: {
    id: 'id',
    entryId: 'entryId',
    accountId: 'accountId',
    debit: 'debit',
    credit: 'credit',
    narration: 'narration'
  };

  export type JournalLineScalarFieldEnum = (typeof JournalLineScalarFieldEnum)[keyof typeof JournalLineScalarFieldEnum]


  export const VoucherSequenceScalarFieldEnum: {
    id: 'id',
    type: 'type',
    prefix: 'prefix',
    nextValue: 'nextValue',
    updatedAt: 'updatedAt'
  };

  export type VoucherSequenceScalarFieldEnum = (typeof VoucherSequenceScalarFieldEnum)[keyof typeof VoucherSequenceScalarFieldEnum]


  export const ItemGroupScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    status: 'status',
    parentId: 'parentId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemGroupScalarFieldEnum = (typeof ItemGroupScalarFieldEnum)[keyof typeof ItemGroupScalarFieldEnum]


  export const ColorScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    pictureUrl: 'pictureUrl',
    status: 'status',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ColorScalarFieldEnum = (typeof ColorScalarFieldEnum)[keyof typeof ColorScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    status: 'status',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const ItemGradeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    status: 'status',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemGradeScalarFieldEnum = (typeof ItemGradeScalarFieldEnum)[keyof typeof ItemGradeScalarFieldEnum]


  export const PackingUnitScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    symbol: 'symbol',
    status: 'status',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackingUnitScalarFieldEnum = (typeof PackingUnitScalarFieldEnum)[keyof typeof PackingUnitScalarFieldEnum]


  export const ItemMasterScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    shortDescription: 'shortDescription',
    status: 'status',
    hsCode: 'hsCode',
    imageUrl: 'imageUrl',
    itemGroupId: 'itemGroupId',
    baseUnitId: 'baseUnitId',
    packingUnitId: 'packingUnitId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemMasterScalarFieldEnum = (typeof ItemMasterScalarFieldEnum)[keyof typeof ItemMasterScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    poNumber: 'poNumber',
    type: 'type',
    status: 'status',
    date: 'date',
    accountId: 'accountId',
    partyName: 'partyName',
    warehouseId: 'warehouseId',
    referenceNo: 'referenceNo',
    documentDate: 'documentDate',
    fileNo: 'fileNo',
    remarks: 'remarks',
    totalAmount: 'totalAmount',
    currencyId: 'currencyId',
    exchangeRate: 'exchangeRate',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderItemScalarFieldEnum: {
    id: 'id',
    purchaseOrderId: 'purchaseOrderId',
    itemMasterId: 'itemMasterId',
    colorId: 'colorId',
    brandId: 'brandId',
    itemGradeId: 'itemGradeId',
    packingUnitId: 'packingUnitId',
    packingType: 'packingType',
    pcs: 'pcs',
    unitSize: 'unitSize',
    quantity: 'quantity',
    unitId: 'unitId',
    rate: 'rate',
    amount: 'amount',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


  export const GRNScalarFieldEnum: {
    id: 'id',
    grnNumber: 'grnNumber',
    date: 'date',
    purchaseOrderId: 'purchaseOrderId',
    lotNo: 'lotNo',
    warehouseRefNo: 'warehouseRefNo',
    remarks: 'remarks',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GRNScalarFieldEnum = (typeof GRNScalarFieldEnum)[keyof typeof GRNScalarFieldEnum]


  export const GRNItemScalarFieldEnum: {
    id: 'id',
    grnId: 'grnId',
    purchaseOrderItemId: 'purchaseOrderItemId',
    itemMasterId: 'itemMasterId',
    colorId: 'colorId',
    brandId: 'brandId',
    itemGradeId: 'itemGradeId',
    packingUnitId: 'packingUnitId',
    receivedQty: 'receivedQty',
    pcs: 'pcs',
    unitSize: 'unitSize',
    packingType: 'packingType',
    unitId: 'unitId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GRNItemScalarFieldEnum = (typeof GRNItemScalarFieldEnum)[keyof typeof GRNItemScalarFieldEnum]


  export const PurchaseInvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    date: 'date',
    supplierInvoiceNo: 'supplierInvoiceNo',
    remarks: 'remarks',
    purchaseOrderId: 'purchaseOrderId',
    accountId: 'accountId',
    totalAmount: 'totalAmount',
    status: 'status',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseInvoiceScalarFieldEnum = (typeof PurchaseInvoiceScalarFieldEnum)[keyof typeof PurchaseInvoiceScalarFieldEnum]


  export const PurchaseInvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    purchaseOrderItemId: 'purchaseOrderItemId',
    grnItemId: 'grnItemId',
    itemMasterId: 'itemMasterId',
    colorId: 'colorId',
    brandId: 'brandId',
    itemGradeId: 'itemGradeId',
    unitId: 'unitId',
    invoicedQty: 'invoicedQty',
    rate: 'rate',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseInvoiceItemScalarFieldEnum = (typeof PurchaseInvoiceItemScalarFieldEnum)[keyof typeof PurchaseInvoiceItemScalarFieldEnum]


  export const PurchaseReturnScalarFieldEnum: {
    id: 'id',
    returnNumber: 'returnNumber',
    date: 'date',
    remarks: 'remarks',
    purchaseInvoiceId: 'purchaseInvoiceId',
    grnId: 'grnId',
    accountId: 'accountId',
    totalAmount: 'totalAmount',
    status: 'status',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseReturnScalarFieldEnum = (typeof PurchaseReturnScalarFieldEnum)[keyof typeof PurchaseReturnScalarFieldEnum]


  export const PurchaseReturnItemScalarFieldEnum: {
    id: 'id',
    returnId: 'returnId',
    purchaseInvoiceItemId: 'purchaseInvoiceItemId',
    grnItemId: 'grnItemId',
    itemMasterId: 'itemMasterId',
    colorId: 'colorId',
    brandId: 'brandId',
    itemGradeId: 'itemGradeId',
    unitId: 'unitId',
    returnedQty: 'returnedQty',
    rate: 'rate',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseReturnItemScalarFieldEnum = (typeof PurchaseReturnItemScalarFieldEnum)[keyof typeof PurchaseReturnItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'BalanceType'
   */
  export type EnumBalanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BalanceType'>
    


  /**
   * Reference to a field of type 'BalanceType[]'
   */
  export type ListEnumBalanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BalanceType[]'>
    


  /**
   * Reference to a field of type 'VoucherType'
   */
  export type EnumVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherType'>
    


  /**
   * Reference to a field of type 'VoucherType[]'
   */
  export type ListEnumVoucherTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoucherType[]'>
    


  /**
   * Reference to a field of type 'PurchaseOrderType'
   */
  export type EnumPurchaseOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseOrderType'>
    


  /**
   * Reference to a field of type 'PurchaseOrderType[]'
   */
  export type ListEnumPurchaseOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseOrderType[]'>
    


  /**
   * Reference to a field of type 'PurchaseOrderStatus'
   */
  export type EnumPurchaseOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseOrderStatus'>
    


  /**
   * Reference to a field of type 'PurchaseOrderStatus[]'
   */
  export type ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseOrderStatus[]'>
    


  /**
   * Reference to a field of type 'PackingType'
   */
  export type EnumPackingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackingType'>
    


  /**
   * Reference to a field of type 'PackingType[]'
   */
  export type ListEnumPackingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PackingType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstLogin?: BoolFilter<"User"> | boolean
    forcePasswordChange?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    departmentId?: IntNullableFilter<"User"> | number | null
    posts?: PostListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    auditLogPermissions?: AuditAccessListRelationFilter
    visibleToAudit?: AuditAccessListRelationFilter
    userRoles?: UserRoleListRelationFilter
    userWarehouses?: UserWarehouseListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstLogin?: SortOrder
    forcePasswordChange?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    posts?: PostOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    auditLogPermissions?: AuditAccessOrderByRelationAggregateInput
    visibleToAudit?: AuditAccessOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    userWarehouses?: UserWarehouseOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstLogin?: BoolFilter<"User"> | boolean
    forcePasswordChange?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    departmentId?: IntNullableFilter<"User"> | number | null
    posts?: PostListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    auditLogPermissions?: AuditAccessListRelationFilter
    visibleToAudit?: AuditAccessListRelationFilter
    userRoles?: UserRoleListRelationFilter
    userWarehouses?: UserWarehouseListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstLogin?: SortOrder
    forcePasswordChange?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    firstLogin?: BoolWithAggregatesFilter<"User"> | boolean
    forcePasswordChange?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    departmentId?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type AuditAccessWhereInput = {
    AND?: AuditAccessWhereInput | AuditAccessWhereInput[]
    OR?: AuditAccessWhereInput[]
    NOT?: AuditAccessWhereInput | AuditAccessWhereInput[]
    id?: IntFilter<"AuditAccess"> | number
    seniorId?: IntFilter<"AuditAccess"> | number
    juniorId?: IntFilter<"AuditAccess"> | number
    senior?: XOR<UserScalarRelationFilter, UserWhereInput>
    junior?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditAccessOrderByWithRelationInput = {
    id?: SortOrder
    seniorId?: SortOrder
    juniorId?: SortOrder
    senior?: UserOrderByWithRelationInput
    junior?: UserOrderByWithRelationInput
  }

  export type AuditAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    seniorId_juniorId?: AuditAccessSeniorIdJuniorIdCompoundUniqueInput
    AND?: AuditAccessWhereInput | AuditAccessWhereInput[]
    OR?: AuditAccessWhereInput[]
    NOT?: AuditAccessWhereInput | AuditAccessWhereInput[]
    seniorId?: IntFilter<"AuditAccess"> | number
    juniorId?: IntFilter<"AuditAccess"> | number
    senior?: XOR<UserScalarRelationFilter, UserWhereInput>
    junior?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "seniorId_juniorId">

  export type AuditAccessOrderByWithAggregationInput = {
    id?: SortOrder
    seniorId?: SortOrder
    juniorId?: SortOrder
    _count?: AuditAccessCountOrderByAggregateInput
    _avg?: AuditAccessAvgOrderByAggregateInput
    _max?: AuditAccessMaxOrderByAggregateInput
    _min?: AuditAccessMinOrderByAggregateInput
    _sum?: AuditAccessSumOrderByAggregateInput
  }

  export type AuditAccessScalarWhereWithAggregatesInput = {
    AND?: AuditAccessScalarWhereWithAggregatesInput | AuditAccessScalarWhereWithAggregatesInput[]
    OR?: AuditAccessScalarWhereWithAggregatesInput[]
    NOT?: AuditAccessScalarWhereWithAggregatesInput | AuditAccessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditAccess"> | number
    seniorId?: IntWithAggregatesFilter<"AuditAccess"> | number
    juniorId?: IntWithAggregatesFilter<"AuditAccess"> | number
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    users?: UserListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    description?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
    permissions?: RolePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
    permissions?: RolePermissionOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    userRoles?: UserRoleListRelationFilter
    permissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: IntFilter<"Permission"> | number
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    action_resource?: PermissionActionResourceCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    action?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    updatedAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "action_resource">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permission"> | number
    action?: StringWithAggregatesFilter<"Permission"> | string
    resource?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    assignedAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    assignedAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"RolePermission"> | number
    permissionId?: IntWithAggregatesFilter<"RolePermission"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserRole"> | number
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    published?: BoolFilter<"Post"> | boolean
    authorId?: IntFilter<"Post"> | number
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    published?: SortOrder
    authorId?: SortOrder
    author?: UserOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    title?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    published?: BoolFilter<"Post"> | boolean
    authorId?: IntFilter<"Post"> | number
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    published?: SortOrder
    authorId?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    title?: StringWithAggregatesFilter<"Post"> | string
    content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    published?: BoolWithAggregatesFilter<"Post"> | boolean
    authorId?: IntWithAggregatesFilter<"Post"> | number
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: IntWithAggregatesFilter<"RefreshToken"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    before?: JsonNullableFilter<"AuditLog">
    after?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    before?: JsonNullableFilter<"AuditLog">
    after?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: IntWithAggregatesFilter<"AuditLog"> | number
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    module?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    before?: JsonNullableWithAggregatesFilter<"AuditLog">
    after?: JsonNullableWithAggregatesFilter<"AuditLog">
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type WarehouseWhereInput = {
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    id?: IntFilter<"Warehouse"> | number
    name?: StringFilter<"Warehouse"> | string
    location?: StringNullableFilter<"Warehouse"> | string | null
    contactPerson?: StringNullableFilter<"Warehouse"> | string | null
    contactNumbers?: StringNullableListFilter<"Warehouse">
    status?: StringFilter<"Warehouse"> | string
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    userWarehouses?: UserWarehouseListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
  }

  export type WarehouseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contactNumbers?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userWarehouses?: UserWarehouseOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type WarehouseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: WarehouseWhereInput | WarehouseWhereInput[]
    OR?: WarehouseWhereInput[]
    NOT?: WarehouseWhereInput | WarehouseWhereInput[]
    location?: StringNullableFilter<"Warehouse"> | string | null
    contactPerson?: StringNullableFilter<"Warehouse"> | string | null
    contactNumbers?: StringNullableListFilter<"Warehouse">
    status?: StringFilter<"Warehouse"> | string
    createdAt?: DateTimeFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouse"> | Date | string
    userWarehouses?: UserWarehouseListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
  }, "id" | "name">

  export type WarehouseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    contactNumbers?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehouseCountOrderByAggregateInput
    _avg?: WarehouseAvgOrderByAggregateInput
    _max?: WarehouseMaxOrderByAggregateInput
    _min?: WarehouseMinOrderByAggregateInput
    _sum?: WarehouseSumOrderByAggregateInput
  }

  export type WarehouseScalarWhereWithAggregatesInput = {
    AND?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    OR?: WarehouseScalarWhereWithAggregatesInput[]
    NOT?: WarehouseScalarWhereWithAggregatesInput | WarehouseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Warehouse"> | number
    name?: StringWithAggregatesFilter<"Warehouse"> | string
    location?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"Warehouse"> | string | null
    contactNumbers?: StringNullableListFilter<"Warehouse">
    status?: StringWithAggregatesFilter<"Warehouse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Warehouse"> | Date | string
  }

  export type UserWarehouseWhereInput = {
    AND?: UserWarehouseWhereInput | UserWarehouseWhereInput[]
    OR?: UserWarehouseWhereInput[]
    NOT?: UserWarehouseWhereInput | UserWarehouseWhereInput[]
    userId?: IntFilter<"UserWarehouse"> | number
    warehouseId?: IntFilter<"UserWarehouse"> | number
    assignedAt?: DateTimeFilter<"UserWarehouse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }

  export type UserWarehouseOrderByWithRelationInput = {
    userId?: SortOrder
    warehouseId?: SortOrder
    assignedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
  }

  export type UserWarehouseWhereUniqueInput = Prisma.AtLeast<{
    userId_warehouseId?: UserWarehouseUserIdWarehouseIdCompoundUniqueInput
    AND?: UserWarehouseWhereInput | UserWarehouseWhereInput[]
    OR?: UserWarehouseWhereInput[]
    NOT?: UserWarehouseWhereInput | UserWarehouseWhereInput[]
    userId?: IntFilter<"UserWarehouse"> | number
    warehouseId?: IntFilter<"UserWarehouse"> | number
    assignedAt?: DateTimeFilter<"UserWarehouse"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    warehouse?: XOR<WarehouseScalarRelationFilter, WarehouseWhereInput>
  }, "userId_warehouseId">

  export type UserWarehouseOrderByWithAggregationInput = {
    userId?: SortOrder
    warehouseId?: SortOrder
    assignedAt?: SortOrder
    _count?: UserWarehouseCountOrderByAggregateInput
    _avg?: UserWarehouseAvgOrderByAggregateInput
    _max?: UserWarehouseMaxOrderByAggregateInput
    _min?: UserWarehouseMinOrderByAggregateInput
    _sum?: UserWarehouseSumOrderByAggregateInput
  }

  export type UserWarehouseScalarWhereWithAggregatesInput = {
    AND?: UserWarehouseScalarWhereWithAggregatesInput | UserWarehouseScalarWhereWithAggregatesInput[]
    OR?: UserWarehouseScalarWhereWithAggregatesInput[]
    NOT?: UserWarehouseScalarWhereWithAggregatesInput | UserWarehouseScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserWarehouse"> | number
    warehouseId?: IntWithAggregatesFilter<"UserWarehouse"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"UserWarehouse"> | Date | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    id?: IntFilter<"Unit"> | number
    code?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    symbol?: StringFilter<"Unit"> | string
    unitType?: StringFilter<"Unit"> | string
    isBase?: BoolFilter<"Unit"> | boolean
    status?: StringFilter<"Unit"> | string
    companyId?: IntFilter<"Unit"> | number
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    conversionsFrom?: UnitConversionListRelationFilter
    conversionsTo?: UnitConversionListRelationFilter
    products?: ProductListRelationFilter
    itemMasters?: ItemMasterListRelationFilter
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    unitType?: SortOrder
    isBase?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    conversionsFrom?: UnitConversionOrderByRelationAggregateInput
    conversionsTo?: UnitConversionOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    itemMasters?: ItemMasterOrderByRelationAggregateInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
    grnItems?: GRNItemOrderByRelationAggregateInput
    purchaseInvoiceItems?: PurchaseInvoiceItemOrderByRelationAggregateInput
    purchaseReturnItems?: PurchaseReturnItemOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    name?: StringFilter<"Unit"> | string
    symbol?: StringFilter<"Unit"> | string
    unitType?: StringFilter<"Unit"> | string
    isBase?: BoolFilter<"Unit"> | boolean
    status?: StringFilter<"Unit"> | string
    companyId?: IntFilter<"Unit"> | number
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    conversionsFrom?: UnitConversionListRelationFilter
    conversionsTo?: UnitConversionListRelationFilter
    products?: ProductListRelationFilter
    itemMasters?: ItemMasterListRelationFilter
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }, "id" | "code">

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    unitType?: SortOrder
    isBase?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Unit"> | number
    code?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringWithAggregatesFilter<"Unit"> | string
    symbol?: StringWithAggregatesFilter<"Unit"> | string
    unitType?: StringWithAggregatesFilter<"Unit"> | string
    isBase?: BoolWithAggregatesFilter<"Unit"> | boolean
    status?: StringWithAggregatesFilter<"Unit"> | string
    companyId?: IntWithAggregatesFilter<"Unit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
  }

  export type UnitConversionWhereInput = {
    AND?: UnitConversionWhereInput | UnitConversionWhereInput[]
    OR?: UnitConversionWhereInput[]
    NOT?: UnitConversionWhereInput | UnitConversionWhereInput[]
    id?: IntFilter<"UnitConversion"> | number
    fromUnitId?: IntFilter<"UnitConversion"> | number
    toUnitId?: IntFilter<"UnitConversion"> | number
    conversionRate?: FloatFilter<"UnitConversion"> | number
    companyId?: IntFilter<"UnitConversion"> | number
    createdAt?: DateTimeFilter<"UnitConversion"> | Date | string
    updatedAt?: DateTimeFilter<"UnitConversion"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    fromUnit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    toUnit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }

  export type UnitConversionOrderByWithRelationInput = {
    id?: SortOrder
    fromUnitId?: SortOrder
    toUnitId?: SortOrder
    conversionRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    fromUnit?: UnitOrderByWithRelationInput
    toUnit?: UnitOrderByWithRelationInput
  }

  export type UnitConversionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fromUnitId_toUnitId?: UnitConversionFromUnitIdToUnitIdCompoundUniqueInput
    AND?: UnitConversionWhereInput | UnitConversionWhereInput[]
    OR?: UnitConversionWhereInput[]
    NOT?: UnitConversionWhereInput | UnitConversionWhereInput[]
    fromUnitId?: IntFilter<"UnitConversion"> | number
    toUnitId?: IntFilter<"UnitConversion"> | number
    conversionRate?: FloatFilter<"UnitConversion"> | number
    companyId?: IntFilter<"UnitConversion"> | number
    createdAt?: DateTimeFilter<"UnitConversion"> | Date | string
    updatedAt?: DateTimeFilter<"UnitConversion"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    fromUnit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    toUnit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
  }, "id" | "fromUnitId_toUnitId">

  export type UnitConversionOrderByWithAggregationInput = {
    id?: SortOrder
    fromUnitId?: SortOrder
    toUnitId?: SortOrder
    conversionRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitConversionCountOrderByAggregateInput
    _avg?: UnitConversionAvgOrderByAggregateInput
    _max?: UnitConversionMaxOrderByAggregateInput
    _min?: UnitConversionMinOrderByAggregateInput
    _sum?: UnitConversionSumOrderByAggregateInput
  }

  export type UnitConversionScalarWhereWithAggregatesInput = {
    AND?: UnitConversionScalarWhereWithAggregatesInput | UnitConversionScalarWhereWithAggregatesInput[]
    OR?: UnitConversionScalarWhereWithAggregatesInput[]
    NOT?: UnitConversionScalarWhereWithAggregatesInput | UnitConversionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UnitConversion"> | number
    fromUnitId?: IntWithAggregatesFilter<"UnitConversion"> | number
    toUnitId?: IntWithAggregatesFilter<"UnitConversion"> | number
    conversionRate?: FloatWithAggregatesFilter<"UnitConversion"> | number
    companyId?: IntWithAggregatesFilter<"UnitConversion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UnitConversion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnitConversion"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    legalName?: StringFilter<"Company"> | string
    tradeName?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    country?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    taxId?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    itemGroups?: ItemGroupListRelationFilter
    colors?: ColorListRelationFilter
    brands?: BrandListRelationFilter
    units?: UnitListRelationFilter
    itemGrades?: ItemGradeListRelationFilter
    unitConversions?: UnitConversionListRelationFilter
    itemMasters?: ItemMasterListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    grns?: GRNListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    purchaseReturns?: PurchaseReturnListRelationFilter
    packingUnits?: PackingUnitListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    legalName?: SortOrder
    tradeName?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itemGroups?: ItemGroupOrderByRelationAggregateInput
    colors?: ColorOrderByRelationAggregateInput
    brands?: BrandOrderByRelationAggregateInput
    units?: UnitOrderByRelationAggregateInput
    itemGrades?: ItemGradeOrderByRelationAggregateInput
    unitConversions?: UnitConversionOrderByRelationAggregateInput
    itemMasters?: ItemMasterOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    grns?: GRNOrderByRelationAggregateInput
    purchaseInvoices?: PurchaseInvoiceOrderByRelationAggregateInput
    purchaseReturns?: PurchaseReturnOrderByRelationAggregateInput
    packingUnits?: PackingUnitOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    legalName?: StringFilter<"Company"> | string
    tradeName?: StringNullableFilter<"Company"> | string | null
    address?: StringNullableFilter<"Company"> | string | null
    country?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    taxId?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    itemGroups?: ItemGroupListRelationFilter
    colors?: ColorListRelationFilter
    brands?: BrandListRelationFilter
    units?: UnitListRelationFilter
    itemGrades?: ItemGradeListRelationFilter
    unitConversions?: UnitConversionListRelationFilter
    itemMasters?: ItemMasterListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    grns?: GRNListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    purchaseReturns?: PurchaseReturnListRelationFilter
    packingUnits?: PackingUnitListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    legalName?: SortOrder
    tradeName?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    legalName?: StringWithAggregatesFilter<"Company"> | string
    tradeName?: StringNullableWithAggregatesFilter<"Company"> | string | null
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    country?: StringNullableWithAggregatesFilter<"Company"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type FiscalYearWhereInput = {
    AND?: FiscalYearWhereInput | FiscalYearWhereInput[]
    OR?: FiscalYearWhereInput[]
    NOT?: FiscalYearWhereInput | FiscalYearWhereInput[]
    id?: IntFilter<"FiscalYear"> | number
    name?: StringFilter<"FiscalYear"> | string
    startDate?: DateTimeFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeFilter<"FiscalYear"> | Date | string
    isActive?: BoolFilter<"FiscalYear"> | boolean
    isLocked?: BoolFilter<"FiscalYear"> | boolean
    createdAt?: DateTimeFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalYear"> | Date | string
    journalEntries?: JournalEntryListRelationFilter
  }

  export type FiscalYearOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    journalEntries?: JournalEntryOrderByRelationAggregateInput
  }

  export type FiscalYearWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: FiscalYearWhereInput | FiscalYearWhereInput[]
    OR?: FiscalYearWhereInput[]
    NOT?: FiscalYearWhereInput | FiscalYearWhereInput[]
    startDate?: DateTimeFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeFilter<"FiscalYear"> | Date | string
    isActive?: BoolFilter<"FiscalYear"> | boolean
    isLocked?: BoolFilter<"FiscalYear"> | boolean
    createdAt?: DateTimeFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeFilter<"FiscalYear"> | Date | string
    journalEntries?: JournalEntryListRelationFilter
  }, "id" | "name">

  export type FiscalYearOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FiscalYearCountOrderByAggregateInput
    _avg?: FiscalYearAvgOrderByAggregateInput
    _max?: FiscalYearMaxOrderByAggregateInput
    _min?: FiscalYearMinOrderByAggregateInput
    _sum?: FiscalYearSumOrderByAggregateInput
  }

  export type FiscalYearScalarWhereWithAggregatesInput = {
    AND?: FiscalYearScalarWhereWithAggregatesInput | FiscalYearScalarWhereWithAggregatesInput[]
    OR?: FiscalYearScalarWhereWithAggregatesInput[]
    NOT?: FiscalYearScalarWhereWithAggregatesInput | FiscalYearScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FiscalYear"> | number
    name?: StringWithAggregatesFilter<"FiscalYear"> | string
    startDate?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
    isActive?: BoolWithAggregatesFilter<"FiscalYear"> | boolean
    isLocked?: BoolWithAggregatesFilter<"FiscalYear"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FiscalYear"> | Date | string
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: IntFilter<"Currency"> | number
    code?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    isBase?: BoolFilter<"Currency"> | boolean
    exchangeRate?: FloatFilter<"Currency"> | number
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
    purchaseOrders?: PurchaseOrderListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    isBase?: SortOrder
    exchangeRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    symbol?: StringFilter<"Currency"> | string
    isBase?: BoolFilter<"Currency"> | boolean
    exchangeRate?: FloatFilter<"Currency"> | number
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
    purchaseOrders?: PurchaseOrderListRelationFilter
  }, "id" | "code">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    isBase?: SortOrder
    exchangeRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Currency"> | number
    code?: StringWithAggregatesFilter<"Currency"> | string
    symbol?: StringWithAggregatesFilter<"Currency"> | string
    isBase?: BoolWithAggregatesFilter<"Currency"> | boolean
    exchangeRate?: FloatWithAggregatesFilter<"Currency"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: IntFilter<"SystemConfig"> | number
    quantityDecimals?: IntFilter<"SystemConfig"> | number
    amountDecimals?: IntFilter<"SystemConfig"> | number
    rateDecimals?: IntFilter<"SystemConfig"> | number
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    quantityDecimals?: SortOrder
    amountDecimals?: SortOrder
    rateDecimals?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    quantityDecimals?: IntFilter<"SystemConfig"> | number
    amountDecimals?: IntFilter<"SystemConfig"> | number
    rateDecimals?: IntFilter<"SystemConfig"> | number
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    quantityDecimals?: SortOrder
    amountDecimals?: SortOrder
    rateDecimals?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _avg?: SystemConfigAvgOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
    _sum?: SystemConfigSumOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemConfig"> | number
    quantityDecimals?: IntWithAggregatesFilter<"SystemConfig"> | number
    amountDecimals?: IntWithAggregatesFilter<"SystemConfig"> | number
    rateDecimals?: IntWithAggregatesFilter<"SystemConfig"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    description?: StringNullableFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "key">

  export type SystemSettingOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    description?: StringNullableWithAggregatesFilter<"SystemSetting"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    code?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    code?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "name" | "code">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    code?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    categoryId?: IntFilter<"Product"> | number
    unitId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    variants?: VariantListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    variants?: VariantOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    categoryId?: IntFilter<"Product"> | number
    unitId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    unit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    variants?: VariantListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    code?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    categoryId?: IntWithAggregatesFilter<"Product"> | number
    unitId?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type VariantWhereInput = {
    AND?: VariantWhereInput | VariantWhereInput[]
    OR?: VariantWhereInput[]
    NOT?: VariantWhereInput | VariantWhereInput[]
    id?: IntFilter<"Variant"> | number
    name?: StringFilter<"Variant"> | string
    sku?: StringFilter<"Variant"> | string
    productId?: IntFilter<"Variant"> | number
    color?: StringNullableFilter<"Variant"> | string | null
    count?: StringNullableFilter<"Variant"> | string | null
    gsm?: StringNullableFilter<"Variant"> | string | null
    width?: StringNullableFilter<"Variant"> | string | null
    shade?: StringNullableFilter<"Variant"> | string | null
    weave?: StringNullableFilter<"Variant"> | string | null
    finish?: StringNullableFilter<"Variant"> | string | null
    type?: StringNullableFilter<"Variant"> | string | null
    price?: FloatNullableFilter<"Variant"> | number | null
    stock?: FloatNullableFilter<"Variant"> | number | null
    createdAt?: DateTimeFilter<"Variant"> | Date | string
    updatedAt?: DateTimeFilter<"Variant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type VariantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    productId?: SortOrder
    color?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    gsm?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    shade?: SortOrderInput | SortOrder
    weave?: SortOrderInput | SortOrder
    finish?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type VariantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sku?: string
    AND?: VariantWhereInput | VariantWhereInput[]
    OR?: VariantWhereInput[]
    NOT?: VariantWhereInput | VariantWhereInput[]
    name?: StringFilter<"Variant"> | string
    productId?: IntFilter<"Variant"> | number
    color?: StringNullableFilter<"Variant"> | string | null
    count?: StringNullableFilter<"Variant"> | string | null
    gsm?: StringNullableFilter<"Variant"> | string | null
    width?: StringNullableFilter<"Variant"> | string | null
    shade?: StringNullableFilter<"Variant"> | string | null
    weave?: StringNullableFilter<"Variant"> | string | null
    finish?: StringNullableFilter<"Variant"> | string | null
    type?: StringNullableFilter<"Variant"> | string | null
    price?: FloatNullableFilter<"Variant"> | number | null
    stock?: FloatNullableFilter<"Variant"> | number | null
    createdAt?: DateTimeFilter<"Variant"> | Date | string
    updatedAt?: DateTimeFilter<"Variant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "sku">

  export type VariantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    productId?: SortOrder
    color?: SortOrderInput | SortOrder
    count?: SortOrderInput | SortOrder
    gsm?: SortOrderInput | SortOrder
    width?: SortOrderInput | SortOrder
    shade?: SortOrderInput | SortOrder
    weave?: SortOrderInput | SortOrder
    finish?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VariantCountOrderByAggregateInput
    _avg?: VariantAvgOrderByAggregateInput
    _max?: VariantMaxOrderByAggregateInput
    _min?: VariantMinOrderByAggregateInput
    _sum?: VariantSumOrderByAggregateInput
  }

  export type VariantScalarWhereWithAggregatesInput = {
    AND?: VariantScalarWhereWithAggregatesInput | VariantScalarWhereWithAggregatesInput[]
    OR?: VariantScalarWhereWithAggregatesInput[]
    NOT?: VariantScalarWhereWithAggregatesInput | VariantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Variant"> | number
    name?: StringWithAggregatesFilter<"Variant"> | string
    sku?: StringWithAggregatesFilter<"Variant"> | string
    productId?: IntWithAggregatesFilter<"Variant"> | number
    color?: StringNullableWithAggregatesFilter<"Variant"> | string | null
    count?: StringNullableWithAggregatesFilter<"Variant"> | string | null
    gsm?: StringNullableWithAggregatesFilter<"Variant"> | string | null
    width?: StringNullableWithAggregatesFilter<"Variant"> | string | null
    shade?: StringNullableWithAggregatesFilter<"Variant"> | string | null
    weave?: StringNullableWithAggregatesFilter<"Variant"> | string | null
    finish?: StringNullableWithAggregatesFilter<"Variant"> | string | null
    type?: StringNullableWithAggregatesFilter<"Variant"> | string | null
    price?: FloatNullableWithAggregatesFilter<"Variant"> | number | null
    stock?: FloatNullableWithAggregatesFilter<"Variant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Variant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Variant"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: IntFilter<"Location"> | number
    name?: StringFilter<"Location"> | string
    description?: StringNullableFilter<"Location"> | string | null
    status?: StringFilter<"Location"> | string
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    machines?: MachineListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    machines?: MachineOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    description?: StringNullableFilter<"Location"> | string | null
    status?: StringFilter<"Location"> | string
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    machines?: MachineListRelationFilter
  }, "id" | "name">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Location"> | number
    name?: StringWithAggregatesFilter<"Location"> | string
    description?: StringNullableWithAggregatesFilter<"Location"> | string | null
    status?: StringWithAggregatesFilter<"Location"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: IntFilter<"Shift"> | number
    name?: StringFilter<"Shift"> | string
    startTime?: StringFilter<"Shift"> | string
    endTime?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    startTime?: StringFilter<"Shift"> | string
    endTime?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
  }, "id" | "name">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shift"> | number
    name?: StringWithAggregatesFilter<"Shift"> | string
    startTime?: StringWithAggregatesFilter<"Shift"> | string
    endTime?: StringWithAggregatesFilter<"Shift"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
  }

  export type OperatorWhereInput = {
    AND?: OperatorWhereInput | OperatorWhereInput[]
    OR?: OperatorWhereInput[]
    NOT?: OperatorWhereInput | OperatorWhereInput[]
    id?: IntFilter<"Operator"> | number
    name?: StringFilter<"Operator"> | string
    code?: StringFilter<"Operator"> | string
    contact?: StringNullableFilter<"Operator"> | string | null
    status?: StringFilter<"Operator"> | string
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeFilter<"Operator"> | Date | string
  }

  export type OperatorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    contact?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: OperatorWhereInput | OperatorWhereInput[]
    OR?: OperatorWhereInput[]
    NOT?: OperatorWhereInput | OperatorWhereInput[]
    name?: StringFilter<"Operator"> | string
    contact?: StringNullableFilter<"Operator"> | string | null
    status?: StringFilter<"Operator"> | string
    createdAt?: DateTimeFilter<"Operator"> | Date | string
    updatedAt?: DateTimeFilter<"Operator"> | Date | string
  }, "id" | "code">

  export type OperatorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    contact?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OperatorCountOrderByAggregateInput
    _avg?: OperatorAvgOrderByAggregateInput
    _max?: OperatorMaxOrderByAggregateInput
    _min?: OperatorMinOrderByAggregateInput
    _sum?: OperatorSumOrderByAggregateInput
  }

  export type OperatorScalarWhereWithAggregatesInput = {
    AND?: OperatorScalarWhereWithAggregatesInput | OperatorScalarWhereWithAggregatesInput[]
    OR?: OperatorScalarWhereWithAggregatesInput[]
    NOT?: OperatorScalarWhereWithAggregatesInput | OperatorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Operator"> | number
    name?: StringWithAggregatesFilter<"Operator"> | string
    code?: StringWithAggregatesFilter<"Operator"> | string
    contact?: StringNullableWithAggregatesFilter<"Operator"> | string | null
    status?: StringWithAggregatesFilter<"Operator"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Operator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Operator"> | Date | string
  }

  export type MachineWhereInput = {
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    id?: IntFilter<"Machine"> | number
    name?: StringFilter<"Machine"> | string
    code?: StringFilter<"Machine"> | string
    type?: StringNullableFilter<"Machine"> | string | null
    status?: StringFilter<"Machine"> | string
    locationId?: IntNullableFilter<"Machine"> | number | null
    createdAt?: DateTimeFilter<"Machine"> | Date | string
    updatedAt?: DateTimeFilter<"Machine"> | Date | string
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }

  export type MachineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
  }

  export type MachineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: MachineWhereInput | MachineWhereInput[]
    OR?: MachineWhereInput[]
    NOT?: MachineWhereInput | MachineWhereInput[]
    name?: StringFilter<"Machine"> | string
    type?: StringNullableFilter<"Machine"> | string | null
    status?: StringFilter<"Machine"> | string
    locationId?: IntNullableFilter<"Machine"> | number | null
    createdAt?: DateTimeFilter<"Machine"> | Date | string
    updatedAt?: DateTimeFilter<"Machine"> | Date | string
    location?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
  }, "id" | "code">

  export type MachineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrderInput | SortOrder
    status?: SortOrder
    locationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MachineCountOrderByAggregateInput
    _avg?: MachineAvgOrderByAggregateInput
    _max?: MachineMaxOrderByAggregateInput
    _min?: MachineMinOrderByAggregateInput
    _sum?: MachineSumOrderByAggregateInput
  }

  export type MachineScalarWhereWithAggregatesInput = {
    AND?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    OR?: MachineScalarWhereWithAggregatesInput[]
    NOT?: MachineScalarWhereWithAggregatesInput | MachineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Machine"> | number
    name?: StringWithAggregatesFilter<"Machine"> | string
    code?: StringWithAggregatesFilter<"Machine"> | string
    type?: StringNullableWithAggregatesFilter<"Machine"> | string | null
    status?: StringWithAggregatesFilter<"Machine"> | string
    locationId?: IntNullableWithAggregatesFilter<"Machine"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Machine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Machine"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    parentId?: IntNullableFilter<"Account"> | number | null
    level?: IntFilter<"Account"> | number
    isPosting?: BoolFilter<"Account"> | boolean
    description?: StringNullableFilter<"Account"> | string | null
    openingBalance?: FloatFilter<"Account"> | number
    openingBalanceType?: EnumBalanceTypeFilter<"Account"> | $Enums.BalanceType
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    parent?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    children?: AccountListRelationFilter
    journalLines?: JournalLineListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    purchaseReturns?: PurchaseReturnListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrderInput | SortOrder
    level?: SortOrder
    isPosting?: SortOrder
    description?: SortOrderInput | SortOrder
    openingBalance?: SortOrder
    openingBalanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: AccountOrderByWithRelationInput
    children?: AccountOrderByRelationAggregateInput
    journalLines?: JournalLineOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    purchaseInvoices?: PurchaseInvoiceOrderByRelationAggregateInput
    purchaseReturns?: PurchaseReturnOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    parentId?: IntNullableFilter<"Account"> | number | null
    level?: IntFilter<"Account"> | number
    isPosting?: BoolFilter<"Account"> | boolean
    description?: StringNullableFilter<"Account"> | string | null
    openingBalance?: FloatFilter<"Account"> | number
    openingBalanceType?: EnumBalanceTypeFilter<"Account"> | $Enums.BalanceType
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    parent?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    children?: AccountListRelationFilter
    journalLines?: JournalLineListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    purchaseInvoices?: PurchaseInvoiceListRelationFilter
    purchaseReturns?: PurchaseReturnListRelationFilter
  }, "id" | "code">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrderInput | SortOrder
    level?: SortOrder
    isPosting?: SortOrder
    description?: SortOrderInput | SortOrder
    openingBalance?: SortOrder
    openingBalanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    code?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    type?: EnumAccountTypeWithAggregatesFilter<"Account"> | $Enums.AccountType
    parentId?: IntNullableWithAggregatesFilter<"Account"> | number | null
    level?: IntWithAggregatesFilter<"Account"> | number
    isPosting?: BoolWithAggregatesFilter<"Account"> | boolean
    description?: StringNullableWithAggregatesFilter<"Account"> | string | null
    openingBalance?: FloatWithAggregatesFilter<"Account"> | number
    openingBalanceType?: EnumBalanceTypeWithAggregatesFilter<"Account"> | $Enums.BalanceType
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type JournalEntryWhereInput = {
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    id?: IntFilter<"JournalEntry"> | number
    number?: StringFilter<"JournalEntry"> | string
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    type?: EnumVoucherTypeFilter<"JournalEntry"> | $Enums.VoucherType
    reference?: StringNullableFilter<"JournalEntry"> | string | null
    narration?: StringNullableFilter<"JournalEntry"> | string | null
    status?: BoolFilter<"JournalEntry"> | boolean
    fiscalYearId?: IntNullableFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    fiscalYear?: XOR<FiscalYearNullableScalarRelationFilter, FiscalYearWhereInput> | null
    lines?: JournalLineListRelationFilter
  }

  export type JournalEntryOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    type?: SortOrder
    reference?: SortOrderInput | SortOrder
    narration?: SortOrderInput | SortOrder
    status?: SortOrder
    fiscalYearId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fiscalYear?: FiscalYearOrderByWithRelationInput
    lines?: JournalLineOrderByRelationAggregateInput
  }

  export type JournalEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    number?: string
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    type?: EnumVoucherTypeFilter<"JournalEntry"> | $Enums.VoucherType
    reference?: StringNullableFilter<"JournalEntry"> | string | null
    narration?: StringNullableFilter<"JournalEntry"> | string | null
    status?: BoolFilter<"JournalEntry"> | boolean
    fiscalYearId?: IntNullableFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    fiscalYear?: XOR<FiscalYearNullableScalarRelationFilter, FiscalYearWhereInput> | null
    lines?: JournalLineListRelationFilter
  }, "id" | "number">

  export type JournalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    type?: SortOrder
    reference?: SortOrderInput | SortOrder
    narration?: SortOrderInput | SortOrder
    status?: SortOrder
    fiscalYearId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalEntryCountOrderByAggregateInput
    _avg?: JournalEntryAvgOrderByAggregateInput
    _max?: JournalEntryMaxOrderByAggregateInput
    _min?: JournalEntryMinOrderByAggregateInput
    _sum?: JournalEntrySumOrderByAggregateInput
  }

  export type JournalEntryScalarWhereWithAggregatesInput = {
    AND?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    OR?: JournalEntryScalarWhereWithAggregatesInput[]
    NOT?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JournalEntry"> | number
    number?: StringWithAggregatesFilter<"JournalEntry"> | string
    date?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    type?: EnumVoucherTypeWithAggregatesFilter<"JournalEntry"> | $Enums.VoucherType
    reference?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    narration?: StringNullableWithAggregatesFilter<"JournalEntry"> | string | null
    status?: BoolWithAggregatesFilter<"JournalEntry"> | boolean
    fiscalYearId?: IntNullableWithAggregatesFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
  }

  export type JournalLineWhereInput = {
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    id?: IntFilter<"JournalLine"> | number
    entryId?: IntFilter<"JournalLine"> | number
    accountId?: IntFilter<"JournalLine"> | number
    debit?: FloatFilter<"JournalLine"> | number
    credit?: FloatFilter<"JournalLine"> | number
    narration?: StringNullableFilter<"JournalLine"> | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    entry?: XOR<JournalEntryScalarRelationFilter, JournalEntryWhereInput>
  }

  export type JournalLineOrderByWithRelationInput = {
    id?: SortOrder
    entryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    narration?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    entry?: JournalEntryOrderByWithRelationInput
  }

  export type JournalLineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JournalLineWhereInput | JournalLineWhereInput[]
    OR?: JournalLineWhereInput[]
    NOT?: JournalLineWhereInput | JournalLineWhereInput[]
    entryId?: IntFilter<"JournalLine"> | number
    accountId?: IntFilter<"JournalLine"> | number
    debit?: FloatFilter<"JournalLine"> | number
    credit?: FloatFilter<"JournalLine"> | number
    narration?: StringNullableFilter<"JournalLine"> | string | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    entry?: XOR<JournalEntryScalarRelationFilter, JournalEntryWhereInput>
  }, "id">

  export type JournalLineOrderByWithAggregationInput = {
    id?: SortOrder
    entryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    narration?: SortOrderInput | SortOrder
    _count?: JournalLineCountOrderByAggregateInput
    _avg?: JournalLineAvgOrderByAggregateInput
    _max?: JournalLineMaxOrderByAggregateInput
    _min?: JournalLineMinOrderByAggregateInput
    _sum?: JournalLineSumOrderByAggregateInput
  }

  export type JournalLineScalarWhereWithAggregatesInput = {
    AND?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    OR?: JournalLineScalarWhereWithAggregatesInput[]
    NOT?: JournalLineScalarWhereWithAggregatesInput | JournalLineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JournalLine"> | number
    entryId?: IntWithAggregatesFilter<"JournalLine"> | number
    accountId?: IntWithAggregatesFilter<"JournalLine"> | number
    debit?: FloatWithAggregatesFilter<"JournalLine"> | number
    credit?: FloatWithAggregatesFilter<"JournalLine"> | number
    narration?: StringNullableWithAggregatesFilter<"JournalLine"> | string | null
  }

  export type VoucherSequenceWhereInput = {
    AND?: VoucherSequenceWhereInput | VoucherSequenceWhereInput[]
    OR?: VoucherSequenceWhereInput[]
    NOT?: VoucherSequenceWhereInput | VoucherSequenceWhereInput[]
    id?: IntFilter<"VoucherSequence"> | number
    type?: EnumVoucherTypeFilter<"VoucherSequence"> | $Enums.VoucherType
    prefix?: StringFilter<"VoucherSequence"> | string
    nextValue?: IntFilter<"VoucherSequence"> | number
    updatedAt?: DateTimeFilter<"VoucherSequence"> | Date | string
  }

  export type VoucherSequenceOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    prefix?: SortOrder
    nextValue?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherSequenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type?: $Enums.VoucherType
    AND?: VoucherSequenceWhereInput | VoucherSequenceWhereInput[]
    OR?: VoucherSequenceWhereInput[]
    NOT?: VoucherSequenceWhereInput | VoucherSequenceWhereInput[]
    prefix?: StringFilter<"VoucherSequence"> | string
    nextValue?: IntFilter<"VoucherSequence"> | number
    updatedAt?: DateTimeFilter<"VoucherSequence"> | Date | string
  }, "id" | "type">

  export type VoucherSequenceOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    prefix?: SortOrder
    nextValue?: SortOrder
    updatedAt?: SortOrder
    _count?: VoucherSequenceCountOrderByAggregateInput
    _avg?: VoucherSequenceAvgOrderByAggregateInput
    _max?: VoucherSequenceMaxOrderByAggregateInput
    _min?: VoucherSequenceMinOrderByAggregateInput
    _sum?: VoucherSequenceSumOrderByAggregateInput
  }

  export type VoucherSequenceScalarWhereWithAggregatesInput = {
    AND?: VoucherSequenceScalarWhereWithAggregatesInput | VoucherSequenceScalarWhereWithAggregatesInput[]
    OR?: VoucherSequenceScalarWhereWithAggregatesInput[]
    NOT?: VoucherSequenceScalarWhereWithAggregatesInput | VoucherSequenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VoucherSequence"> | number
    type?: EnumVoucherTypeWithAggregatesFilter<"VoucherSequence"> | $Enums.VoucherType
    prefix?: StringWithAggregatesFilter<"VoucherSequence"> | string
    nextValue?: IntWithAggregatesFilter<"VoucherSequence"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"VoucherSequence"> | Date | string
  }

  export type ItemGroupWhereInput = {
    AND?: ItemGroupWhereInput | ItemGroupWhereInput[]
    OR?: ItemGroupWhereInput[]
    NOT?: ItemGroupWhereInput | ItemGroupWhereInput[]
    id?: StringFilter<"ItemGroup"> | string
    code?: StringFilter<"ItemGroup"> | string
    name?: StringFilter<"ItemGroup"> | string
    description?: StringNullableFilter<"ItemGroup"> | string | null
    status?: StringFilter<"ItemGroup"> | string
    parentId?: StringNullableFilter<"ItemGroup"> | string | null
    companyId?: IntFilter<"ItemGroup"> | number
    createdAt?: DateTimeFilter<"ItemGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ItemGroup"> | Date | string
    parent?: XOR<ItemGroupNullableScalarRelationFilter, ItemGroupWhereInput> | null
    children?: ItemGroupListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    itemMasters?: ItemMasterListRelationFilter
  }

  export type ItemGroupOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    parentId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: ItemGroupOrderByWithRelationInput
    children?: ItemGroupOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    itemMasters?: ItemMasterOrderByRelationAggregateInput
  }

  export type ItemGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ItemGroupWhereInput | ItemGroupWhereInput[]
    OR?: ItemGroupWhereInput[]
    NOT?: ItemGroupWhereInput | ItemGroupWhereInput[]
    name?: StringFilter<"ItemGroup"> | string
    description?: StringNullableFilter<"ItemGroup"> | string | null
    status?: StringFilter<"ItemGroup"> | string
    parentId?: StringNullableFilter<"ItemGroup"> | string | null
    companyId?: IntFilter<"ItemGroup"> | number
    createdAt?: DateTimeFilter<"ItemGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ItemGroup"> | Date | string
    parent?: XOR<ItemGroupNullableScalarRelationFilter, ItemGroupWhereInput> | null
    children?: ItemGroupListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    itemMasters?: ItemMasterListRelationFilter
  }, "id" | "code">

  export type ItemGroupOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    parentId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemGroupCountOrderByAggregateInput
    _avg?: ItemGroupAvgOrderByAggregateInput
    _max?: ItemGroupMaxOrderByAggregateInput
    _min?: ItemGroupMinOrderByAggregateInput
    _sum?: ItemGroupSumOrderByAggregateInput
  }

  export type ItemGroupScalarWhereWithAggregatesInput = {
    AND?: ItemGroupScalarWhereWithAggregatesInput | ItemGroupScalarWhereWithAggregatesInput[]
    OR?: ItemGroupScalarWhereWithAggregatesInput[]
    NOT?: ItemGroupScalarWhereWithAggregatesInput | ItemGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemGroup"> | string
    code?: StringWithAggregatesFilter<"ItemGroup"> | string
    name?: StringWithAggregatesFilter<"ItemGroup"> | string
    description?: StringNullableWithAggregatesFilter<"ItemGroup"> | string | null
    status?: StringWithAggregatesFilter<"ItemGroup"> | string
    parentId?: StringNullableWithAggregatesFilter<"ItemGroup"> | string | null
    companyId?: IntWithAggregatesFilter<"ItemGroup"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ItemGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemGroup"> | Date | string
  }

  export type ColorWhereInput = {
    AND?: ColorWhereInput | ColorWhereInput[]
    OR?: ColorWhereInput[]
    NOT?: ColorWhereInput | ColorWhereInput[]
    id?: StringFilter<"Color"> | string
    code?: StringFilter<"Color"> | string
    name?: StringFilter<"Color"> | string
    pictureUrl?: StringNullableFilter<"Color"> | string | null
    status?: StringFilter<"Color"> | string
    companyId?: IntFilter<"Color"> | number
    createdAt?: DateTimeFilter<"Color"> | Date | string
    updatedAt?: DateTimeFilter<"Color"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }

  export type ColorOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    pictureUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
    grnItems?: GRNItemOrderByRelationAggregateInput
    purchaseInvoiceItems?: PurchaseInvoiceItemOrderByRelationAggregateInput
    purchaseReturnItems?: PurchaseReturnItemOrderByRelationAggregateInput
  }

  export type ColorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ColorWhereInput | ColorWhereInput[]
    OR?: ColorWhereInput[]
    NOT?: ColorWhereInput | ColorWhereInput[]
    name?: StringFilter<"Color"> | string
    pictureUrl?: StringNullableFilter<"Color"> | string | null
    status?: StringFilter<"Color"> | string
    companyId?: IntFilter<"Color"> | number
    createdAt?: DateTimeFilter<"Color"> | Date | string
    updatedAt?: DateTimeFilter<"Color"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }, "id" | "code">

  export type ColorOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    pictureUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ColorCountOrderByAggregateInput
    _avg?: ColorAvgOrderByAggregateInput
    _max?: ColorMaxOrderByAggregateInput
    _min?: ColorMinOrderByAggregateInput
    _sum?: ColorSumOrderByAggregateInput
  }

  export type ColorScalarWhereWithAggregatesInput = {
    AND?: ColorScalarWhereWithAggregatesInput | ColorScalarWhereWithAggregatesInput[]
    OR?: ColorScalarWhereWithAggregatesInput[]
    NOT?: ColorScalarWhereWithAggregatesInput | ColorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Color"> | string
    code?: StringWithAggregatesFilter<"Color"> | string
    name?: StringWithAggregatesFilter<"Color"> | string
    pictureUrl?: StringNullableWithAggregatesFilter<"Color"> | string | null
    status?: StringWithAggregatesFilter<"Color"> | string
    companyId?: IntWithAggregatesFilter<"Color"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Color"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Color"> | Date | string
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: StringFilter<"Brand"> | string
    code?: StringFilter<"Brand"> | string
    name?: StringFilter<"Brand"> | string
    status?: StringFilter<"Brand"> | string
    companyId?: IntFilter<"Brand"> | number
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
    grnItems?: GRNItemOrderByRelationAggregateInput
    purchaseInvoiceItems?: PurchaseInvoiceItemOrderByRelationAggregateInput
    purchaseReturnItems?: PurchaseReturnItemOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    name?: StringFilter<"Brand"> | string
    status?: StringFilter<"Brand"> | string
    companyId?: IntFilter<"Brand"> | number
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }, "id" | "code">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _avg?: BrandAvgOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
    _sum?: BrandSumOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Brand"> | string
    code?: StringWithAggregatesFilter<"Brand"> | string
    name?: StringWithAggregatesFilter<"Brand"> | string
    status?: StringWithAggregatesFilter<"Brand"> | string
    companyId?: IntWithAggregatesFilter<"Brand"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
  }

  export type ItemGradeWhereInput = {
    AND?: ItemGradeWhereInput | ItemGradeWhereInput[]
    OR?: ItemGradeWhereInput[]
    NOT?: ItemGradeWhereInput | ItemGradeWhereInput[]
    id?: StringFilter<"ItemGrade"> | string
    code?: StringFilter<"ItemGrade"> | string
    name?: StringFilter<"ItemGrade"> | string
    status?: StringFilter<"ItemGrade"> | string
    companyId?: IntFilter<"ItemGrade"> | number
    createdAt?: DateTimeFilter<"ItemGrade"> | Date | string
    updatedAt?: DateTimeFilter<"ItemGrade"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }

  export type ItemGradeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
    grnItems?: GRNItemOrderByRelationAggregateInput
    purchaseInvoiceItems?: PurchaseInvoiceItemOrderByRelationAggregateInput
    purchaseReturnItems?: PurchaseReturnItemOrderByRelationAggregateInput
  }

  export type ItemGradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ItemGradeWhereInput | ItemGradeWhereInput[]
    OR?: ItemGradeWhereInput[]
    NOT?: ItemGradeWhereInput | ItemGradeWhereInput[]
    name?: StringFilter<"ItemGrade"> | string
    status?: StringFilter<"ItemGrade"> | string
    companyId?: IntFilter<"ItemGrade"> | number
    createdAt?: DateTimeFilter<"ItemGrade"> | Date | string
    updatedAt?: DateTimeFilter<"ItemGrade"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }, "id" | "code">

  export type ItemGradeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemGradeCountOrderByAggregateInput
    _avg?: ItemGradeAvgOrderByAggregateInput
    _max?: ItemGradeMaxOrderByAggregateInput
    _min?: ItemGradeMinOrderByAggregateInput
    _sum?: ItemGradeSumOrderByAggregateInput
  }

  export type ItemGradeScalarWhereWithAggregatesInput = {
    AND?: ItemGradeScalarWhereWithAggregatesInput | ItemGradeScalarWhereWithAggregatesInput[]
    OR?: ItemGradeScalarWhereWithAggregatesInput[]
    NOT?: ItemGradeScalarWhereWithAggregatesInput | ItemGradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemGrade"> | string
    code?: StringWithAggregatesFilter<"ItemGrade"> | string
    name?: StringWithAggregatesFilter<"ItemGrade"> | string
    status?: StringWithAggregatesFilter<"ItemGrade"> | string
    companyId?: IntWithAggregatesFilter<"ItemGrade"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ItemGrade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemGrade"> | Date | string
  }

  export type PackingUnitWhereInput = {
    AND?: PackingUnitWhereInput | PackingUnitWhereInput[]
    OR?: PackingUnitWhereInput[]
    NOT?: PackingUnitWhereInput | PackingUnitWhereInput[]
    id?: StringFilter<"PackingUnit"> | string
    code?: StringFilter<"PackingUnit"> | string
    name?: StringFilter<"PackingUnit"> | string
    symbol?: StringNullableFilter<"PackingUnit"> | string | null
    status?: StringFilter<"PackingUnit"> | string
    companyId?: IntFilter<"PackingUnit"> | number
    createdAt?: DateTimeFilter<"PackingUnit"> | Date | string
    updatedAt?: DateTimeFilter<"PackingUnit"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    itemMasters?: ItemMasterListRelationFilter
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
  }

  export type PackingUnitOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrderInput | SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    itemMasters?: ItemMasterOrderByRelationAggregateInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
    grnItems?: GRNItemOrderByRelationAggregateInput
  }

  export type PackingUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PackingUnitWhereInput | PackingUnitWhereInput[]
    OR?: PackingUnitWhereInput[]
    NOT?: PackingUnitWhereInput | PackingUnitWhereInput[]
    name?: StringFilter<"PackingUnit"> | string
    symbol?: StringNullableFilter<"PackingUnit"> | string | null
    status?: StringFilter<"PackingUnit"> | string
    companyId?: IntFilter<"PackingUnit"> | number
    createdAt?: DateTimeFilter<"PackingUnit"> | Date | string
    updatedAt?: DateTimeFilter<"PackingUnit"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    itemMasters?: ItemMasterListRelationFilter
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
  }, "id" | "code">

  export type PackingUnitOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrderInput | SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackingUnitCountOrderByAggregateInput
    _avg?: PackingUnitAvgOrderByAggregateInput
    _max?: PackingUnitMaxOrderByAggregateInput
    _min?: PackingUnitMinOrderByAggregateInput
    _sum?: PackingUnitSumOrderByAggregateInput
  }

  export type PackingUnitScalarWhereWithAggregatesInput = {
    AND?: PackingUnitScalarWhereWithAggregatesInput | PackingUnitScalarWhereWithAggregatesInput[]
    OR?: PackingUnitScalarWhereWithAggregatesInput[]
    NOT?: PackingUnitScalarWhereWithAggregatesInput | PackingUnitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PackingUnit"> | string
    code?: StringWithAggregatesFilter<"PackingUnit"> | string
    name?: StringWithAggregatesFilter<"PackingUnit"> | string
    symbol?: StringNullableWithAggregatesFilter<"PackingUnit"> | string | null
    status?: StringWithAggregatesFilter<"PackingUnit"> | string
    companyId?: IntWithAggregatesFilter<"PackingUnit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PackingUnit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PackingUnit"> | Date | string
  }

  export type ItemMasterWhereInput = {
    AND?: ItemMasterWhereInput | ItemMasterWhereInput[]
    OR?: ItemMasterWhereInput[]
    NOT?: ItemMasterWhereInput | ItemMasterWhereInput[]
    id?: StringFilter<"ItemMaster"> | string
    code?: StringFilter<"ItemMaster"> | string
    name?: StringFilter<"ItemMaster"> | string
    shortDescription?: StringNullableFilter<"ItemMaster"> | string | null
    status?: StringFilter<"ItemMaster"> | string
    hsCode?: StringNullableFilter<"ItemMaster"> | string | null
    imageUrl?: StringNullableFilter<"ItemMaster"> | string | null
    itemGroupId?: StringFilter<"ItemMaster"> | string
    baseUnitId?: IntFilter<"ItemMaster"> | number
    packingUnitId?: StringNullableFilter<"ItemMaster"> | string | null
    companyId?: IntFilter<"ItemMaster"> | number
    createdAt?: DateTimeFilter<"ItemMaster"> | Date | string
    updatedAt?: DateTimeFilter<"ItemMaster"> | Date | string
    itemGroup?: XOR<ItemGroupScalarRelationFilter, ItemGroupWhereInput>
    baseUnit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    packingUnit?: XOR<PackingUnitNullableScalarRelationFilter, PackingUnitWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }

  export type ItemMasterOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    status?: SortOrder
    hsCode?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    itemGroupId?: SortOrder
    baseUnitId?: SortOrder
    packingUnitId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itemGroup?: ItemGroupOrderByWithRelationInput
    baseUnit?: UnitOrderByWithRelationInput
    packingUnit?: PackingUnitOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    purchaseOrderItems?: PurchaseOrderItemOrderByRelationAggregateInput
    grnItems?: GRNItemOrderByRelationAggregateInput
    purchaseInvoiceItems?: PurchaseInvoiceItemOrderByRelationAggregateInput
    purchaseReturnItems?: PurchaseReturnItemOrderByRelationAggregateInput
  }

  export type ItemMasterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ItemMasterWhereInput | ItemMasterWhereInput[]
    OR?: ItemMasterWhereInput[]
    NOT?: ItemMasterWhereInput | ItemMasterWhereInput[]
    name?: StringFilter<"ItemMaster"> | string
    shortDescription?: StringNullableFilter<"ItemMaster"> | string | null
    status?: StringFilter<"ItemMaster"> | string
    hsCode?: StringNullableFilter<"ItemMaster"> | string | null
    imageUrl?: StringNullableFilter<"ItemMaster"> | string | null
    itemGroupId?: StringFilter<"ItemMaster"> | string
    baseUnitId?: IntFilter<"ItemMaster"> | number
    packingUnitId?: StringNullableFilter<"ItemMaster"> | string | null
    companyId?: IntFilter<"ItemMaster"> | number
    createdAt?: DateTimeFilter<"ItemMaster"> | Date | string
    updatedAt?: DateTimeFilter<"ItemMaster"> | Date | string
    itemGroup?: XOR<ItemGroupScalarRelationFilter, ItemGroupWhereInput>
    baseUnit?: XOR<UnitScalarRelationFilter, UnitWhereInput>
    packingUnit?: XOR<PackingUnitNullableScalarRelationFilter, PackingUnitWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    purchaseOrderItems?: PurchaseOrderItemListRelationFilter
    grnItems?: GRNItemListRelationFilter
    purchaseInvoiceItems?: PurchaseInvoiceItemListRelationFilter
    purchaseReturnItems?: PurchaseReturnItemListRelationFilter
  }, "id" | "code">

  export type ItemMasterOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrderInput | SortOrder
    status?: SortOrder
    hsCode?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    itemGroupId?: SortOrder
    baseUnitId?: SortOrder
    packingUnitId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemMasterCountOrderByAggregateInput
    _avg?: ItemMasterAvgOrderByAggregateInput
    _max?: ItemMasterMaxOrderByAggregateInput
    _min?: ItemMasterMinOrderByAggregateInput
    _sum?: ItemMasterSumOrderByAggregateInput
  }

  export type ItemMasterScalarWhereWithAggregatesInput = {
    AND?: ItemMasterScalarWhereWithAggregatesInput | ItemMasterScalarWhereWithAggregatesInput[]
    OR?: ItemMasterScalarWhereWithAggregatesInput[]
    NOT?: ItemMasterScalarWhereWithAggregatesInput | ItemMasterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemMaster"> | string
    code?: StringWithAggregatesFilter<"ItemMaster"> | string
    name?: StringWithAggregatesFilter<"ItemMaster"> | string
    shortDescription?: StringNullableWithAggregatesFilter<"ItemMaster"> | string | null
    status?: StringWithAggregatesFilter<"ItemMaster"> | string
    hsCode?: StringNullableWithAggregatesFilter<"ItemMaster"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"ItemMaster"> | string | null
    itemGroupId?: StringWithAggregatesFilter<"ItemMaster"> | string
    baseUnitId?: IntWithAggregatesFilter<"ItemMaster"> | number
    packingUnitId?: StringNullableWithAggregatesFilter<"ItemMaster"> | string | null
    companyId?: IntWithAggregatesFilter<"ItemMaster"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ItemMaster"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemMaster"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    poNumber?: StringFilter<"PurchaseOrder"> | string
    type?: EnumPurchaseOrderTypeFilter<"PurchaseOrder"> | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    accountId?: IntNullableFilter<"PurchaseOrder"> | number | null
    partyName?: StringNullableFilter<"PurchaseOrder"> | string | null
    warehouseId?: IntNullableFilter<"PurchaseOrder"> | number | null
    referenceNo?: StringNullableFilter<"PurchaseOrder"> | string | null
    documentDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    fileNo?: StringNullableFilter<"PurchaseOrder"> | string | null
    remarks?: StringNullableFilter<"PurchaseOrder"> | string | null
    totalAmount?: FloatFilter<"PurchaseOrder"> | number
    currencyId?: IntNullableFilter<"PurchaseOrder"> | number | null
    exchangeRate?: FloatFilter<"PurchaseOrder"> | number
    companyId?: IntFilter<"PurchaseOrder"> | number
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    items?: PurchaseOrderItemListRelationFilter
    grns?: GRNListRelationFilter
    invoices?: PurchaseInvoiceListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    date?: SortOrder
    accountId?: SortOrderInput | SortOrder
    partyName?: SortOrderInput | SortOrder
    warehouseId?: SortOrderInput | SortOrder
    referenceNo?: SortOrderInput | SortOrder
    documentDate?: SortOrderInput | SortOrder
    fileNo?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrderInput | SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    warehouse?: WarehouseOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    items?: PurchaseOrderItemOrderByRelationAggregateInput
    grns?: GRNOrderByRelationAggregateInput
    invoices?: PurchaseInvoiceOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    poNumber?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    type?: EnumPurchaseOrderTypeFilter<"PurchaseOrder"> | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    accountId?: IntNullableFilter<"PurchaseOrder"> | number | null
    partyName?: StringNullableFilter<"PurchaseOrder"> | string | null
    warehouseId?: IntNullableFilter<"PurchaseOrder"> | number | null
    referenceNo?: StringNullableFilter<"PurchaseOrder"> | string | null
    documentDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    fileNo?: StringNullableFilter<"PurchaseOrder"> | string | null
    remarks?: StringNullableFilter<"PurchaseOrder"> | string | null
    totalAmount?: FloatFilter<"PurchaseOrder"> | number
    currencyId?: IntNullableFilter<"PurchaseOrder"> | number | null
    exchangeRate?: FloatFilter<"PurchaseOrder"> | number
    companyId?: IntFilter<"PurchaseOrder"> | number
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    warehouse?: XOR<WarehouseNullableScalarRelationFilter, WarehouseWhereInput> | null
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    items?: PurchaseOrderItemListRelationFilter
    grns?: GRNListRelationFilter
    invoices?: PurchaseInvoiceListRelationFilter
  }, "id" | "poNumber">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    date?: SortOrder
    accountId?: SortOrderInput | SortOrder
    partyName?: SortOrderInput | SortOrder
    warehouseId?: SortOrderInput | SortOrder
    referenceNo?: SortOrderInput | SortOrder
    documentDate?: SortOrderInput | SortOrder
    fileNo?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrderInput | SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    poNumber?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    type?: EnumPurchaseOrderTypeWithAggregatesFilter<"PurchaseOrder"> | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    date?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    accountId?: IntNullableWithAggregatesFilter<"PurchaseOrder"> | number | null
    partyName?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    warehouseId?: IntNullableWithAggregatesFilter<"PurchaseOrder"> | number | null
    referenceNo?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    documentDate?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    fileNo?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    totalAmount?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    currencyId?: IntNullableWithAggregatesFilter<"PurchaseOrder"> | number | null
    exchangeRate?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    companyId?: IntWithAggregatesFilter<"PurchaseOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderItemWhereInput = {
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    itemMasterId?: StringFilter<"PurchaseOrderItem"> | string
    colorId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    brandId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    itemGradeId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    packingUnitId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    packingType?: EnumPackingTypeNullableFilter<"PurchaseOrderItem"> | $Enums.PackingType | null
    pcs?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    unitSize?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    quantity?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    unitId?: IntNullableFilter<"PurchaseOrderItem"> | number | null
    rate?: FloatFilter<"PurchaseOrderItem"> | number
    amount?: FloatFilter<"PurchaseOrderItem"> | number
    remarks?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    itemMaster?: XOR<ItemMasterScalarRelationFilter, ItemMasterWhereInput>
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    itemGrade?: XOR<ItemGradeNullableScalarRelationFilter, ItemGradeWhereInput> | null
    packingUnit?: XOR<PackingUnitNullableScalarRelationFilter, PackingUnitWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    grnItems?: GRNItemListRelationFilter
    invoiceItems?: PurchaseInvoiceItemListRelationFilter
  }

  export type PurchaseOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    itemGradeId?: SortOrderInput | SortOrder
    packingUnitId?: SortOrderInput | SortOrder
    packingType?: SortOrderInput | SortOrder
    pcs?: SortOrderInput | SortOrder
    unitSize?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    rate?: SortOrder
    amount?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    itemMaster?: ItemMasterOrderByWithRelationInput
    color?: ColorOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    itemGrade?: ItemGradeOrderByWithRelationInput
    packingUnit?: PackingUnitOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    grnItems?: GRNItemOrderByRelationAggregateInput
    invoiceItems?: PurchaseInvoiceItemOrderByRelationAggregateInput
  }

  export type PurchaseOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    itemMasterId?: StringFilter<"PurchaseOrderItem"> | string
    colorId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    brandId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    itemGradeId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    packingUnitId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    packingType?: EnumPackingTypeNullableFilter<"PurchaseOrderItem"> | $Enums.PackingType | null
    pcs?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    unitSize?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    quantity?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    unitId?: IntNullableFilter<"PurchaseOrderItem"> | number | null
    rate?: FloatFilter<"PurchaseOrderItem"> | number
    amount?: FloatFilter<"PurchaseOrderItem"> | number
    remarks?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    itemMaster?: XOR<ItemMasterScalarRelationFilter, ItemMasterWhereInput>
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    itemGrade?: XOR<ItemGradeNullableScalarRelationFilter, ItemGradeWhereInput> | null
    packingUnit?: XOR<PackingUnitNullableScalarRelationFilter, PackingUnitWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    grnItems?: GRNItemListRelationFilter
    invoiceItems?: PurchaseInvoiceItemListRelationFilter
  }, "id">

  export type PurchaseOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    itemGradeId?: SortOrderInput | SortOrder
    packingUnitId?: SortOrderInput | SortOrder
    packingType?: SortOrderInput | SortOrder
    pcs?: SortOrderInput | SortOrder
    unitSize?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    rate?: SortOrder
    amount?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderItemCountOrderByAggregateInput
    _avg?: PurchaseOrderItemAvgOrderByAggregateInput
    _max?: PurchaseOrderItemMaxOrderByAggregateInput
    _min?: PurchaseOrderItemMinOrderByAggregateInput
    _sum?: PurchaseOrderItemSumOrderByAggregateInput
  }

  export type PurchaseOrderItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    itemMasterId?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    colorId?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    brandId?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    itemGradeId?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    packingUnitId?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    packingType?: EnumPackingTypeNullableWithAggregatesFilter<"PurchaseOrderItem"> | $Enums.PackingType | null
    pcs?: FloatNullableWithAggregatesFilter<"PurchaseOrderItem"> | number | null
    unitSize?: FloatNullableWithAggregatesFilter<"PurchaseOrderItem"> | number | null
    quantity?: FloatNullableWithAggregatesFilter<"PurchaseOrderItem"> | number | null
    unitId?: IntNullableWithAggregatesFilter<"PurchaseOrderItem"> | number | null
    rate?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    amount?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    remarks?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
  }

  export type GRNWhereInput = {
    AND?: GRNWhereInput | GRNWhereInput[]
    OR?: GRNWhereInput[]
    NOT?: GRNWhereInput | GRNWhereInput[]
    id?: StringFilter<"GRN"> | string
    grnNumber?: StringFilter<"GRN"> | string
    date?: DateTimeFilter<"GRN"> | Date | string
    purchaseOrderId?: StringFilter<"GRN"> | string
    lotNo?: StringNullableFilter<"GRN"> | string | null
    warehouseRefNo?: StringNullableFilter<"GRN"> | string | null
    remarks?: StringNullableFilter<"GRN"> | string | null
    companyId?: IntFilter<"GRN"> | number
    createdAt?: DateTimeFilter<"GRN"> | Date | string
    updatedAt?: DateTimeFilter<"GRN"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    items?: GRNItemListRelationFilter
    purchaseReturns?: PurchaseReturnListRelationFilter
  }

  export type GRNOrderByWithRelationInput = {
    id?: SortOrder
    grnNumber?: SortOrder
    date?: SortOrder
    purchaseOrderId?: SortOrder
    lotNo?: SortOrderInput | SortOrder
    warehouseRefNo?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    items?: GRNItemOrderByRelationAggregateInput
    purchaseReturns?: PurchaseReturnOrderByRelationAggregateInput
  }

  export type GRNWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    grnNumber?: string
    AND?: GRNWhereInput | GRNWhereInput[]
    OR?: GRNWhereInput[]
    NOT?: GRNWhereInput | GRNWhereInput[]
    date?: DateTimeFilter<"GRN"> | Date | string
    purchaseOrderId?: StringFilter<"GRN"> | string
    lotNo?: StringNullableFilter<"GRN"> | string | null
    warehouseRefNo?: StringNullableFilter<"GRN"> | string | null
    remarks?: StringNullableFilter<"GRN"> | string | null
    companyId?: IntFilter<"GRN"> | number
    createdAt?: DateTimeFilter<"GRN"> | Date | string
    updatedAt?: DateTimeFilter<"GRN"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    items?: GRNItemListRelationFilter
    purchaseReturns?: PurchaseReturnListRelationFilter
  }, "id" | "grnNumber">

  export type GRNOrderByWithAggregationInput = {
    id?: SortOrder
    grnNumber?: SortOrder
    date?: SortOrder
    purchaseOrderId?: SortOrder
    lotNo?: SortOrderInput | SortOrder
    warehouseRefNo?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GRNCountOrderByAggregateInput
    _avg?: GRNAvgOrderByAggregateInput
    _max?: GRNMaxOrderByAggregateInput
    _min?: GRNMinOrderByAggregateInput
    _sum?: GRNSumOrderByAggregateInput
  }

  export type GRNScalarWhereWithAggregatesInput = {
    AND?: GRNScalarWhereWithAggregatesInput | GRNScalarWhereWithAggregatesInput[]
    OR?: GRNScalarWhereWithAggregatesInput[]
    NOT?: GRNScalarWhereWithAggregatesInput | GRNScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GRN"> | string
    grnNumber?: StringWithAggregatesFilter<"GRN"> | string
    date?: DateTimeWithAggregatesFilter<"GRN"> | Date | string
    purchaseOrderId?: StringWithAggregatesFilter<"GRN"> | string
    lotNo?: StringNullableWithAggregatesFilter<"GRN"> | string | null
    warehouseRefNo?: StringNullableWithAggregatesFilter<"GRN"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"GRN"> | string | null
    companyId?: IntWithAggregatesFilter<"GRN"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GRN"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GRN"> | Date | string
  }

  export type GRNItemWhereInput = {
    AND?: GRNItemWhereInput | GRNItemWhereInput[]
    OR?: GRNItemWhereInput[]
    NOT?: GRNItemWhereInput | GRNItemWhereInput[]
    id?: StringFilter<"GRNItem"> | string
    grnId?: StringFilter<"GRNItem"> | string
    purchaseOrderItemId?: StringFilter<"GRNItem"> | string
    itemMasterId?: StringFilter<"GRNItem"> | string
    colorId?: StringNullableFilter<"GRNItem"> | string | null
    brandId?: StringNullableFilter<"GRNItem"> | string | null
    itemGradeId?: StringNullableFilter<"GRNItem"> | string | null
    packingUnitId?: StringNullableFilter<"GRNItem"> | string | null
    receivedQty?: FloatFilter<"GRNItem"> | number
    pcs?: FloatNullableFilter<"GRNItem"> | number | null
    unitSize?: FloatNullableFilter<"GRNItem"> | number | null
    packingType?: EnumPackingTypeNullableFilter<"GRNItem"> | $Enums.PackingType | null
    unitId?: IntNullableFilter<"GRNItem"> | number | null
    createdAt?: DateTimeFilter<"GRNItem"> | Date | string
    updatedAt?: DateTimeFilter<"GRNItem"> | Date | string
    grn?: XOR<GRNScalarRelationFilter, GRNWhereInput>
    purchaseOrderItem?: XOR<PurchaseOrderItemScalarRelationFilter, PurchaseOrderItemWhereInput>
    itemMaster?: XOR<ItemMasterScalarRelationFilter, ItemMasterWhereInput>
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    itemGrade?: XOR<ItemGradeNullableScalarRelationFilter, ItemGradeWhereInput> | null
    packingUnit?: XOR<PackingUnitNullableScalarRelationFilter, PackingUnitWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    invoiceItems?: PurchaseInvoiceItemListRelationFilter
  }

  export type GRNItemOrderByWithRelationInput = {
    id?: SortOrder
    grnId?: SortOrder
    purchaseOrderItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    itemGradeId?: SortOrderInput | SortOrder
    packingUnitId?: SortOrderInput | SortOrder
    receivedQty?: SortOrder
    pcs?: SortOrderInput | SortOrder
    unitSize?: SortOrderInput | SortOrder
    packingType?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    grn?: GRNOrderByWithRelationInput
    purchaseOrderItem?: PurchaseOrderItemOrderByWithRelationInput
    itemMaster?: ItemMasterOrderByWithRelationInput
    color?: ColorOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    itemGrade?: ItemGradeOrderByWithRelationInput
    packingUnit?: PackingUnitOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    invoiceItems?: PurchaseInvoiceItemOrderByRelationAggregateInput
  }

  export type GRNItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GRNItemWhereInput | GRNItemWhereInput[]
    OR?: GRNItemWhereInput[]
    NOT?: GRNItemWhereInput | GRNItemWhereInput[]
    grnId?: StringFilter<"GRNItem"> | string
    purchaseOrderItemId?: StringFilter<"GRNItem"> | string
    itemMasterId?: StringFilter<"GRNItem"> | string
    colorId?: StringNullableFilter<"GRNItem"> | string | null
    brandId?: StringNullableFilter<"GRNItem"> | string | null
    itemGradeId?: StringNullableFilter<"GRNItem"> | string | null
    packingUnitId?: StringNullableFilter<"GRNItem"> | string | null
    receivedQty?: FloatFilter<"GRNItem"> | number
    pcs?: FloatNullableFilter<"GRNItem"> | number | null
    unitSize?: FloatNullableFilter<"GRNItem"> | number | null
    packingType?: EnumPackingTypeNullableFilter<"GRNItem"> | $Enums.PackingType | null
    unitId?: IntNullableFilter<"GRNItem"> | number | null
    createdAt?: DateTimeFilter<"GRNItem"> | Date | string
    updatedAt?: DateTimeFilter<"GRNItem"> | Date | string
    grn?: XOR<GRNScalarRelationFilter, GRNWhereInput>
    purchaseOrderItem?: XOR<PurchaseOrderItemScalarRelationFilter, PurchaseOrderItemWhereInput>
    itemMaster?: XOR<ItemMasterScalarRelationFilter, ItemMasterWhereInput>
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    itemGrade?: XOR<ItemGradeNullableScalarRelationFilter, ItemGradeWhereInput> | null
    packingUnit?: XOR<PackingUnitNullableScalarRelationFilter, PackingUnitWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    invoiceItems?: PurchaseInvoiceItemListRelationFilter
  }, "id">

  export type GRNItemOrderByWithAggregationInput = {
    id?: SortOrder
    grnId?: SortOrder
    purchaseOrderItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    itemGradeId?: SortOrderInput | SortOrder
    packingUnitId?: SortOrderInput | SortOrder
    receivedQty?: SortOrder
    pcs?: SortOrderInput | SortOrder
    unitSize?: SortOrderInput | SortOrder
    packingType?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GRNItemCountOrderByAggregateInput
    _avg?: GRNItemAvgOrderByAggregateInput
    _max?: GRNItemMaxOrderByAggregateInput
    _min?: GRNItemMinOrderByAggregateInput
    _sum?: GRNItemSumOrderByAggregateInput
  }

  export type GRNItemScalarWhereWithAggregatesInput = {
    AND?: GRNItemScalarWhereWithAggregatesInput | GRNItemScalarWhereWithAggregatesInput[]
    OR?: GRNItemScalarWhereWithAggregatesInput[]
    NOT?: GRNItemScalarWhereWithAggregatesInput | GRNItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GRNItem"> | string
    grnId?: StringWithAggregatesFilter<"GRNItem"> | string
    purchaseOrderItemId?: StringWithAggregatesFilter<"GRNItem"> | string
    itemMasterId?: StringWithAggregatesFilter<"GRNItem"> | string
    colorId?: StringNullableWithAggregatesFilter<"GRNItem"> | string | null
    brandId?: StringNullableWithAggregatesFilter<"GRNItem"> | string | null
    itemGradeId?: StringNullableWithAggregatesFilter<"GRNItem"> | string | null
    packingUnitId?: StringNullableWithAggregatesFilter<"GRNItem"> | string | null
    receivedQty?: FloatWithAggregatesFilter<"GRNItem"> | number
    pcs?: FloatNullableWithAggregatesFilter<"GRNItem"> | number | null
    unitSize?: FloatNullableWithAggregatesFilter<"GRNItem"> | number | null
    packingType?: EnumPackingTypeNullableWithAggregatesFilter<"GRNItem"> | $Enums.PackingType | null
    unitId?: IntNullableWithAggregatesFilter<"GRNItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"GRNItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GRNItem"> | Date | string
  }

  export type PurchaseInvoiceWhereInput = {
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    id?: StringFilter<"PurchaseInvoice"> | string
    invoiceNumber?: StringFilter<"PurchaseInvoice"> | string
    date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    supplierInvoiceNo?: StringNullableFilter<"PurchaseInvoice"> | string | null
    remarks?: StringNullableFilter<"PurchaseInvoice"> | string | null
    purchaseOrderId?: StringNullableFilter<"PurchaseInvoice"> | string | null
    accountId?: IntNullableFilter<"PurchaseInvoice"> | number | null
    totalAmount?: FloatFilter<"PurchaseInvoice"> | number
    status?: StringFilter<"PurchaseInvoice"> | string
    companyId?: IntFilter<"PurchaseInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    items?: PurchaseInvoiceItemListRelationFilter
    purchaseReturns?: PurchaseReturnListRelationFilter
  }

  export type PurchaseInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    supplierInvoiceNo?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseOrder?: PurchaseOrderOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    items?: PurchaseInvoiceItemOrderByRelationAggregateInput
    purchaseReturns?: PurchaseReturnOrderByRelationAggregateInput
  }

  export type PurchaseInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    supplierInvoiceNo?: StringNullableFilter<"PurchaseInvoice"> | string | null
    remarks?: StringNullableFilter<"PurchaseInvoice"> | string | null
    purchaseOrderId?: StringNullableFilter<"PurchaseInvoice"> | string | null
    accountId?: IntNullableFilter<"PurchaseInvoice"> | number | null
    totalAmount?: FloatFilter<"PurchaseInvoice"> | number
    status?: StringFilter<"PurchaseInvoice"> | string
    companyId?: IntFilter<"PurchaseInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    purchaseOrder?: XOR<PurchaseOrderNullableScalarRelationFilter, PurchaseOrderWhereInput> | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    items?: PurchaseInvoiceItemListRelationFilter
    purchaseReturns?: PurchaseReturnListRelationFilter
  }, "id" | "invoiceNumber">

  export type PurchaseInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    supplierInvoiceNo?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    purchaseOrderId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseInvoiceCountOrderByAggregateInput
    _avg?: PurchaseInvoiceAvgOrderByAggregateInput
    _max?: PurchaseInvoiceMaxOrderByAggregateInput
    _min?: PurchaseInvoiceMinOrderByAggregateInput
    _sum?: PurchaseInvoiceSumOrderByAggregateInput
  }

  export type PurchaseInvoiceScalarWhereWithAggregatesInput = {
    AND?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    OR?: PurchaseInvoiceScalarWhereWithAggregatesInput[]
    NOT?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    date?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    supplierInvoiceNo?: StringNullableWithAggregatesFilter<"PurchaseInvoice"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"PurchaseInvoice"> | string | null
    purchaseOrderId?: StringNullableWithAggregatesFilter<"PurchaseInvoice"> | string | null
    accountId?: IntNullableWithAggregatesFilter<"PurchaseInvoice"> | number | null
    totalAmount?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    status?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    companyId?: IntWithAggregatesFilter<"PurchaseInvoice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
  }

  export type PurchaseInvoiceItemWhereInput = {
    AND?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    OR?: PurchaseInvoiceItemWhereInput[]
    NOT?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    id?: StringFilter<"PurchaseInvoiceItem"> | string
    invoiceId?: StringFilter<"PurchaseInvoiceItem"> | string
    purchaseOrderItemId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    grnItemId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    itemMasterId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    colorId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    brandId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    itemGradeId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    unitId?: IntNullableFilter<"PurchaseInvoiceItem"> | number | null
    invoicedQty?: FloatFilter<"PurchaseInvoiceItem"> | number
    rate?: FloatFilter<"PurchaseInvoiceItem"> | number
    amount?: FloatFilter<"PurchaseInvoiceItem"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    invoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
    purchaseOrderItem?: XOR<PurchaseOrderItemNullableScalarRelationFilter, PurchaseOrderItemWhereInput> | null
    grnItem?: XOR<GRNItemNullableScalarRelationFilter, GRNItemWhereInput> | null
    itemMaster?: XOR<ItemMasterNullableScalarRelationFilter, ItemMasterWhereInput> | null
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    itemGrade?: XOR<ItemGradeNullableScalarRelationFilter, ItemGradeWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }

  export type PurchaseInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    purchaseOrderItemId?: SortOrderInput | SortOrder
    grnItemId?: SortOrderInput | SortOrder
    itemMasterId?: SortOrderInput | SortOrder
    colorId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    itemGradeId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    invoicedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: PurchaseInvoiceOrderByWithRelationInput
    purchaseOrderItem?: PurchaseOrderItemOrderByWithRelationInput
    grnItem?: GRNItemOrderByWithRelationInput
    itemMaster?: ItemMasterOrderByWithRelationInput
    color?: ColorOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    itemGrade?: ItemGradeOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
  }

  export type PurchaseInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    OR?: PurchaseInvoiceItemWhereInput[]
    NOT?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    invoiceId?: StringFilter<"PurchaseInvoiceItem"> | string
    purchaseOrderItemId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    grnItemId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    itemMasterId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    colorId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    brandId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    itemGradeId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    unitId?: IntNullableFilter<"PurchaseInvoiceItem"> | number | null
    invoicedQty?: FloatFilter<"PurchaseInvoiceItem"> | number
    rate?: FloatFilter<"PurchaseInvoiceItem"> | number
    amount?: FloatFilter<"PurchaseInvoiceItem"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    invoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
    purchaseOrderItem?: XOR<PurchaseOrderItemNullableScalarRelationFilter, PurchaseOrderItemWhereInput> | null
    grnItem?: XOR<GRNItemNullableScalarRelationFilter, GRNItemWhereInput> | null
    itemMaster?: XOR<ItemMasterNullableScalarRelationFilter, ItemMasterWhereInput> | null
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    itemGrade?: XOR<ItemGradeNullableScalarRelationFilter, ItemGradeWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }, "id">

  export type PurchaseInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    purchaseOrderItemId?: SortOrderInput | SortOrder
    grnItemId?: SortOrderInput | SortOrder
    itemMasterId?: SortOrderInput | SortOrder
    colorId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    itemGradeId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    invoicedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseInvoiceItemCountOrderByAggregateInput
    _avg?: PurchaseInvoiceItemAvgOrderByAggregateInput
    _max?: PurchaseInvoiceItemMaxOrderByAggregateInput
    _min?: PurchaseInvoiceItemMinOrderByAggregateInput
    _sum?: PurchaseInvoiceItemSumOrderByAggregateInput
  }

  export type PurchaseInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseInvoiceItemScalarWhereWithAggregatesInput | PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseInvoiceItemScalarWhereWithAggregatesInput | PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseInvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"PurchaseInvoiceItem"> | string
    purchaseOrderItemId?: StringNullableWithAggregatesFilter<"PurchaseInvoiceItem"> | string | null
    grnItemId?: StringNullableWithAggregatesFilter<"PurchaseInvoiceItem"> | string | null
    itemMasterId?: StringNullableWithAggregatesFilter<"PurchaseInvoiceItem"> | string | null
    colorId?: StringNullableWithAggregatesFilter<"PurchaseInvoiceItem"> | string | null
    brandId?: StringNullableWithAggregatesFilter<"PurchaseInvoiceItem"> | string | null
    itemGradeId?: StringNullableWithAggregatesFilter<"PurchaseInvoiceItem"> | string | null
    unitId?: IntNullableWithAggregatesFilter<"PurchaseInvoiceItem"> | number | null
    invoicedQty?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    rate?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    amount?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseInvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseInvoiceItem"> | Date | string
  }

  export type PurchaseReturnWhereInput = {
    AND?: PurchaseReturnWhereInput | PurchaseReturnWhereInput[]
    OR?: PurchaseReturnWhereInput[]
    NOT?: PurchaseReturnWhereInput | PurchaseReturnWhereInput[]
    id?: StringFilter<"PurchaseReturn"> | string
    returnNumber?: StringFilter<"PurchaseReturn"> | string
    date?: DateTimeFilter<"PurchaseReturn"> | Date | string
    remarks?: StringNullableFilter<"PurchaseReturn"> | string | null
    purchaseInvoiceId?: StringNullableFilter<"PurchaseReturn"> | string | null
    grnId?: StringNullableFilter<"PurchaseReturn"> | string | null
    accountId?: IntNullableFilter<"PurchaseReturn"> | number | null
    totalAmount?: FloatFilter<"PurchaseReturn"> | number
    status?: StringFilter<"PurchaseReturn"> | string
    companyId?: IntFilter<"PurchaseReturn"> | number
    createdAt?: DateTimeFilter<"PurchaseReturn"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturn"> | Date | string
    purchaseInvoice?: XOR<PurchaseInvoiceNullableScalarRelationFilter, PurchaseInvoiceWhereInput> | null
    grn?: XOR<GRNNullableScalarRelationFilter, GRNWhereInput> | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    items?: PurchaseReturnItemListRelationFilter
  }

  export type PurchaseReturnOrderByWithRelationInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    date?: SortOrder
    remarks?: SortOrderInput | SortOrder
    purchaseInvoiceId?: SortOrderInput | SortOrder
    grnId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseInvoice?: PurchaseInvoiceOrderByWithRelationInput
    grn?: GRNOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    items?: PurchaseReturnItemOrderByRelationAggregateInput
  }

  export type PurchaseReturnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    returnNumber?: string
    AND?: PurchaseReturnWhereInput | PurchaseReturnWhereInput[]
    OR?: PurchaseReturnWhereInput[]
    NOT?: PurchaseReturnWhereInput | PurchaseReturnWhereInput[]
    date?: DateTimeFilter<"PurchaseReturn"> | Date | string
    remarks?: StringNullableFilter<"PurchaseReturn"> | string | null
    purchaseInvoiceId?: StringNullableFilter<"PurchaseReturn"> | string | null
    grnId?: StringNullableFilter<"PurchaseReturn"> | string | null
    accountId?: IntNullableFilter<"PurchaseReturn"> | number | null
    totalAmount?: FloatFilter<"PurchaseReturn"> | number
    status?: StringFilter<"PurchaseReturn"> | string
    companyId?: IntFilter<"PurchaseReturn"> | number
    createdAt?: DateTimeFilter<"PurchaseReturn"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturn"> | Date | string
    purchaseInvoice?: XOR<PurchaseInvoiceNullableScalarRelationFilter, PurchaseInvoiceWhereInput> | null
    grn?: XOR<GRNNullableScalarRelationFilter, GRNWhereInput> | null
    account?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    items?: PurchaseReturnItemListRelationFilter
  }, "id" | "returnNumber">

  export type PurchaseReturnOrderByWithAggregationInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    date?: SortOrder
    remarks?: SortOrderInput | SortOrder
    purchaseInvoiceId?: SortOrderInput | SortOrder
    grnId?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseReturnCountOrderByAggregateInput
    _avg?: PurchaseReturnAvgOrderByAggregateInput
    _max?: PurchaseReturnMaxOrderByAggregateInput
    _min?: PurchaseReturnMinOrderByAggregateInput
    _sum?: PurchaseReturnSumOrderByAggregateInput
  }

  export type PurchaseReturnScalarWhereWithAggregatesInput = {
    AND?: PurchaseReturnScalarWhereWithAggregatesInput | PurchaseReturnScalarWhereWithAggregatesInput[]
    OR?: PurchaseReturnScalarWhereWithAggregatesInput[]
    NOT?: PurchaseReturnScalarWhereWithAggregatesInput | PurchaseReturnScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseReturn"> | string
    returnNumber?: StringWithAggregatesFilter<"PurchaseReturn"> | string
    date?: DateTimeWithAggregatesFilter<"PurchaseReturn"> | Date | string
    remarks?: StringNullableWithAggregatesFilter<"PurchaseReturn"> | string | null
    purchaseInvoiceId?: StringNullableWithAggregatesFilter<"PurchaseReturn"> | string | null
    grnId?: StringNullableWithAggregatesFilter<"PurchaseReturn"> | string | null
    accountId?: IntNullableWithAggregatesFilter<"PurchaseReturn"> | number | null
    totalAmount?: FloatWithAggregatesFilter<"PurchaseReturn"> | number
    status?: StringWithAggregatesFilter<"PurchaseReturn"> | string
    companyId?: IntWithAggregatesFilter<"PurchaseReturn"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseReturn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseReturn"> | Date | string
  }

  export type PurchaseReturnItemWhereInput = {
    AND?: PurchaseReturnItemWhereInput | PurchaseReturnItemWhereInput[]
    OR?: PurchaseReturnItemWhereInput[]
    NOT?: PurchaseReturnItemWhereInput | PurchaseReturnItemWhereInput[]
    id?: StringFilter<"PurchaseReturnItem"> | string
    returnId?: StringFilter<"PurchaseReturnItem"> | string
    purchaseInvoiceItemId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    grnItemId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    itemMasterId?: StringFilter<"PurchaseReturnItem"> | string
    colorId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    brandId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    itemGradeId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    unitId?: IntNullableFilter<"PurchaseReturnItem"> | number | null
    returnedQty?: FloatFilter<"PurchaseReturnItem"> | number
    rate?: FloatFilter<"PurchaseReturnItem"> | number
    amount?: FloatFilter<"PurchaseReturnItem"> | number
    createdAt?: DateTimeFilter<"PurchaseReturnItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturnItem"> | Date | string
    return?: XOR<PurchaseReturnScalarRelationFilter, PurchaseReturnWhereInput>
    itemMaster?: XOR<ItemMasterScalarRelationFilter, ItemMasterWhereInput>
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    itemGrade?: XOR<ItemGradeNullableScalarRelationFilter, ItemGradeWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }

  export type PurchaseReturnItemOrderByWithRelationInput = {
    id?: SortOrder
    returnId?: SortOrder
    purchaseInvoiceItemId?: SortOrderInput | SortOrder
    grnItemId?: SortOrderInput | SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    itemGradeId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    returnedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    return?: PurchaseReturnOrderByWithRelationInput
    itemMaster?: ItemMasterOrderByWithRelationInput
    color?: ColorOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    itemGrade?: ItemGradeOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
  }

  export type PurchaseReturnItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseReturnItemWhereInput | PurchaseReturnItemWhereInput[]
    OR?: PurchaseReturnItemWhereInput[]
    NOT?: PurchaseReturnItemWhereInput | PurchaseReturnItemWhereInput[]
    returnId?: StringFilter<"PurchaseReturnItem"> | string
    purchaseInvoiceItemId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    grnItemId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    itemMasterId?: StringFilter<"PurchaseReturnItem"> | string
    colorId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    brandId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    itemGradeId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    unitId?: IntNullableFilter<"PurchaseReturnItem"> | number | null
    returnedQty?: FloatFilter<"PurchaseReturnItem"> | number
    rate?: FloatFilter<"PurchaseReturnItem"> | number
    amount?: FloatFilter<"PurchaseReturnItem"> | number
    createdAt?: DateTimeFilter<"PurchaseReturnItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturnItem"> | Date | string
    return?: XOR<PurchaseReturnScalarRelationFilter, PurchaseReturnWhereInput>
    itemMaster?: XOR<ItemMasterScalarRelationFilter, ItemMasterWhereInput>
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    itemGrade?: XOR<ItemGradeNullableScalarRelationFilter, ItemGradeWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
  }, "id">

  export type PurchaseReturnItemOrderByWithAggregationInput = {
    id?: SortOrder
    returnId?: SortOrder
    purchaseInvoiceItemId?: SortOrderInput | SortOrder
    grnItemId?: SortOrderInput | SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    itemGradeId?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    returnedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseReturnItemCountOrderByAggregateInput
    _avg?: PurchaseReturnItemAvgOrderByAggregateInput
    _max?: PurchaseReturnItemMaxOrderByAggregateInput
    _min?: PurchaseReturnItemMinOrderByAggregateInput
    _sum?: PurchaseReturnItemSumOrderByAggregateInput
  }

  export type PurchaseReturnItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseReturnItemScalarWhereWithAggregatesInput | PurchaseReturnItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseReturnItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseReturnItemScalarWhereWithAggregatesInput | PurchaseReturnItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseReturnItem"> | string
    returnId?: StringWithAggregatesFilter<"PurchaseReturnItem"> | string
    purchaseInvoiceItemId?: StringNullableWithAggregatesFilter<"PurchaseReturnItem"> | string | null
    grnItemId?: StringNullableWithAggregatesFilter<"PurchaseReturnItem"> | string | null
    itemMasterId?: StringWithAggregatesFilter<"PurchaseReturnItem"> | string
    colorId?: StringNullableWithAggregatesFilter<"PurchaseReturnItem"> | string | null
    brandId?: StringNullableWithAggregatesFilter<"PurchaseReturnItem"> | string | null
    itemGradeId?: StringNullableWithAggregatesFilter<"PurchaseReturnItem"> | string | null
    unitId?: IntNullableWithAggregatesFilter<"PurchaseReturnItem"> | number | null
    returnedQty?: FloatWithAggregatesFilter<"PurchaseReturnItem"> | number
    rate?: FloatWithAggregatesFilter<"PurchaseReturnItem"> | number
    amount?: FloatWithAggregatesFilter<"PurchaseReturnItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseReturnItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseReturnItem"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    posts?: PostCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    auditLogPermissions?: AuditAccessCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    auditLogPermissions?: AuditAccessUncheckedCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessUncheckedCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    auditLogPermissions?: AuditAccessUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    auditLogPermissions?: AuditAccessUncheckedUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUncheckedUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: number | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AuditAccessCreateInput = {
    senior: UserCreateNestedOneWithoutAuditLogPermissionsInput
    junior: UserCreateNestedOneWithoutVisibleToAuditInput
  }

  export type AuditAccessUncheckedCreateInput = {
    id?: number
    seniorId: number
    juniorId: number
  }

  export type AuditAccessUpdateInput = {
    senior?: UserUpdateOneRequiredWithoutAuditLogPermissionsNestedInput
    junior?: UserUpdateOneRequiredWithoutVisibleToAuditNestedInput
  }

  export type AuditAccessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    seniorId?: IntFieldUpdateOperationsInput | number
    juniorId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditAccessCreateManyInput = {
    id?: number
    seniorId: number
    juniorId: number
  }

  export type AuditAccessUpdateManyMutationInput = {

  }

  export type AuditAccessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    seniorId?: IntFieldUpdateOperationsInput | number
    juniorId?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    action: string
    resource: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: number
    action: string
    resource: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: number
    action: string
    resource: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    roleId: number
    permissionId: number
    assignedAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    roleId: number
    permissionId: number
    assignedAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    permissionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: number
    roleId: number
    assignedAt?: Date | string
  }

  export type UserRoleUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateManyInput = {
    userId: number
    roleId: number
    assignedAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    title: string
    content?: string | null
    published?: boolean
    author: UserCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    title: string
    content?: string | null
    published?: boolean
    authorId: number
  }

  export type PostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: IntFieldUpdateOperationsInput | number
  }

  export type PostCreateManyInput = {
    id?: number
    title: string
    content?: string | null
    published?: boolean
    authorId: number
  }

  export type PostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    authorId?: IntFieldUpdateOperationsInput | number
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: number
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: number
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    module: string
    resourceId?: string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: number
    action: string
    module: string
    resourceId?: string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: number
    action: string
    module: string
    resourceId?: string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseCreateInput = {
    name: string
    location?: string | null
    contactPerson?: string | null
    contactNumbers?: WarehouseCreatecontactNumbersInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userWarehouses?: UserWarehouseCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateInput = {
    id?: number
    name: string
    location?: string | null
    contactPerson?: string | null
    contactNumbers?: WarehouseCreatecontactNumbersInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutWarehouseInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumbers?: WarehouseUpdatecontactNumbersInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userWarehouses?: UserWarehouseUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumbers?: WarehouseUpdatecontactNumbersInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutWarehouseNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseCreateManyInput = {
    id?: number
    name: string
    location?: string | null
    contactPerson?: string | null
    contactNumbers?: WarehouseCreatecontactNumbersInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumbers?: WarehouseUpdatecontactNumbersInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumbers?: WarehouseUpdatecontactNumbersInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWarehouseCreateInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutUserWarehousesInput
    warehouse: WarehouseCreateNestedOneWithoutUserWarehousesInput
  }

  export type UserWarehouseUncheckedCreateInput = {
    userId: number
    warehouseId: number
    assignedAt?: Date | string
  }

  export type UserWarehouseUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserWarehousesNestedInput
    warehouse?: WarehouseUpdateOneRequiredWithoutUserWarehousesNestedInput
  }

  export type UserWarehouseUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWarehouseCreateManyInput = {
    userId: number
    warehouseId: number
    assignedAt?: Date | string
  }

  export type UserWarehouseUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWarehouseUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitCreateInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitsInput
    conversionsFrom?: UnitConversionCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionCreateNestedManyWithoutToUnitInput
    products?: ProductCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionUncheckedCreateNestedManyWithoutToUnitInput
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitsNestedInput
    conversionsFrom?: UnitConversionUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUpdateManyWithoutToUnitNestedInput
    products?: ProductUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitConversionCreateInput = {
    conversionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitConversionsInput
    fromUnit: UnitCreateNestedOneWithoutConversionsFromInput
    toUnit: UnitCreateNestedOneWithoutConversionsToInput
  }

  export type UnitConversionUncheckedCreateInput = {
    id?: number
    fromUnitId: number
    toUnitId: number
    conversionRate: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitConversionUpdateInput = {
    conversionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitConversionsNestedInput
    fromUnit?: UnitUpdateOneRequiredWithoutConversionsFromNestedInput
    toUnit?: UnitUpdateOneRequiredWithoutConversionsToNestedInput
  }

  export type UnitConversionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUnitId?: IntFieldUpdateOperationsInput | number
    toUnitId?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitConversionCreateManyInput = {
    id?: number
    fromUnitId: number
    toUnitId: number
    conversionRate: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitConversionUpdateManyMutationInput = {
    conversionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitConversionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUnitId?: IntFieldUpdateOperationsInput | number
    toUnitId?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalYearCreateInput = {
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journalEntries?: JournalEntryCreateNestedManyWithoutFiscalYearInput
  }

  export type FiscalYearUncheckedCreateInput = {
    id?: number
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutFiscalYearInput
  }

  export type FiscalYearUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalEntries?: JournalEntryUpdateManyWithoutFiscalYearNestedInput
  }

  export type FiscalYearUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutFiscalYearNestedInput
  }

  export type FiscalYearCreateManyInput = {
    id?: number
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalYearUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalYearUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyCreateInput = {
    code: string
    symbol: string
    isBase?: boolean
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    id?: number
    code: string
    symbol: string
    isBase?: boolean
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyCreateManyInput = {
    id?: number
    code: string
    symbol: string
    isBase?: boolean
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    quantityDecimals?: number
    amountDecimals?: number
    rateDecimals?: number
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: number
    quantityDecimals?: number
    amountDecimals?: number
    rateDecimals?: number
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    quantityDecimals?: IntFieldUpdateOperationsInput | number
    amountDecimals?: IntFieldUpdateOperationsInput | number
    rateDecimals?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantityDecimals?: IntFieldUpdateOperationsInput | number
    amountDecimals?: IntFieldUpdateOperationsInput | number
    rateDecimals?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: number
    quantityDecimals?: number
    amountDecimals?: number
    rateDecimals?: number
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    quantityDecimals?: IntFieldUpdateOperationsInput | number
    amountDecimals?: IntFieldUpdateOperationsInput | number
    rateDecimals?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantityDecimals?: IntFieldUpdateOperationsInput | number
    amountDecimals?: IntFieldUpdateOperationsInput | number
    rateDecimals?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    unit: UnitCreateNestedOneWithoutProductsInput
    variants?: VariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    categoryId: number
    unitId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    unit?: UnitUpdateOneRequiredWithoutProductsNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    categoryId: number
    unitId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantCreateInput = {
    name: string
    sku: string
    color?: string | null
    count?: string | null
    gsm?: string | null
    width?: string | null
    shade?: string | null
    weave?: string | null
    finish?: string | null
    type?: string | null
    price?: number | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
  }

  export type VariantUncheckedCreateInput = {
    id?: number
    name: string
    sku: string
    productId: number
    color?: string | null
    count?: string | null
    gsm?: string | null
    width?: string | null
    shade?: string | null
    weave?: string | null
    finish?: string | null
    type?: string | null
    price?: number | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariantUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableStringFieldUpdateOperationsInput | string | null
    gsm?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    shade?: NullableStringFieldUpdateOperationsInput | string | null
    weave?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
  }

  export type VariantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableStringFieldUpdateOperationsInput | string | null
    gsm?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    shade?: NullableStringFieldUpdateOperationsInput | string | null
    weave?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantCreateManyInput = {
    id?: number
    name: string
    sku: string
    productId: number
    color?: string | null
    count?: string | null
    gsm?: string | null
    width?: string | null
    shade?: string | null
    weave?: string | null
    finish?: string | null
    type?: string | null
    price?: number | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariantUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableStringFieldUpdateOperationsInput | string | null
    gsm?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    shade?: NullableStringFieldUpdateOperationsInput | string | null
    weave?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableStringFieldUpdateOperationsInput | string | null
    gsm?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    shade?: NullableStringFieldUpdateOperationsInput | string | null
    weave?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    machines?: MachineCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    machines?: MachineUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machines?: MachineUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    machines?: MachineUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    name: string
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUncheckedCreateInput = {
    id?: number
    name: string
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateManyInput = {
    id?: number
    name: string
    startTime: string
    endTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorCreateInput = {
    name: string
    code: string
    contact?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatorUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    contact?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorCreateManyInput = {
    id?: number
    name: string
    code: string
    contact?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OperatorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperatorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateInput = {
    name: string
    code: string
    type?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: LocationCreateNestedOneWithoutMachinesInput
  }

  export type MachineUncheckedCreateInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    status?: string
    locationId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneWithoutMachinesNestedInput
  }

  export type MachineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateManyInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    status?: string
    locationId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    locationId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    code: string
    name: string
    type: $Enums.AccountType
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    parentId?: number | null
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    parentId?: number | null
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateInput = {
    number: string
    date: Date | string
    type: $Enums.VoucherType
    reference?: string | null
    narration?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear?: FiscalYearCreateNestedOneWithoutJournalEntriesInput
    lines?: JournalLineCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryUncheckedCreateInput = {
    id?: number
    number: string
    date: Date | string
    type: $Enums.VoucherType
    reference?: string | null
    narration?: string | null
    status?: boolean
    fiscalYearId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: JournalLineUncheckedCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryUpdateInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: FiscalYearUpdateOneWithoutJournalEntriesNestedInput
    lines?: JournalLineUpdateManyWithoutEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    fiscalYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: JournalLineUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type JournalEntryCreateManyInput = {
    id?: number
    number: string
    date: Date | string
    type: $Enums.VoucherType
    reference?: string | null
    narration?: string | null
    status?: boolean
    fiscalYearId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateManyMutationInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    fiscalYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineCreateInput = {
    debit?: number
    credit?: number
    narration?: string | null
    account: AccountCreateNestedOneWithoutJournalLinesInput
    entry: JournalEntryCreateNestedOneWithoutLinesInput
  }

  export type JournalLineUncheckedCreateInput = {
    id?: number
    entryId: number
    accountId: number
    debit?: number
    credit?: number
    narration?: string | null
  }

  export type JournalLineUpdateInput = {
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutJournalLinesNestedInput
    entry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
  }

  export type JournalLineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryId?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineCreateManyInput = {
    id?: number
    entryId: number
    accountId: number
    debit?: number
    credit?: number
    narration?: string | null
  }

  export type JournalLineUpdateManyMutationInput = {
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryId?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoucherSequenceCreateInput = {
    type: $Enums.VoucherType
    prefix: string
    nextValue?: number
    updatedAt?: Date | string
  }

  export type VoucherSequenceUncheckedCreateInput = {
    id?: number
    type: $Enums.VoucherType
    prefix: string
    nextValue?: number
    updatedAt?: Date | string
  }

  export type VoucherSequenceUpdateInput = {
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    prefix?: StringFieldUpdateOperationsInput | string
    nextValue?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherSequenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    prefix?: StringFieldUpdateOperationsInput | string
    nextValue?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherSequenceCreateManyInput = {
    id?: number
    type: $Enums.VoucherType
    prefix: string
    nextValue?: number
    updatedAt?: Date | string
  }

  export type VoucherSequenceUpdateManyMutationInput = {
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    prefix?: StringFieldUpdateOperationsInput | string
    nextValue?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherSequenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    prefix?: StringFieldUpdateOperationsInput | string
    nextValue?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGroupCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ItemGroupCreateNestedOneWithoutChildrenInput
    children?: ItemGroupCreateNestedManyWithoutParentInput
    company: CompanyCreateNestedOneWithoutItemGroupsInput
    itemMasters?: ItemMasterCreateNestedManyWithoutItemGroupInput
  }

  export type ItemGroupUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    parentId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ItemGroupUncheckedCreateNestedManyWithoutParentInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutItemGroupInput
  }

  export type ItemGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ItemGroupUpdateOneWithoutChildrenNestedInput
    children?: ItemGroupUpdateManyWithoutParentNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemGroupsNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutItemGroupNestedInput
  }

  export type ItemGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ItemGroupUncheckedUpdateManyWithoutParentNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutItemGroupNestedInput
  }

  export type ItemGroupCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    parentId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorCreateInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutColorsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutColorInput
    grnItems?: GRNItemCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutColorInput
  }

  export type ColorUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutColorInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutColorInput
  }

  export type ColorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutColorsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutColorNestedInput
    grnItems?: GRNItemUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutColorNestedInput
  }

  export type ColorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutColorNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutColorNestedInput
  }

  export type ColorCreateManyInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandCreateInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBrandsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutBrandInput
    grnItems?: GRNItemCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutBrandInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBrandsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutBrandNestedInput
    grnItems?: GRNItemUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutBrandNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGradeCreateInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutItemGradesInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemGradeInput
    grnItems?: GRNItemCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemGradeInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutItemGradesNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemGradeNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemGradeNestedInput
  }

  export type ItemGradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemGradeNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemGradeNestedInput
  }

  export type ItemGradeCreateManyInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemGradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackingUnitCreateInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPackingUnitsInput
    itemMasters?: ItemMasterCreateNestedManyWithoutPackingUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutPackingUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutPackingUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPackingUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPackingUnitsNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutPackingUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutPackingUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutPackingUnitNestedInput
  }

  export type PackingUnitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutPackingUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutPackingUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutPackingUnitNestedInput
  }

  export type PackingUnitCreateManyInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackingUnitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackingUnitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemMasterCreateInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroup: ItemGroupCreateNestedOneWithoutItemMastersInput
    baseUnit: UnitCreateNestedOneWithoutItemMastersInput
    packingUnit?: PackingUnitCreateNestedOneWithoutItemMastersInput
    company: CompanyCreateNestedOneWithoutItemMastersInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroup?: ItemGroupUpdateOneRequiredWithoutItemMastersNestedInput
    baseUnit?: UnitUpdateOneRequiredWithoutItemMastersNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutItemMastersNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemMastersNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterCreateManyInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemMasterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemMasterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutPurchaseOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    currency?: CurrencyCreateNestedOneWithoutPurchaseOrdersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutPurchaseOrdersNestedInput
    currency?: CurrencyUpdateOneWithoutPurchaseOrdersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseOrderItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseOrderItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseOrderItemsInput
    grnItems?: GRNItemCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseOrderItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseOrderItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    grnItems?: GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemCreateManyInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNCreateInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutGrnsInput
    company: CompanyCreateNestedOneWithoutGrnsInput
    items?: GRNItemCreateNestedManyWithoutGrnInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutGrnInput
  }

  export type GRNUncheckedCreateInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    purchaseOrderId: string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: GRNItemUncheckedCreateNestedManyWithoutGrnInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutGrnInput
  }

  export type GRNUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutGrnsNestedInput
    company?: CompanyUpdateOneRequiredWithoutGrnsNestedInput
    items?: GRNItemUpdateManyWithoutGrnNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutGrnNestedInput
  }

  export type GRNUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: GRNItemUncheckedUpdateManyWithoutGrnNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutGrnNestedInput
  }

  export type GRNCreateManyInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    purchaseOrderId: string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemCreateInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grn: GRNCreateNestedOneWithoutItemsInput
    purchaseOrderItem: PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutGrnItemsInput
    color?: ColorCreateNestedOneWithoutGrnItemsInput
    brand?: BrandCreateNestedOneWithoutGrnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutGrnItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutGrnItemsInput
    unit?: UnitCreateNestedOneWithoutGrnItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUncheckedCreateInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput
    color?: ColorUpdateOneWithoutGrnItemsNestedInput
    brand?: BrandUpdateOneWithoutGrnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutGrnItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutGrnItemsNestedInput
    unit?: UnitUpdateOneWithoutGrnItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemCreateManyInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    account?: AccountCreateNestedOneWithoutPurchaseInvoicesInput
    company: CompanyCreateNestedOneWithoutPurchaseInvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutInvoiceInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    purchaseOrderId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    account?: AccountUpdateOneWithoutPurchaseInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutInvoiceNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    purchaseOrderId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemCreateInput = {
    id?: string
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
    purchaseOrderItem?: PurchaseOrderItemCreateNestedOneWithoutInvoiceItemsInput
    grnItem?: GRNItemCreateNestedOneWithoutInvoiceItemsInput
    itemMaster?: ItemMasterCreateNestedOneWithoutPurchaseInvoiceItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseInvoiceItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseInvoiceItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseInvoiceItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseInvoiceItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneWithoutInvoiceItemsNestedInput
    grnItem?: GRNItemUpdateOneWithoutInvoiceItemsNestedInput
    itemMaster?: ItemMasterUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseInvoiceItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnCreateInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseInvoice?: PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnsInput
    grn?: GRNCreateNestedOneWithoutPurchaseReturnsInput
    account?: AccountCreateNestedOneWithoutPurchaseReturnsInput
    company: CompanyCreateNestedOneWithoutPurchaseReturnsInput
    items?: PurchaseReturnItemCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnUncheckedCreateInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    purchaseInvoiceId?: string | null
    grnId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseReturnItemUncheckedCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseInvoice?: PurchaseInvoiceUpdateOneWithoutPurchaseReturnsNestedInput
    grn?: GRNUpdateOneWithoutPurchaseReturnsNestedInput
    account?: AccountUpdateOneWithoutPurchaseReturnsNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseReturnsNestedInput
    items?: PurchaseReturnItemUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    grnId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseReturnItemUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnCreateManyInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    purchaseInvoiceId?: string | null
    grnId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    grnId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemCreateInput = {
    id?: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    return: PurchaseReturnCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseReturnItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseReturnItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseReturnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseReturnItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseReturnItemsInput
  }

  export type PurchaseReturnItemUncheckedCreateInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return?: PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseReturnItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseReturnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseReturnItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseReturnItemsNestedInput
  }

  export type PurchaseReturnItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemCreateManyInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type AuditAccessListRelationFilter = {
    every?: AuditAccessWhereInput
    some?: AuditAccessWhereInput
    none?: AuditAccessWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserWarehouseListRelationFilter = {
    every?: UserWarehouseWhereInput
    some?: UserWarehouseWhereInput
    none?: UserWarehouseWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserWarehouseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstLogin?: SortOrder
    forcePasswordChange?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstLogin?: SortOrder
    forcePasswordChange?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstLogin?: SortOrder
    forcePasswordChange?: SortOrder
    isActive?: SortOrder
    departmentId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuditAccessSeniorIdJuniorIdCompoundUniqueInput = {
    seniorId: number
    juniorId: number
  }

  export type AuditAccessCountOrderByAggregateInput = {
    id?: SortOrder
    seniorId?: SortOrder
    juniorId?: SortOrder
  }

  export type AuditAccessAvgOrderByAggregateInput = {
    id?: SortOrder
    seniorId?: SortOrder
    juniorId?: SortOrder
  }

  export type AuditAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    seniorId?: SortOrder
    juniorId?: SortOrder
  }

  export type AuditAccessMinOrderByAggregateInput = {
    id?: SortOrder
    seniorId?: SortOrder
    juniorId?: SortOrder
  }

  export type AuditAccessSumOrderByAggregateInput = {
    id?: SortOrder
    seniorId?: SortOrder
    juniorId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionActionResourceCompoundUniqueInput = {
    action: string
    resource: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: number
    permissionId: number
  }

  export type RolePermissionCountOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
    assignedAt?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    roleId?: SortOrder
    permissionId?: SortOrder
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: number
    roleId: number
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    authorId?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    userId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    resourceId?: SortOrder
    before?: SortOrder
    after?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    resourceId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    resourceId?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    userId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehouseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contactPerson?: SortOrder
    contactNumbers?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WarehouseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contactPerson?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contactPerson?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehouseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WarehouseScalarRelationFilter = {
    is?: WarehouseWhereInput
    isNot?: WarehouseWhereInput
  }

  export type UserWarehouseUserIdWarehouseIdCompoundUniqueInput = {
    userId: number
    warehouseId: number
  }

  export type UserWarehouseCountOrderByAggregateInput = {
    userId?: SortOrder
    warehouseId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserWarehouseAvgOrderByAggregateInput = {
    userId?: SortOrder
    warehouseId?: SortOrder
  }

  export type UserWarehouseMaxOrderByAggregateInput = {
    userId?: SortOrder
    warehouseId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserWarehouseMinOrderByAggregateInput = {
    userId?: SortOrder
    warehouseId?: SortOrder
    assignedAt?: SortOrder
  }

  export type UserWarehouseSumOrderByAggregateInput = {
    userId?: SortOrder
    warehouseId?: SortOrder
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type UnitConversionListRelationFilter = {
    every?: UnitConversionWhereInput
    some?: UnitConversionWhereInput
    none?: UnitConversionWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ItemMasterListRelationFilter = {
    every?: ItemMasterWhereInput
    some?: ItemMasterWhereInput
    none?: ItemMasterWhereInput
  }

  export type PurchaseOrderItemListRelationFilter = {
    every?: PurchaseOrderItemWhereInput
    some?: PurchaseOrderItemWhereInput
    none?: PurchaseOrderItemWhereInput
  }

  export type GRNItemListRelationFilter = {
    every?: GRNItemWhereInput
    some?: GRNItemWhereInput
    none?: GRNItemWhereInput
  }

  export type PurchaseInvoiceItemListRelationFilter = {
    every?: PurchaseInvoiceItemWhereInput
    some?: PurchaseInvoiceItemWhereInput
    none?: PurchaseInvoiceItemWhereInput
  }

  export type PurchaseReturnItemListRelationFilter = {
    every?: PurchaseReturnItemWhereInput
    some?: PurchaseReturnItemWhereInput
    none?: PurchaseReturnItemWhereInput
  }

  export type UnitConversionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemMasterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GRNItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseReturnItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    unitType?: SortOrder
    isBase?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    unitType?: SortOrder
    isBase?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    unitType?: SortOrder
    isBase?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UnitScalarRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type UnitConversionFromUnitIdToUnitIdCompoundUniqueInput = {
    fromUnitId: number
    toUnitId: number
  }

  export type UnitConversionCountOrderByAggregateInput = {
    id?: SortOrder
    fromUnitId?: SortOrder
    toUnitId?: SortOrder
    conversionRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitConversionAvgOrderByAggregateInput = {
    id?: SortOrder
    fromUnitId?: SortOrder
    toUnitId?: SortOrder
    conversionRate?: SortOrder
    companyId?: SortOrder
  }

  export type UnitConversionMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUnitId?: SortOrder
    toUnitId?: SortOrder
    conversionRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitConversionMinOrderByAggregateInput = {
    id?: SortOrder
    fromUnitId?: SortOrder
    toUnitId?: SortOrder
    conversionRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitConversionSumOrderByAggregateInput = {
    id?: SortOrder
    fromUnitId?: SortOrder
    toUnitId?: SortOrder
    conversionRate?: SortOrder
    companyId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ItemGroupListRelationFilter = {
    every?: ItemGroupWhereInput
    some?: ItemGroupWhereInput
    none?: ItemGroupWhereInput
  }

  export type ColorListRelationFilter = {
    every?: ColorWhereInput
    some?: ColorWhereInput
    none?: ColorWhereInput
  }

  export type BrandListRelationFilter = {
    every?: BrandWhereInput
    some?: BrandWhereInput
    none?: BrandWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type ItemGradeListRelationFilter = {
    every?: ItemGradeWhereInput
    some?: ItemGradeWhereInput
    none?: ItemGradeWhereInput
  }

  export type GRNListRelationFilter = {
    every?: GRNWhereInput
    some?: GRNWhereInput
    none?: GRNWhereInput
  }

  export type PurchaseInvoiceListRelationFilter = {
    every?: PurchaseInvoiceWhereInput
    some?: PurchaseInvoiceWhereInput
    none?: PurchaseInvoiceWhereInput
  }

  export type PurchaseReturnListRelationFilter = {
    every?: PurchaseReturnWhereInput
    some?: PurchaseReturnWhereInput
    none?: PurchaseReturnWhereInput
  }

  export type PackingUnitListRelationFilter = {
    every?: PackingUnitWhereInput
    some?: PackingUnitWhereInput
    none?: PackingUnitWhereInput
  }

  export type ItemGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ColorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemGradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GRNOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseReturnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackingUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    legalName?: SortOrder
    tradeName?: SortOrder
    address?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    legalName?: SortOrder
    tradeName?: SortOrder
    address?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    legalName?: SortOrder
    tradeName?: SortOrder
    address?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxId?: SortOrder
    logoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JournalEntryListRelationFilter = {
    every?: JournalEntryWhereInput
    some?: JournalEntryWhereInput
    none?: JournalEntryWhereInput
  }

  export type JournalEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FiscalYearCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalYearAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FiscalYearMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalYearMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isLocked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FiscalYearSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    isBase?: SortOrder
    exchangeRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    id?: SortOrder
    exchangeRate?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    isBase?: SortOrder
    exchangeRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    symbol?: SortOrder
    isBase?: SortOrder
    exchangeRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    id?: SortOrder
    exchangeRate?: SortOrder
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    quantityDecimals?: SortOrder
    amountDecimals?: SortOrder
    rateDecimals?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigAvgOrderByAggregateInput = {
    id?: SortOrder
    quantityDecimals?: SortOrder
    amountDecimals?: SortOrder
    rateDecimals?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    quantityDecimals?: SortOrder
    amountDecimals?: SortOrder
    rateDecimals?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    quantityDecimals?: SortOrder
    amountDecimals?: SortOrder
    rateDecimals?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigSumOrderByAggregateInput = {
    id?: SortOrder
    quantityDecimals?: SortOrder
    amountDecimals?: SortOrder
    rateDecimals?: SortOrder
  }

  export type SystemSettingCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type VariantListRelationFilter = {
    every?: VariantWhereInput
    some?: VariantWhereInput
    none?: VariantWhereInput
  }

  export type VariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    unitId?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type VariantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    productId?: SortOrder
    color?: SortOrder
    count?: SortOrder
    gsm?: SortOrder
    width?: SortOrder
    shade?: SortOrder
    weave?: SortOrder
    finish?: SortOrder
    type?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariantAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
  }

  export type VariantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    productId?: SortOrder
    color?: SortOrder
    count?: SortOrder
    gsm?: SortOrder
    width?: SortOrder
    shade?: SortOrder
    weave?: SortOrder
    finish?: SortOrder
    type?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    productId?: SortOrder
    color?: SortOrder
    count?: SortOrder
    gsm?: SortOrder
    width?: SortOrder
    shade?: SortOrder
    weave?: SortOrder
    finish?: SortOrder
    type?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariantSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    stock?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MachineListRelationFilter = {
    every?: MachineWhereInput
    some?: MachineWhereInput
    none?: MachineWhereInput
  }

  export type MachineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OperatorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    contact?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OperatorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    contact?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    contact?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OperatorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type MachineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
  }

  export type MachineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    locationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MachineSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type EnumBalanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeFilter<$PrismaModel> | $Enums.BalanceType
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type JournalLineListRelationFilter = {
    every?: JournalLineWhereInput
    some?: JournalLineWhereInput
    none?: JournalLineWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    level?: SortOrder
    isPosting?: SortOrder
    description?: SortOrder
    openingBalance?: SortOrder
    openingBalanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    level?: SortOrder
    openingBalance?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    level?: SortOrder
    isPosting?: SortOrder
    description?: SortOrder
    openingBalance?: SortOrder
    openingBalanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parentId?: SortOrder
    level?: SortOrder
    isPosting?: SortOrder
    description?: SortOrder
    openingBalance?: SortOrder
    openingBalanceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    level?: SortOrder
    openingBalance?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumBalanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.BalanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBalanceTypeFilter<$PrismaModel>
    _max?: NestedEnumBalanceTypeFilter<$PrismaModel>
  }

  export type EnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type FiscalYearNullableScalarRelationFilter = {
    is?: FiscalYearWhereInput | null
    isNot?: FiscalYearWhereInput | null
  }

  export type JournalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    narration?: SortOrder
    status?: SortOrder
    fiscalYearId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    fiscalYearId?: SortOrder
  }

  export type JournalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    narration?: SortOrder
    status?: SortOrder
    fiscalYearId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    date?: SortOrder
    type?: SortOrder
    reference?: SortOrder
    narration?: SortOrder
    status?: SortOrder
    fiscalYearId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntrySumOrderByAggregateInput = {
    id?: SortOrder
    fiscalYearId?: SortOrder
  }

  export type EnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type JournalEntryScalarRelationFilter = {
    is?: JournalEntryWhereInput
    isNot?: JournalEntryWhereInput
  }

  export type JournalLineCountOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    narration?: SortOrder
  }

  export type JournalLineAvgOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
  }

  export type JournalLineMaxOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    narration?: SortOrder
  }

  export type JournalLineMinOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    narration?: SortOrder
  }

  export type JournalLineSumOrderByAggregateInput = {
    id?: SortOrder
    entryId?: SortOrder
    accountId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
  }

  export type VoucherSequenceCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    prefix?: SortOrder
    nextValue?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherSequenceAvgOrderByAggregateInput = {
    id?: SortOrder
    nextValue?: SortOrder
  }

  export type VoucherSequenceMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    prefix?: SortOrder
    nextValue?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherSequenceMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    prefix?: SortOrder
    nextValue?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherSequenceSumOrderByAggregateInput = {
    id?: SortOrder
    nextValue?: SortOrder
  }

  export type ItemGroupNullableScalarRelationFilter = {
    is?: ItemGroupWhereInput | null
    isNot?: ItemGroupWhereInput | null
  }

  export type ItemGroupCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemGroupAvgOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type ItemGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemGroupMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemGroupSumOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type ColorCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    pictureUrl?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColorAvgOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type ColorMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    pictureUrl?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColorMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    pictureUrl?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColorSumOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandAvgOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandSumOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type ItemGradeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemGradeAvgOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type ItemGradeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemGradeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemGradeSumOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type PackingUnitCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackingUnitAvgOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type PackingUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackingUnitMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackingUnitSumOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type ItemGroupScalarRelationFilter = {
    is?: ItemGroupWhereInput
    isNot?: ItemGroupWhereInput
  }

  export type PackingUnitNullableScalarRelationFilter = {
    is?: PackingUnitWhereInput | null
    isNot?: PackingUnitWhereInput | null
  }

  export type ItemMasterCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    status?: SortOrder
    hsCode?: SortOrder
    imageUrl?: SortOrder
    itemGroupId?: SortOrder
    baseUnitId?: SortOrder
    packingUnitId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMasterAvgOrderByAggregateInput = {
    baseUnitId?: SortOrder
    companyId?: SortOrder
  }

  export type ItemMasterMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    status?: SortOrder
    hsCode?: SortOrder
    imageUrl?: SortOrder
    itemGroupId?: SortOrder
    baseUnitId?: SortOrder
    packingUnitId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMasterMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    status?: SortOrder
    hsCode?: SortOrder
    imageUrl?: SortOrder
    itemGroupId?: SortOrder
    baseUnitId?: SortOrder
    packingUnitId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMasterSumOrderByAggregateInput = {
    baseUnitId?: SortOrder
    companyId?: SortOrder
  }

  export type EnumPurchaseOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderType | EnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderType[] | ListEnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderType[] | ListEnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderTypeFilter<$PrismaModel> | $Enums.PurchaseOrderType
  }

  export type EnumPurchaseOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type WarehouseNullableScalarRelationFilter = {
    is?: WarehouseWhereInput | null
    isNot?: WarehouseWhereInput | null
  }

  export type CurrencyNullableScalarRelationFilter = {
    is?: CurrencyWhereInput | null
    isNot?: CurrencyWhereInput | null
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    partyName?: SortOrder
    warehouseId?: SortOrder
    referenceNo?: SortOrder
    documentDate?: SortOrder
    fileNo?: SortOrder
    remarks?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    accountId?: SortOrder
    warehouseId?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    partyName?: SortOrder
    warehouseId?: SortOrder
    referenceNo?: SortOrder
    documentDate?: SortOrder
    fileNo?: SortOrder
    remarks?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    poNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    date?: SortOrder
    accountId?: SortOrder
    partyName?: SortOrder
    warehouseId?: SortOrder
    referenceNo?: SortOrder
    documentDate?: SortOrder
    fileNo?: SortOrder
    remarks?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    accountId?: SortOrder
    warehouseId?: SortOrder
    totalAmount?: SortOrder
    currencyId?: SortOrder
    exchangeRate?: SortOrder
    companyId?: SortOrder
  }

  export type EnumPurchaseOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderType | EnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderType[] | ListEnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderType[] | ListEnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseOrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumPurchaseOrderTypeFilter<$PrismaModel>
  }

  export type EnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPackingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PackingType | EnumPackingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PackingType[] | ListEnumPackingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PackingType[] | ListEnumPackingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPackingTypeNullableFilter<$PrismaModel> | $Enums.PackingType | null
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type ItemMasterScalarRelationFilter = {
    is?: ItemMasterWhereInput
    isNot?: ItemMasterWhereInput
  }

  export type ColorNullableScalarRelationFilter = {
    is?: ColorWhereInput | null
    isNot?: ColorWhereInput | null
  }

  export type BrandNullableScalarRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type ItemGradeNullableScalarRelationFilter = {
    is?: ItemGradeWhereInput | null
    isNot?: ItemGradeWhereInput | null
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type PurchaseOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    packingUnitId?: SortOrder
    packingType?: SortOrder
    pcs?: SortOrder
    unitSize?: SortOrder
    quantity?: SortOrder
    unitId?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemAvgOrderByAggregateInput = {
    pcs?: SortOrder
    unitSize?: SortOrder
    quantity?: SortOrder
    unitId?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
  }

  export type PurchaseOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    packingUnitId?: SortOrder
    packingType?: SortOrder
    pcs?: SortOrder
    unitSize?: SortOrder
    quantity?: SortOrder
    unitId?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchaseOrderId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    packingUnitId?: SortOrder
    packingType?: SortOrder
    pcs?: SortOrder
    unitSize?: SortOrder
    quantity?: SortOrder
    unitId?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderItemSumOrderByAggregateInput = {
    pcs?: SortOrder
    unitSize?: SortOrder
    quantity?: SortOrder
    unitId?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
  }

  export type EnumPackingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackingType | EnumPackingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PackingType[] | ListEnumPackingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PackingType[] | ListEnumPackingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPackingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PackingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPackingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPackingTypeNullableFilter<$PrismaModel>
  }

  export type GRNCountOrderByAggregateInput = {
    id?: SortOrder
    grnNumber?: SortOrder
    date?: SortOrder
    purchaseOrderId?: SortOrder
    lotNo?: SortOrder
    warehouseRefNo?: SortOrder
    remarks?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GRNAvgOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type GRNMaxOrderByAggregateInput = {
    id?: SortOrder
    grnNumber?: SortOrder
    date?: SortOrder
    purchaseOrderId?: SortOrder
    lotNo?: SortOrder
    warehouseRefNo?: SortOrder
    remarks?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GRNMinOrderByAggregateInput = {
    id?: SortOrder
    grnNumber?: SortOrder
    date?: SortOrder
    purchaseOrderId?: SortOrder
    lotNo?: SortOrder
    warehouseRefNo?: SortOrder
    remarks?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GRNSumOrderByAggregateInput = {
    companyId?: SortOrder
  }

  export type GRNScalarRelationFilter = {
    is?: GRNWhereInput
    isNot?: GRNWhereInput
  }

  export type PurchaseOrderItemScalarRelationFilter = {
    is?: PurchaseOrderItemWhereInput
    isNot?: PurchaseOrderItemWhereInput
  }

  export type GRNItemCountOrderByAggregateInput = {
    id?: SortOrder
    grnId?: SortOrder
    purchaseOrderItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    packingUnitId?: SortOrder
    receivedQty?: SortOrder
    pcs?: SortOrder
    unitSize?: SortOrder
    packingType?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GRNItemAvgOrderByAggregateInput = {
    receivedQty?: SortOrder
    pcs?: SortOrder
    unitSize?: SortOrder
    unitId?: SortOrder
  }

  export type GRNItemMaxOrderByAggregateInput = {
    id?: SortOrder
    grnId?: SortOrder
    purchaseOrderItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    packingUnitId?: SortOrder
    receivedQty?: SortOrder
    pcs?: SortOrder
    unitSize?: SortOrder
    packingType?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GRNItemMinOrderByAggregateInput = {
    id?: SortOrder
    grnId?: SortOrder
    purchaseOrderItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    packingUnitId?: SortOrder
    receivedQty?: SortOrder
    pcs?: SortOrder
    unitSize?: SortOrder
    packingType?: SortOrder
    unitId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GRNItemSumOrderByAggregateInput = {
    receivedQty?: SortOrder
    pcs?: SortOrder
    unitSize?: SortOrder
    unitId?: SortOrder
  }

  export type PurchaseOrderNullableScalarRelationFilter = {
    is?: PurchaseOrderWhereInput | null
    isNot?: PurchaseOrderWhereInput | null
  }

  export type PurchaseInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    supplierInvoiceNo?: SortOrder
    remarks?: SortOrder
    purchaseOrderId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceAvgOrderByAggregateInput = {
    accountId?: SortOrder
    totalAmount?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    supplierInvoiceNo?: SortOrder
    remarks?: SortOrder
    purchaseOrderId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    date?: SortOrder
    supplierInvoiceNo?: SortOrder
    remarks?: SortOrder
    purchaseOrderId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceSumOrderByAggregateInput = {
    accountId?: SortOrder
    totalAmount?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseInvoiceScalarRelationFilter = {
    is?: PurchaseInvoiceWhereInput
    isNot?: PurchaseInvoiceWhereInput
  }

  export type PurchaseOrderItemNullableScalarRelationFilter = {
    is?: PurchaseOrderItemWhereInput | null
    isNot?: PurchaseOrderItemWhereInput | null
  }

  export type GRNItemNullableScalarRelationFilter = {
    is?: GRNItemWhereInput | null
    isNot?: GRNItemWhereInput | null
  }

  export type ItemMasterNullableScalarRelationFilter = {
    is?: ItemMasterWhereInput | null
    isNot?: ItemMasterWhereInput | null
  }

  export type PurchaseInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    purchaseOrderItemId?: SortOrder
    grnItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    unitId?: SortOrder
    invoicedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceItemAvgOrderByAggregateInput = {
    unitId?: SortOrder
    invoicedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
  }

  export type PurchaseInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    purchaseOrderItemId?: SortOrder
    grnItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    unitId?: SortOrder
    invoicedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    purchaseOrderItemId?: SortOrder
    grnItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    unitId?: SortOrder
    invoicedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceItemSumOrderByAggregateInput = {
    unitId?: SortOrder
    invoicedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
  }

  export type PurchaseInvoiceNullableScalarRelationFilter = {
    is?: PurchaseInvoiceWhereInput | null
    isNot?: PurchaseInvoiceWhereInput | null
  }

  export type GRNNullableScalarRelationFilter = {
    is?: GRNWhereInput | null
    isNot?: GRNWhereInput | null
  }

  export type PurchaseReturnCountOrderByAggregateInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    date?: SortOrder
    remarks?: SortOrder
    purchaseInvoiceId?: SortOrder
    grnId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnAvgOrderByAggregateInput = {
    accountId?: SortOrder
    totalAmount?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseReturnMaxOrderByAggregateInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    date?: SortOrder
    remarks?: SortOrder
    purchaseInvoiceId?: SortOrder
    grnId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnMinOrderByAggregateInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    date?: SortOrder
    remarks?: SortOrder
    purchaseInvoiceId?: SortOrder
    grnId?: SortOrder
    accountId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnSumOrderByAggregateInput = {
    accountId?: SortOrder
    totalAmount?: SortOrder
    companyId?: SortOrder
  }

  export type PurchaseReturnScalarRelationFilter = {
    is?: PurchaseReturnWhereInput
    isNot?: PurchaseReturnWhereInput
  }

  export type PurchaseReturnItemCountOrderByAggregateInput = {
    id?: SortOrder
    returnId?: SortOrder
    purchaseInvoiceItemId?: SortOrder
    grnItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    unitId?: SortOrder
    returnedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnItemAvgOrderByAggregateInput = {
    unitId?: SortOrder
    returnedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
  }

  export type PurchaseReturnItemMaxOrderByAggregateInput = {
    id?: SortOrder
    returnId?: SortOrder
    purchaseInvoiceItemId?: SortOrder
    grnItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    unitId?: SortOrder
    returnedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnItemMinOrderByAggregateInput = {
    id?: SortOrder
    returnId?: SortOrder
    purchaseInvoiceItemId?: SortOrder
    grnItemId?: SortOrder
    itemMasterId?: SortOrder
    colorId?: SortOrder
    brandId?: SortOrder
    itemGradeId?: SortOrder
    unitId?: SortOrder
    returnedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnItemSumOrderByAggregateInput = {
    unitId?: SortOrder
    returnedQty?: SortOrder
    rate?: SortOrder
    amount?: SortOrder
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutUsersInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type AuditAccessCreateNestedManyWithoutSeniorInput = {
    create?: XOR<AuditAccessCreateWithoutSeniorInput, AuditAccessUncheckedCreateWithoutSeniorInput> | AuditAccessCreateWithoutSeniorInput[] | AuditAccessUncheckedCreateWithoutSeniorInput[]
    connectOrCreate?: AuditAccessCreateOrConnectWithoutSeniorInput | AuditAccessCreateOrConnectWithoutSeniorInput[]
    createMany?: AuditAccessCreateManySeniorInputEnvelope
    connect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
  }

  export type AuditAccessCreateNestedManyWithoutJuniorInput = {
    create?: XOR<AuditAccessCreateWithoutJuniorInput, AuditAccessUncheckedCreateWithoutJuniorInput> | AuditAccessCreateWithoutJuniorInput[] | AuditAccessUncheckedCreateWithoutJuniorInput[]
    connectOrCreate?: AuditAccessCreateOrConnectWithoutJuniorInput | AuditAccessCreateOrConnectWithoutJuniorInput[]
    createMany?: AuditAccessCreateManyJuniorInputEnvelope
    connect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserWarehouseCreateNestedManyWithoutUserInput = {
    create?: XOR<UserWarehouseCreateWithoutUserInput, UserWarehouseUncheckedCreateWithoutUserInput> | UserWarehouseCreateWithoutUserInput[] | UserWarehouseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWarehouseCreateOrConnectWithoutUserInput | UserWarehouseCreateOrConnectWithoutUserInput[]
    createMany?: UserWarehouseCreateManyUserInputEnvelope
    connect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AuditAccessUncheckedCreateNestedManyWithoutSeniorInput = {
    create?: XOR<AuditAccessCreateWithoutSeniorInput, AuditAccessUncheckedCreateWithoutSeniorInput> | AuditAccessCreateWithoutSeniorInput[] | AuditAccessUncheckedCreateWithoutSeniorInput[]
    connectOrCreate?: AuditAccessCreateOrConnectWithoutSeniorInput | AuditAccessCreateOrConnectWithoutSeniorInput[]
    createMany?: AuditAccessCreateManySeniorInputEnvelope
    connect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
  }

  export type AuditAccessUncheckedCreateNestedManyWithoutJuniorInput = {
    create?: XOR<AuditAccessCreateWithoutJuniorInput, AuditAccessUncheckedCreateWithoutJuniorInput> | AuditAccessCreateWithoutJuniorInput[] | AuditAccessUncheckedCreateWithoutJuniorInput[]
    connectOrCreate?: AuditAccessCreateOrConnectWithoutJuniorInput | AuditAccessCreateOrConnectWithoutJuniorInput[]
    createMany?: AuditAccessCreateManyJuniorInputEnvelope
    connect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserWarehouseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserWarehouseCreateWithoutUserInput, UserWarehouseUncheckedCreateWithoutUserInput> | UserWarehouseCreateWithoutUserInput[] | UserWarehouseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWarehouseCreateOrConnectWithoutUserInput | UserWarehouseCreateOrConnectWithoutUserInput[]
    createMany?: UserWarehouseCreateManyUserInputEnvelope
    connect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    upsert?: DepartmentUpsertWithoutUsersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUsersInput, DepartmentUpdateWithoutUsersInput>, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type AuditAccessUpdateManyWithoutSeniorNestedInput = {
    create?: XOR<AuditAccessCreateWithoutSeniorInput, AuditAccessUncheckedCreateWithoutSeniorInput> | AuditAccessCreateWithoutSeniorInput[] | AuditAccessUncheckedCreateWithoutSeniorInput[]
    connectOrCreate?: AuditAccessCreateOrConnectWithoutSeniorInput | AuditAccessCreateOrConnectWithoutSeniorInput[]
    upsert?: AuditAccessUpsertWithWhereUniqueWithoutSeniorInput | AuditAccessUpsertWithWhereUniqueWithoutSeniorInput[]
    createMany?: AuditAccessCreateManySeniorInputEnvelope
    set?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    disconnect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    delete?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    connect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    update?: AuditAccessUpdateWithWhereUniqueWithoutSeniorInput | AuditAccessUpdateWithWhereUniqueWithoutSeniorInput[]
    updateMany?: AuditAccessUpdateManyWithWhereWithoutSeniorInput | AuditAccessUpdateManyWithWhereWithoutSeniorInput[]
    deleteMany?: AuditAccessScalarWhereInput | AuditAccessScalarWhereInput[]
  }

  export type AuditAccessUpdateManyWithoutJuniorNestedInput = {
    create?: XOR<AuditAccessCreateWithoutJuniorInput, AuditAccessUncheckedCreateWithoutJuniorInput> | AuditAccessCreateWithoutJuniorInput[] | AuditAccessUncheckedCreateWithoutJuniorInput[]
    connectOrCreate?: AuditAccessCreateOrConnectWithoutJuniorInput | AuditAccessCreateOrConnectWithoutJuniorInput[]
    upsert?: AuditAccessUpsertWithWhereUniqueWithoutJuniorInput | AuditAccessUpsertWithWhereUniqueWithoutJuniorInput[]
    createMany?: AuditAccessCreateManyJuniorInputEnvelope
    set?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    disconnect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    delete?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    connect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    update?: AuditAccessUpdateWithWhereUniqueWithoutJuniorInput | AuditAccessUpdateWithWhereUniqueWithoutJuniorInput[]
    updateMany?: AuditAccessUpdateManyWithWhereWithoutJuniorInput | AuditAccessUpdateManyWithWhereWithoutJuniorInput[]
    deleteMany?: AuditAccessScalarWhereInput | AuditAccessScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserWarehouseUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserWarehouseCreateWithoutUserInput, UserWarehouseUncheckedCreateWithoutUserInput> | UserWarehouseCreateWithoutUserInput[] | UserWarehouseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWarehouseCreateOrConnectWithoutUserInput | UserWarehouseCreateOrConnectWithoutUserInput[]
    upsert?: UserWarehouseUpsertWithWhereUniqueWithoutUserInput | UserWarehouseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserWarehouseCreateManyUserInputEnvelope
    set?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    disconnect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    delete?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    connect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    update?: UserWarehouseUpdateWithWhereUniqueWithoutUserInput | UserWarehouseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserWarehouseUpdateManyWithWhereWithoutUserInput | UserWarehouseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserWarehouseScalarWhereInput | UserWarehouseScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AuditAccessUncheckedUpdateManyWithoutSeniorNestedInput = {
    create?: XOR<AuditAccessCreateWithoutSeniorInput, AuditAccessUncheckedCreateWithoutSeniorInput> | AuditAccessCreateWithoutSeniorInput[] | AuditAccessUncheckedCreateWithoutSeniorInput[]
    connectOrCreate?: AuditAccessCreateOrConnectWithoutSeniorInput | AuditAccessCreateOrConnectWithoutSeniorInput[]
    upsert?: AuditAccessUpsertWithWhereUniqueWithoutSeniorInput | AuditAccessUpsertWithWhereUniqueWithoutSeniorInput[]
    createMany?: AuditAccessCreateManySeniorInputEnvelope
    set?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    disconnect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    delete?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    connect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    update?: AuditAccessUpdateWithWhereUniqueWithoutSeniorInput | AuditAccessUpdateWithWhereUniqueWithoutSeniorInput[]
    updateMany?: AuditAccessUpdateManyWithWhereWithoutSeniorInput | AuditAccessUpdateManyWithWhereWithoutSeniorInput[]
    deleteMany?: AuditAccessScalarWhereInput | AuditAccessScalarWhereInput[]
  }

  export type AuditAccessUncheckedUpdateManyWithoutJuniorNestedInput = {
    create?: XOR<AuditAccessCreateWithoutJuniorInput, AuditAccessUncheckedCreateWithoutJuniorInput> | AuditAccessCreateWithoutJuniorInput[] | AuditAccessUncheckedCreateWithoutJuniorInput[]
    connectOrCreate?: AuditAccessCreateOrConnectWithoutJuniorInput | AuditAccessCreateOrConnectWithoutJuniorInput[]
    upsert?: AuditAccessUpsertWithWhereUniqueWithoutJuniorInput | AuditAccessUpsertWithWhereUniqueWithoutJuniorInput[]
    createMany?: AuditAccessCreateManyJuniorInputEnvelope
    set?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    disconnect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    delete?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    connect?: AuditAccessWhereUniqueInput | AuditAccessWhereUniqueInput[]
    update?: AuditAccessUpdateWithWhereUniqueWithoutJuniorInput | AuditAccessUpdateWithWhereUniqueWithoutJuniorInput[]
    updateMany?: AuditAccessUpdateManyWithWhereWithoutJuniorInput | AuditAccessUpdateManyWithWhereWithoutJuniorInput[]
    deleteMany?: AuditAccessScalarWhereInput | AuditAccessScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserWarehouseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserWarehouseCreateWithoutUserInput, UserWarehouseUncheckedCreateWithoutUserInput> | UserWarehouseCreateWithoutUserInput[] | UserWarehouseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserWarehouseCreateOrConnectWithoutUserInput | UserWarehouseCreateOrConnectWithoutUserInput[]
    upsert?: UserWarehouseUpsertWithWhereUniqueWithoutUserInput | UserWarehouseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserWarehouseCreateManyUserInputEnvelope
    set?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    disconnect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    delete?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    connect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    update?: UserWarehouseUpdateWithWhereUniqueWithoutUserInput | UserWarehouseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserWarehouseUpdateManyWithWhereWithoutUserInput | UserWarehouseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserWarehouseScalarWhereInput | UserWarehouseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogPermissionsInput = {
    create?: XOR<UserCreateWithoutAuditLogPermissionsInput, UserUncheckedCreateWithoutAuditLogPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVisibleToAuditInput = {
    create?: XOR<UserCreateWithoutVisibleToAuditInput, UserUncheckedCreateWithoutVisibleToAuditInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisibleToAuditInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogPermissionsInput, UserUncheckedCreateWithoutAuditLogPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogPermissionsInput
    upsert?: UserUpsertWithoutAuditLogPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogPermissionsInput, UserUpdateWithoutAuditLogPermissionsInput>, UserUncheckedUpdateWithoutAuditLogPermissionsInput>
  }

  export type UserUpdateOneRequiredWithoutVisibleToAuditNestedInput = {
    create?: XOR<UserCreateWithoutVisibleToAuditInput, UserUncheckedCreateWithoutVisibleToAuditInput>
    connectOrCreate?: UserCreateOrConnectWithoutVisibleToAuditInput
    upsert?: UserUpsertWithoutVisibleToAuditInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVisibleToAuditInput, UserUpdateWithoutVisibleToAuditInput>, UserUncheckedUpdateWithoutVisibleToAuditInput>
  }

  export type UserCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUserRolesInput
    upsert?: RoleUpsertWithoutUserRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUserRolesInput, RoleUpdateWithoutUserRolesInput>, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WarehouseCreatecontactNumbersInput = {
    set: string[]
  }

  export type UserWarehouseCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<UserWarehouseCreateWithoutWarehouseInput, UserWarehouseUncheckedCreateWithoutWarehouseInput> | UserWarehouseCreateWithoutWarehouseInput[] | UserWarehouseUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: UserWarehouseCreateOrConnectWithoutWarehouseInput | UserWarehouseCreateOrConnectWithoutWarehouseInput[]
    createMany?: UserWarehouseCreateManyWarehouseInputEnvelope
    connect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type UserWarehouseUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<UserWarehouseCreateWithoutWarehouseInput, UserWarehouseUncheckedCreateWithoutWarehouseInput> | UserWarehouseCreateWithoutWarehouseInput[] | UserWarehouseUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: UserWarehouseCreateOrConnectWithoutWarehouseInput | UserWarehouseCreateOrConnectWithoutWarehouseInput[]
    createMany?: UserWarehouseCreateManyWarehouseInputEnvelope
    connect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type WarehouseUpdatecontactNumbersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserWarehouseUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<UserWarehouseCreateWithoutWarehouseInput, UserWarehouseUncheckedCreateWithoutWarehouseInput> | UserWarehouseCreateWithoutWarehouseInput[] | UserWarehouseUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: UserWarehouseCreateOrConnectWithoutWarehouseInput | UserWarehouseCreateOrConnectWithoutWarehouseInput[]
    upsert?: UserWarehouseUpsertWithWhereUniqueWithoutWarehouseInput | UserWarehouseUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: UserWarehouseCreateManyWarehouseInputEnvelope
    set?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    disconnect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    delete?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    connect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    update?: UserWarehouseUpdateWithWhereUniqueWithoutWarehouseInput | UserWarehouseUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: UserWarehouseUpdateManyWithWhereWithoutWarehouseInput | UserWarehouseUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: UserWarehouseScalarWhereInput | UserWarehouseScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput | PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type UserWarehouseUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<UserWarehouseCreateWithoutWarehouseInput, UserWarehouseUncheckedCreateWithoutWarehouseInput> | UserWarehouseCreateWithoutWarehouseInput[] | UserWarehouseUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: UserWarehouseCreateOrConnectWithoutWarehouseInput | UserWarehouseCreateOrConnectWithoutWarehouseInput[]
    upsert?: UserWarehouseUpsertWithWhereUniqueWithoutWarehouseInput | UserWarehouseUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: UserWarehouseCreateManyWarehouseInputEnvelope
    set?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    disconnect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    delete?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    connect?: UserWarehouseWhereUniqueInput | UserWarehouseWhereUniqueInput[]
    update?: UserWarehouseUpdateWithWhereUniqueWithoutWarehouseInput | UserWarehouseUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: UserWarehouseUpdateManyWithWhereWithoutWarehouseInput | UserWarehouseUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: UserWarehouseScalarWhereInput | UserWarehouseScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput> | PurchaseOrderCreateWithoutWarehouseInput[] | PurchaseOrderUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutWarehouseInput | PurchaseOrderCreateOrConnectWithoutWarehouseInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: PurchaseOrderCreateManyWarehouseInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput | PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput | PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserWarehousesInput = {
    create?: XOR<UserCreateWithoutUserWarehousesInput, UserUncheckedCreateWithoutUserWarehousesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserWarehousesInput
    connect?: UserWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutUserWarehousesInput = {
    create?: XOR<WarehouseCreateWithoutUserWarehousesInput, WarehouseUncheckedCreateWithoutUserWarehousesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutUserWarehousesInput
    connect?: WarehouseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserWarehousesNestedInput = {
    create?: XOR<UserCreateWithoutUserWarehousesInput, UserUncheckedCreateWithoutUserWarehousesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserWarehousesInput
    upsert?: UserUpsertWithoutUserWarehousesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserWarehousesInput, UserUpdateWithoutUserWarehousesInput>, UserUncheckedUpdateWithoutUserWarehousesInput>
  }

  export type WarehouseUpdateOneRequiredWithoutUserWarehousesNestedInput = {
    create?: XOR<WarehouseCreateWithoutUserWarehousesInput, WarehouseUncheckedCreateWithoutUserWarehousesInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutUserWarehousesInput
    upsert?: WarehouseUpsertWithoutUserWarehousesInput
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutUserWarehousesInput, WarehouseUpdateWithoutUserWarehousesInput>, WarehouseUncheckedUpdateWithoutUserWarehousesInput>
  }

  export type CompanyCreateNestedOneWithoutUnitsInput = {
    create?: XOR<CompanyCreateWithoutUnitsInput, CompanyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUnitsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UnitConversionCreateNestedManyWithoutFromUnitInput = {
    create?: XOR<UnitConversionCreateWithoutFromUnitInput, UnitConversionUncheckedCreateWithoutFromUnitInput> | UnitConversionCreateWithoutFromUnitInput[] | UnitConversionUncheckedCreateWithoutFromUnitInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutFromUnitInput | UnitConversionCreateOrConnectWithoutFromUnitInput[]
    createMany?: UnitConversionCreateManyFromUnitInputEnvelope
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
  }

  export type UnitConversionCreateNestedManyWithoutToUnitInput = {
    create?: XOR<UnitConversionCreateWithoutToUnitInput, UnitConversionUncheckedCreateWithoutToUnitInput> | UnitConversionCreateWithoutToUnitInput[] | UnitConversionUncheckedCreateWithoutToUnitInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutToUnitInput | UnitConversionCreateOrConnectWithoutToUnitInput[]
    createMany?: UnitConversionCreateManyToUnitInputEnvelope
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutUnitInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ItemMasterCreateNestedManyWithoutBaseUnitInput = {
    create?: XOR<ItemMasterCreateWithoutBaseUnitInput, ItemMasterUncheckedCreateWithoutBaseUnitInput> | ItemMasterCreateWithoutBaseUnitInput[] | ItemMasterUncheckedCreateWithoutBaseUnitInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutBaseUnitInput | ItemMasterCreateOrConnectWithoutBaseUnitInput[]
    createMany?: ItemMasterCreateManyBaseUnitInputEnvelope
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
  }

  export type PurchaseOrderItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutUnitInput, PurchaseOrderItemUncheckedCreateWithoutUnitInput> | PurchaseOrderItemCreateWithoutUnitInput[] | PurchaseOrderItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutUnitInput | PurchaseOrderItemCreateOrConnectWithoutUnitInput[]
    createMany?: PurchaseOrderItemCreateManyUnitInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<GRNItemCreateWithoutUnitInput, GRNItemUncheckedCreateWithoutUnitInput> | GRNItemCreateWithoutUnitInput[] | GRNItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutUnitInput | GRNItemCreateOrConnectWithoutUnitInput[]
    createMany?: GRNItemCreateManyUnitInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutUnitInput, PurchaseInvoiceItemUncheckedCreateWithoutUnitInput> | PurchaseInvoiceItemCreateWithoutUnitInput[] | PurchaseInvoiceItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutUnitInput | PurchaseInvoiceItemCreateOrConnectWithoutUnitInput[]
    createMany?: PurchaseInvoiceItemCreateManyUnitInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutUnitInput, PurchaseReturnItemUncheckedCreateWithoutUnitInput> | PurchaseReturnItemCreateWithoutUnitInput[] | PurchaseReturnItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutUnitInput | PurchaseReturnItemCreateOrConnectWithoutUnitInput[]
    createMany?: PurchaseReturnItemCreateManyUnitInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput = {
    create?: XOR<UnitConversionCreateWithoutFromUnitInput, UnitConversionUncheckedCreateWithoutFromUnitInput> | UnitConversionCreateWithoutFromUnitInput[] | UnitConversionUncheckedCreateWithoutFromUnitInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutFromUnitInput | UnitConversionCreateOrConnectWithoutFromUnitInput[]
    createMany?: UnitConversionCreateManyFromUnitInputEnvelope
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
  }

  export type UnitConversionUncheckedCreateNestedManyWithoutToUnitInput = {
    create?: XOR<UnitConversionCreateWithoutToUnitInput, UnitConversionUncheckedCreateWithoutToUnitInput> | UnitConversionCreateWithoutToUnitInput[] | UnitConversionUncheckedCreateWithoutToUnitInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutToUnitInput | UnitConversionCreateOrConnectWithoutToUnitInput[]
    createMany?: UnitConversionCreateManyToUnitInputEnvelope
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput = {
    create?: XOR<ItemMasterCreateWithoutBaseUnitInput, ItemMasterUncheckedCreateWithoutBaseUnitInput> | ItemMasterCreateWithoutBaseUnitInput[] | ItemMasterUncheckedCreateWithoutBaseUnitInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutBaseUnitInput | ItemMasterCreateOrConnectWithoutBaseUnitInput[]
    createMany?: ItemMasterCreateManyBaseUnitInputEnvelope
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutUnitInput, PurchaseOrderItemUncheckedCreateWithoutUnitInput> | PurchaseOrderItemCreateWithoutUnitInput[] | PurchaseOrderItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutUnitInput | PurchaseOrderItemCreateOrConnectWithoutUnitInput[]
    createMany?: PurchaseOrderItemCreateManyUnitInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<GRNItemCreateWithoutUnitInput, GRNItemUncheckedCreateWithoutUnitInput> | GRNItemCreateWithoutUnitInput[] | GRNItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutUnitInput | GRNItemCreateOrConnectWithoutUnitInput[]
    createMany?: GRNItemCreateManyUnitInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutUnitInput, PurchaseInvoiceItemUncheckedCreateWithoutUnitInput> | PurchaseInvoiceItemCreateWithoutUnitInput[] | PurchaseInvoiceItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutUnitInput | PurchaseInvoiceItemCreateOrConnectWithoutUnitInput[]
    createMany?: PurchaseInvoiceItemCreateManyUnitInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutUnitInput, PurchaseReturnItemUncheckedCreateWithoutUnitInput> | PurchaseReturnItemCreateWithoutUnitInput[] | PurchaseReturnItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutUnitInput | PurchaseReturnItemCreateOrConnectWithoutUnitInput[]
    createMany?: PurchaseReturnItemCreateManyUnitInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutUnitsNestedInput = {
    create?: XOR<CompanyCreateWithoutUnitsInput, CompanyUncheckedCreateWithoutUnitsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUnitsInput
    upsert?: CompanyUpsertWithoutUnitsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUnitsInput, CompanyUpdateWithoutUnitsInput>, CompanyUncheckedUpdateWithoutUnitsInput>
  }

  export type UnitConversionUpdateManyWithoutFromUnitNestedInput = {
    create?: XOR<UnitConversionCreateWithoutFromUnitInput, UnitConversionUncheckedCreateWithoutFromUnitInput> | UnitConversionCreateWithoutFromUnitInput[] | UnitConversionUncheckedCreateWithoutFromUnitInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutFromUnitInput | UnitConversionCreateOrConnectWithoutFromUnitInput[]
    upsert?: UnitConversionUpsertWithWhereUniqueWithoutFromUnitInput | UnitConversionUpsertWithWhereUniqueWithoutFromUnitInput[]
    createMany?: UnitConversionCreateManyFromUnitInputEnvelope
    set?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    disconnect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    delete?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    update?: UnitConversionUpdateWithWhereUniqueWithoutFromUnitInput | UnitConversionUpdateWithWhereUniqueWithoutFromUnitInput[]
    updateMany?: UnitConversionUpdateManyWithWhereWithoutFromUnitInput | UnitConversionUpdateManyWithWhereWithoutFromUnitInput[]
    deleteMany?: UnitConversionScalarWhereInput | UnitConversionScalarWhereInput[]
  }

  export type UnitConversionUpdateManyWithoutToUnitNestedInput = {
    create?: XOR<UnitConversionCreateWithoutToUnitInput, UnitConversionUncheckedCreateWithoutToUnitInput> | UnitConversionCreateWithoutToUnitInput[] | UnitConversionUncheckedCreateWithoutToUnitInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutToUnitInput | UnitConversionCreateOrConnectWithoutToUnitInput[]
    upsert?: UnitConversionUpsertWithWhereUniqueWithoutToUnitInput | UnitConversionUpsertWithWhereUniqueWithoutToUnitInput[]
    createMany?: UnitConversionCreateManyToUnitInputEnvelope
    set?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    disconnect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    delete?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    update?: UnitConversionUpdateWithWhereUniqueWithoutToUnitInput | UnitConversionUpdateWithWhereUniqueWithoutToUnitInput[]
    updateMany?: UnitConversionUpdateManyWithWhereWithoutToUnitInput | UnitConversionUpdateManyWithWhereWithoutToUnitInput[]
    deleteMany?: UnitConversionScalarWhereInput | UnitConversionScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitInput | ProductUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitInput | ProductUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitInput | ProductUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ItemMasterUpdateManyWithoutBaseUnitNestedInput = {
    create?: XOR<ItemMasterCreateWithoutBaseUnitInput, ItemMasterUncheckedCreateWithoutBaseUnitInput> | ItemMasterCreateWithoutBaseUnitInput[] | ItemMasterUncheckedCreateWithoutBaseUnitInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutBaseUnitInput | ItemMasterCreateOrConnectWithoutBaseUnitInput[]
    upsert?: ItemMasterUpsertWithWhereUniqueWithoutBaseUnitInput | ItemMasterUpsertWithWhereUniqueWithoutBaseUnitInput[]
    createMany?: ItemMasterCreateManyBaseUnitInputEnvelope
    set?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    disconnect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    delete?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    update?: ItemMasterUpdateWithWhereUniqueWithoutBaseUnitInput | ItemMasterUpdateWithWhereUniqueWithoutBaseUnitInput[]
    updateMany?: ItemMasterUpdateManyWithWhereWithoutBaseUnitInput | ItemMasterUpdateManyWithWhereWithoutBaseUnitInput[]
    deleteMany?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
  }

  export type PurchaseOrderItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutUnitInput, PurchaseOrderItemUncheckedCreateWithoutUnitInput> | PurchaseOrderItemCreateWithoutUnitInput[] | PurchaseOrderItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutUnitInput | PurchaseOrderItemCreateOrConnectWithoutUnitInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutUnitInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: PurchaseOrderItemCreateManyUnitInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutUnitInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutUnitInput | PurchaseOrderItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<GRNItemCreateWithoutUnitInput, GRNItemUncheckedCreateWithoutUnitInput> | GRNItemCreateWithoutUnitInput[] | GRNItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutUnitInput | GRNItemCreateOrConnectWithoutUnitInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutUnitInput | GRNItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: GRNItemCreateManyUnitInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutUnitInput | GRNItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutUnitInput | GRNItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutUnitInput, PurchaseInvoiceItemUncheckedCreateWithoutUnitInput> | PurchaseInvoiceItemCreateWithoutUnitInput[] | PurchaseInvoiceItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutUnitInput | PurchaseInvoiceItemCreateOrConnectWithoutUnitInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutUnitInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: PurchaseInvoiceItemCreateManyUnitInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutUnitInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutUnitInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutUnitInput, PurchaseReturnItemUncheckedCreateWithoutUnitInput> | PurchaseReturnItemCreateWithoutUnitInput[] | PurchaseReturnItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutUnitInput | PurchaseReturnItemCreateOrConnectWithoutUnitInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutUnitInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: PurchaseReturnItemCreateManyUnitInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutUnitInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutUnitInput | PurchaseReturnItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput = {
    create?: XOR<UnitConversionCreateWithoutFromUnitInput, UnitConversionUncheckedCreateWithoutFromUnitInput> | UnitConversionCreateWithoutFromUnitInput[] | UnitConversionUncheckedCreateWithoutFromUnitInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutFromUnitInput | UnitConversionCreateOrConnectWithoutFromUnitInput[]
    upsert?: UnitConversionUpsertWithWhereUniqueWithoutFromUnitInput | UnitConversionUpsertWithWhereUniqueWithoutFromUnitInput[]
    createMany?: UnitConversionCreateManyFromUnitInputEnvelope
    set?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    disconnect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    delete?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    update?: UnitConversionUpdateWithWhereUniqueWithoutFromUnitInput | UnitConversionUpdateWithWhereUniqueWithoutFromUnitInput[]
    updateMany?: UnitConversionUpdateManyWithWhereWithoutFromUnitInput | UnitConversionUpdateManyWithWhereWithoutFromUnitInput[]
    deleteMany?: UnitConversionScalarWhereInput | UnitConversionScalarWhereInput[]
  }

  export type UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput = {
    create?: XOR<UnitConversionCreateWithoutToUnitInput, UnitConversionUncheckedCreateWithoutToUnitInput> | UnitConversionCreateWithoutToUnitInput[] | UnitConversionUncheckedCreateWithoutToUnitInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutToUnitInput | UnitConversionCreateOrConnectWithoutToUnitInput[]
    upsert?: UnitConversionUpsertWithWhereUniqueWithoutToUnitInput | UnitConversionUpsertWithWhereUniqueWithoutToUnitInput[]
    createMany?: UnitConversionCreateManyToUnitInputEnvelope
    set?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    disconnect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    delete?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    update?: UnitConversionUpdateWithWhereUniqueWithoutToUnitInput | UnitConversionUpdateWithWhereUniqueWithoutToUnitInput[]
    updateMany?: UnitConversionUpdateManyWithWhereWithoutToUnitInput | UnitConversionUpdateManyWithWhereWithoutToUnitInput[]
    deleteMany?: UnitConversionScalarWhereInput | UnitConversionScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput> | ProductCreateWithoutUnitInput[] | ProductUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUnitInput | ProductCreateOrConnectWithoutUnitInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUnitInput | ProductUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ProductCreateManyUnitInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUnitInput | ProductUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUnitInput | ProductUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput = {
    create?: XOR<ItemMasterCreateWithoutBaseUnitInput, ItemMasterUncheckedCreateWithoutBaseUnitInput> | ItemMasterCreateWithoutBaseUnitInput[] | ItemMasterUncheckedCreateWithoutBaseUnitInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutBaseUnitInput | ItemMasterCreateOrConnectWithoutBaseUnitInput[]
    upsert?: ItemMasterUpsertWithWhereUniqueWithoutBaseUnitInput | ItemMasterUpsertWithWhereUniqueWithoutBaseUnitInput[]
    createMany?: ItemMasterCreateManyBaseUnitInputEnvelope
    set?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    disconnect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    delete?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    update?: ItemMasterUpdateWithWhereUniqueWithoutBaseUnitInput | ItemMasterUpdateWithWhereUniqueWithoutBaseUnitInput[]
    updateMany?: ItemMasterUpdateManyWithWhereWithoutBaseUnitInput | ItemMasterUpdateManyWithWhereWithoutBaseUnitInput[]
    deleteMany?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutUnitInput, PurchaseOrderItemUncheckedCreateWithoutUnitInput> | PurchaseOrderItemCreateWithoutUnitInput[] | PurchaseOrderItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutUnitInput | PurchaseOrderItemCreateOrConnectWithoutUnitInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutUnitInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: PurchaseOrderItemCreateManyUnitInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutUnitInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutUnitInput | PurchaseOrderItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<GRNItemCreateWithoutUnitInput, GRNItemUncheckedCreateWithoutUnitInput> | GRNItemCreateWithoutUnitInput[] | GRNItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutUnitInput | GRNItemCreateOrConnectWithoutUnitInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutUnitInput | GRNItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: GRNItemCreateManyUnitInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutUnitInput | GRNItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutUnitInput | GRNItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutUnitInput, PurchaseInvoiceItemUncheckedCreateWithoutUnitInput> | PurchaseInvoiceItemCreateWithoutUnitInput[] | PurchaseInvoiceItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutUnitInput | PurchaseInvoiceItemCreateOrConnectWithoutUnitInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutUnitInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: PurchaseInvoiceItemCreateManyUnitInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutUnitInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutUnitInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutUnitInput, PurchaseReturnItemUncheckedCreateWithoutUnitInput> | PurchaseReturnItemCreateWithoutUnitInput[] | PurchaseReturnItemUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutUnitInput | PurchaseReturnItemCreateOrConnectWithoutUnitInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutUnitInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: PurchaseReturnItemCreateManyUnitInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutUnitInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutUnitInput | PurchaseReturnItemUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutUnitConversionsInput = {
    create?: XOR<CompanyCreateWithoutUnitConversionsInput, CompanyUncheckedCreateWithoutUnitConversionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUnitConversionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutConversionsFromInput = {
    create?: XOR<UnitCreateWithoutConversionsFromInput, UnitUncheckedCreateWithoutConversionsFromInput>
    connectOrCreate?: UnitCreateOrConnectWithoutConversionsFromInput
    connect?: UnitWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutConversionsToInput = {
    create?: XOR<UnitCreateWithoutConversionsToInput, UnitUncheckedCreateWithoutConversionsToInput>
    connectOrCreate?: UnitCreateOrConnectWithoutConversionsToInput
    connect?: UnitWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneRequiredWithoutUnitConversionsNestedInput = {
    create?: XOR<CompanyCreateWithoutUnitConversionsInput, CompanyUncheckedCreateWithoutUnitConversionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUnitConversionsInput
    upsert?: CompanyUpsertWithoutUnitConversionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUnitConversionsInput, CompanyUpdateWithoutUnitConversionsInput>, CompanyUncheckedUpdateWithoutUnitConversionsInput>
  }

  export type UnitUpdateOneRequiredWithoutConversionsFromNestedInput = {
    create?: XOR<UnitCreateWithoutConversionsFromInput, UnitUncheckedCreateWithoutConversionsFromInput>
    connectOrCreate?: UnitCreateOrConnectWithoutConversionsFromInput
    upsert?: UnitUpsertWithoutConversionsFromInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutConversionsFromInput, UnitUpdateWithoutConversionsFromInput>, UnitUncheckedUpdateWithoutConversionsFromInput>
  }

  export type UnitUpdateOneRequiredWithoutConversionsToNestedInput = {
    create?: XOR<UnitCreateWithoutConversionsToInput, UnitUncheckedCreateWithoutConversionsToInput>
    connectOrCreate?: UnitCreateOrConnectWithoutConversionsToInput
    upsert?: UnitUpsertWithoutConversionsToInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutConversionsToInput, UnitUpdateWithoutConversionsToInput>, UnitUncheckedUpdateWithoutConversionsToInput>
  }

  export type ItemGroupCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ItemGroupCreateWithoutCompanyInput, ItemGroupUncheckedCreateWithoutCompanyInput> | ItemGroupCreateWithoutCompanyInput[] | ItemGroupUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemGroupCreateOrConnectWithoutCompanyInput | ItemGroupCreateOrConnectWithoutCompanyInput[]
    createMany?: ItemGroupCreateManyCompanyInputEnvelope
    connect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
  }

  export type ColorCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ColorCreateWithoutCompanyInput, ColorUncheckedCreateWithoutCompanyInput> | ColorCreateWithoutCompanyInput[] | ColorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ColorCreateOrConnectWithoutCompanyInput | ColorCreateOrConnectWithoutCompanyInput[]
    createMany?: ColorCreateManyCompanyInputEnvelope
    connect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
  }

  export type BrandCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BrandCreateWithoutCompanyInput, BrandUncheckedCreateWithoutCompanyInput> | BrandCreateWithoutCompanyInput[] | BrandUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BrandCreateOrConnectWithoutCompanyInput | BrandCreateOrConnectWithoutCompanyInput[]
    createMany?: BrandCreateManyCompanyInputEnvelope
    connect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UnitCreateWithoutCompanyInput, UnitUncheckedCreateWithoutCompanyInput> | UnitCreateWithoutCompanyInput[] | UnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutCompanyInput | UnitCreateOrConnectWithoutCompanyInput[]
    createMany?: UnitCreateManyCompanyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ItemGradeCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ItemGradeCreateWithoutCompanyInput, ItemGradeUncheckedCreateWithoutCompanyInput> | ItemGradeCreateWithoutCompanyInput[] | ItemGradeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemGradeCreateOrConnectWithoutCompanyInput | ItemGradeCreateOrConnectWithoutCompanyInput[]
    createMany?: ItemGradeCreateManyCompanyInputEnvelope
    connect?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
  }

  export type UnitConversionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UnitConversionCreateWithoutCompanyInput, UnitConversionUncheckedCreateWithoutCompanyInput> | UnitConversionCreateWithoutCompanyInput[] | UnitConversionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutCompanyInput | UnitConversionCreateOrConnectWithoutCompanyInput[]
    createMany?: UnitConversionCreateManyCompanyInputEnvelope
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
  }

  export type ItemMasterCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ItemMasterCreateWithoutCompanyInput, ItemMasterUncheckedCreateWithoutCompanyInput> | ItemMasterCreateWithoutCompanyInput[] | ItemMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutCompanyInput | ItemMasterCreateOrConnectWithoutCompanyInput[]
    createMany?: ItemMasterCreateManyCompanyInputEnvelope
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type GRNCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GRNCreateWithoutCompanyInput, GRNUncheckedCreateWithoutCompanyInput> | GRNCreateWithoutCompanyInput[] | GRNUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutCompanyInput | GRNCreateOrConnectWithoutCompanyInput[]
    createMany?: GRNCreateManyCompanyInputEnvelope
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
  }

  export type PurchaseInvoiceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput> | PurchaseInvoiceCreateWithoutCompanyInput[] | PurchaseInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCompanyInput | PurchaseInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseInvoiceCreateManyCompanyInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type PurchaseReturnCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseReturnCreateWithoutCompanyInput, PurchaseReturnUncheckedCreateWithoutCompanyInput> | PurchaseReturnCreateWithoutCompanyInput[] | PurchaseReturnUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutCompanyInput | PurchaseReturnCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseReturnCreateManyCompanyInputEnvelope
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
  }

  export type PackingUnitCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PackingUnitCreateWithoutCompanyInput, PackingUnitUncheckedCreateWithoutCompanyInput> | PackingUnitCreateWithoutCompanyInput[] | PackingUnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PackingUnitCreateOrConnectWithoutCompanyInput | PackingUnitCreateOrConnectWithoutCompanyInput[]
    createMany?: PackingUnitCreateManyCompanyInputEnvelope
    connect?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
  }

  export type ItemGroupUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ItemGroupCreateWithoutCompanyInput, ItemGroupUncheckedCreateWithoutCompanyInput> | ItemGroupCreateWithoutCompanyInput[] | ItemGroupUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemGroupCreateOrConnectWithoutCompanyInput | ItemGroupCreateOrConnectWithoutCompanyInput[]
    createMany?: ItemGroupCreateManyCompanyInputEnvelope
    connect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
  }

  export type ColorUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ColorCreateWithoutCompanyInput, ColorUncheckedCreateWithoutCompanyInput> | ColorCreateWithoutCompanyInput[] | ColorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ColorCreateOrConnectWithoutCompanyInput | ColorCreateOrConnectWithoutCompanyInput[]
    createMany?: ColorCreateManyCompanyInputEnvelope
    connect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
  }

  export type BrandUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BrandCreateWithoutCompanyInput, BrandUncheckedCreateWithoutCompanyInput> | BrandCreateWithoutCompanyInput[] | BrandUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BrandCreateOrConnectWithoutCompanyInput | BrandCreateOrConnectWithoutCompanyInput[]
    createMany?: BrandCreateManyCompanyInputEnvelope
    connect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UnitCreateWithoutCompanyInput, UnitUncheckedCreateWithoutCompanyInput> | UnitCreateWithoutCompanyInput[] | UnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutCompanyInput | UnitCreateOrConnectWithoutCompanyInput[]
    createMany?: UnitCreateManyCompanyInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type ItemGradeUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ItemGradeCreateWithoutCompanyInput, ItemGradeUncheckedCreateWithoutCompanyInput> | ItemGradeCreateWithoutCompanyInput[] | ItemGradeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemGradeCreateOrConnectWithoutCompanyInput | ItemGradeCreateOrConnectWithoutCompanyInput[]
    createMany?: ItemGradeCreateManyCompanyInputEnvelope
    connect?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
  }

  export type UnitConversionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UnitConversionCreateWithoutCompanyInput, UnitConversionUncheckedCreateWithoutCompanyInput> | UnitConversionCreateWithoutCompanyInput[] | UnitConversionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutCompanyInput | UnitConversionCreateOrConnectWithoutCompanyInput[]
    createMany?: UnitConversionCreateManyCompanyInputEnvelope
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
  }

  export type ItemMasterUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ItemMasterCreateWithoutCompanyInput, ItemMasterUncheckedCreateWithoutCompanyInput> | ItemMasterCreateWithoutCompanyInput[] | ItemMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutCompanyInput | ItemMasterCreateOrConnectWithoutCompanyInput[]
    createMany?: ItemMasterCreateManyCompanyInputEnvelope
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type GRNUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<GRNCreateWithoutCompanyInput, GRNUncheckedCreateWithoutCompanyInput> | GRNCreateWithoutCompanyInput[] | GRNUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutCompanyInput | GRNCreateOrConnectWithoutCompanyInput[]
    createMany?: GRNCreateManyCompanyInputEnvelope
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
  }

  export type PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput> | PurchaseInvoiceCreateWithoutCompanyInput[] | PurchaseInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCompanyInput | PurchaseInvoiceCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseInvoiceCreateManyCompanyInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PurchaseReturnCreateWithoutCompanyInput, PurchaseReturnUncheckedCreateWithoutCompanyInput> | PurchaseReturnCreateWithoutCompanyInput[] | PurchaseReturnUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutCompanyInput | PurchaseReturnCreateOrConnectWithoutCompanyInput[]
    createMany?: PurchaseReturnCreateManyCompanyInputEnvelope
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
  }

  export type PackingUnitUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<PackingUnitCreateWithoutCompanyInput, PackingUnitUncheckedCreateWithoutCompanyInput> | PackingUnitCreateWithoutCompanyInput[] | PackingUnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PackingUnitCreateOrConnectWithoutCompanyInput | PackingUnitCreateOrConnectWithoutCompanyInput[]
    createMany?: PackingUnitCreateManyCompanyInputEnvelope
    connect?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
  }

  export type ItemGroupUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ItemGroupCreateWithoutCompanyInput, ItemGroupUncheckedCreateWithoutCompanyInput> | ItemGroupCreateWithoutCompanyInput[] | ItemGroupUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemGroupCreateOrConnectWithoutCompanyInput | ItemGroupCreateOrConnectWithoutCompanyInput[]
    upsert?: ItemGroupUpsertWithWhereUniqueWithoutCompanyInput | ItemGroupUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ItemGroupCreateManyCompanyInputEnvelope
    set?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    disconnect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    delete?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    connect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    update?: ItemGroupUpdateWithWhereUniqueWithoutCompanyInput | ItemGroupUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ItemGroupUpdateManyWithWhereWithoutCompanyInput | ItemGroupUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ItemGroupScalarWhereInput | ItemGroupScalarWhereInput[]
  }

  export type ColorUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ColorCreateWithoutCompanyInput, ColorUncheckedCreateWithoutCompanyInput> | ColorCreateWithoutCompanyInput[] | ColorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ColorCreateOrConnectWithoutCompanyInput | ColorCreateOrConnectWithoutCompanyInput[]
    upsert?: ColorUpsertWithWhereUniqueWithoutCompanyInput | ColorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ColorCreateManyCompanyInputEnvelope
    set?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    disconnect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    delete?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    connect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    update?: ColorUpdateWithWhereUniqueWithoutCompanyInput | ColorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ColorUpdateManyWithWhereWithoutCompanyInput | ColorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ColorScalarWhereInput | ColorScalarWhereInput[]
  }

  export type BrandUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BrandCreateWithoutCompanyInput, BrandUncheckedCreateWithoutCompanyInput> | BrandCreateWithoutCompanyInput[] | BrandUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BrandCreateOrConnectWithoutCompanyInput | BrandCreateOrConnectWithoutCompanyInput[]
    upsert?: BrandUpsertWithWhereUniqueWithoutCompanyInput | BrandUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BrandCreateManyCompanyInputEnvelope
    set?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    disconnect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    delete?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    connect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    update?: BrandUpdateWithWhereUniqueWithoutCompanyInput | BrandUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BrandUpdateManyWithWhereWithoutCompanyInput | BrandUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BrandScalarWhereInput | BrandScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UnitCreateWithoutCompanyInput, UnitUncheckedCreateWithoutCompanyInput> | UnitCreateWithoutCompanyInput[] | UnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutCompanyInput | UnitCreateOrConnectWithoutCompanyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutCompanyInput | UnitUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UnitCreateManyCompanyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutCompanyInput | UnitUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutCompanyInput | UnitUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ItemGradeUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ItemGradeCreateWithoutCompanyInput, ItemGradeUncheckedCreateWithoutCompanyInput> | ItemGradeCreateWithoutCompanyInput[] | ItemGradeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemGradeCreateOrConnectWithoutCompanyInput | ItemGradeCreateOrConnectWithoutCompanyInput[]
    upsert?: ItemGradeUpsertWithWhereUniqueWithoutCompanyInput | ItemGradeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ItemGradeCreateManyCompanyInputEnvelope
    set?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
    disconnect?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
    delete?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
    connect?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
    update?: ItemGradeUpdateWithWhereUniqueWithoutCompanyInput | ItemGradeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ItemGradeUpdateManyWithWhereWithoutCompanyInput | ItemGradeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ItemGradeScalarWhereInput | ItemGradeScalarWhereInput[]
  }

  export type UnitConversionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UnitConversionCreateWithoutCompanyInput, UnitConversionUncheckedCreateWithoutCompanyInput> | UnitConversionCreateWithoutCompanyInput[] | UnitConversionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutCompanyInput | UnitConversionCreateOrConnectWithoutCompanyInput[]
    upsert?: UnitConversionUpsertWithWhereUniqueWithoutCompanyInput | UnitConversionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UnitConversionCreateManyCompanyInputEnvelope
    set?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    disconnect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    delete?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    update?: UnitConversionUpdateWithWhereUniqueWithoutCompanyInput | UnitConversionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UnitConversionUpdateManyWithWhereWithoutCompanyInput | UnitConversionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UnitConversionScalarWhereInput | UnitConversionScalarWhereInput[]
  }

  export type ItemMasterUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ItemMasterCreateWithoutCompanyInput, ItemMasterUncheckedCreateWithoutCompanyInput> | ItemMasterCreateWithoutCompanyInput[] | ItemMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutCompanyInput | ItemMasterCreateOrConnectWithoutCompanyInput[]
    upsert?: ItemMasterUpsertWithWhereUniqueWithoutCompanyInput | ItemMasterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ItemMasterCreateManyCompanyInputEnvelope
    set?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    disconnect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    delete?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    update?: ItemMasterUpdateWithWhereUniqueWithoutCompanyInput | ItemMasterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ItemMasterUpdateManyWithWhereWithoutCompanyInput | ItemMasterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCompanyInput | PurchaseOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type GRNUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GRNCreateWithoutCompanyInput, GRNUncheckedCreateWithoutCompanyInput> | GRNCreateWithoutCompanyInput[] | GRNUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutCompanyInput | GRNCreateOrConnectWithoutCompanyInput[]
    upsert?: GRNUpsertWithWhereUniqueWithoutCompanyInput | GRNUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GRNCreateManyCompanyInputEnvelope
    set?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    disconnect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    delete?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    update?: GRNUpdateWithWhereUniqueWithoutCompanyInput | GRNUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GRNUpdateManyWithWhereWithoutCompanyInput | GRNUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GRNScalarWhereInput | GRNScalarWhereInput[]
  }

  export type PurchaseInvoiceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput> | PurchaseInvoiceCreateWithoutCompanyInput[] | PurchaseInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCompanyInput | PurchaseInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseInvoiceCreateManyCompanyInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput | PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PurchaseReturnUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseReturnCreateWithoutCompanyInput, PurchaseReturnUncheckedCreateWithoutCompanyInput> | PurchaseReturnCreateWithoutCompanyInput[] | PurchaseReturnUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutCompanyInput | PurchaseReturnCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseReturnUpsertWithWhereUniqueWithoutCompanyInput | PurchaseReturnUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseReturnCreateManyCompanyInputEnvelope
    set?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    disconnect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    delete?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    update?: PurchaseReturnUpdateWithWhereUniqueWithoutCompanyInput | PurchaseReturnUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseReturnUpdateManyWithWhereWithoutCompanyInput | PurchaseReturnUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
  }

  export type PackingUnitUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PackingUnitCreateWithoutCompanyInput, PackingUnitUncheckedCreateWithoutCompanyInput> | PackingUnitCreateWithoutCompanyInput[] | PackingUnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PackingUnitCreateOrConnectWithoutCompanyInput | PackingUnitCreateOrConnectWithoutCompanyInput[]
    upsert?: PackingUnitUpsertWithWhereUniqueWithoutCompanyInput | PackingUnitUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PackingUnitCreateManyCompanyInputEnvelope
    set?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
    disconnect?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
    delete?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
    connect?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
    update?: PackingUnitUpdateWithWhereUniqueWithoutCompanyInput | PackingUnitUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PackingUnitUpdateManyWithWhereWithoutCompanyInput | PackingUnitUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PackingUnitScalarWhereInput | PackingUnitScalarWhereInput[]
  }

  export type ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ItemGroupCreateWithoutCompanyInput, ItemGroupUncheckedCreateWithoutCompanyInput> | ItemGroupCreateWithoutCompanyInput[] | ItemGroupUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemGroupCreateOrConnectWithoutCompanyInput | ItemGroupCreateOrConnectWithoutCompanyInput[]
    upsert?: ItemGroupUpsertWithWhereUniqueWithoutCompanyInput | ItemGroupUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ItemGroupCreateManyCompanyInputEnvelope
    set?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    disconnect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    delete?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    connect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    update?: ItemGroupUpdateWithWhereUniqueWithoutCompanyInput | ItemGroupUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ItemGroupUpdateManyWithWhereWithoutCompanyInput | ItemGroupUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ItemGroupScalarWhereInput | ItemGroupScalarWhereInput[]
  }

  export type ColorUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ColorCreateWithoutCompanyInput, ColorUncheckedCreateWithoutCompanyInput> | ColorCreateWithoutCompanyInput[] | ColorUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ColorCreateOrConnectWithoutCompanyInput | ColorCreateOrConnectWithoutCompanyInput[]
    upsert?: ColorUpsertWithWhereUniqueWithoutCompanyInput | ColorUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ColorCreateManyCompanyInputEnvelope
    set?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    disconnect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    delete?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    connect?: ColorWhereUniqueInput | ColorWhereUniqueInput[]
    update?: ColorUpdateWithWhereUniqueWithoutCompanyInput | ColorUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ColorUpdateManyWithWhereWithoutCompanyInput | ColorUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ColorScalarWhereInput | ColorScalarWhereInput[]
  }

  export type BrandUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BrandCreateWithoutCompanyInput, BrandUncheckedCreateWithoutCompanyInput> | BrandCreateWithoutCompanyInput[] | BrandUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BrandCreateOrConnectWithoutCompanyInput | BrandCreateOrConnectWithoutCompanyInput[]
    upsert?: BrandUpsertWithWhereUniqueWithoutCompanyInput | BrandUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BrandCreateManyCompanyInputEnvelope
    set?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    disconnect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    delete?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    connect?: BrandWhereUniqueInput | BrandWhereUniqueInput[]
    update?: BrandUpdateWithWhereUniqueWithoutCompanyInput | BrandUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BrandUpdateManyWithWhereWithoutCompanyInput | BrandUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BrandScalarWhereInput | BrandScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UnitCreateWithoutCompanyInput, UnitUncheckedCreateWithoutCompanyInput> | UnitCreateWithoutCompanyInput[] | UnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutCompanyInput | UnitCreateOrConnectWithoutCompanyInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutCompanyInput | UnitUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UnitCreateManyCompanyInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutCompanyInput | UnitUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutCompanyInput | UnitUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ItemGradeCreateWithoutCompanyInput, ItemGradeUncheckedCreateWithoutCompanyInput> | ItemGradeCreateWithoutCompanyInput[] | ItemGradeUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemGradeCreateOrConnectWithoutCompanyInput | ItemGradeCreateOrConnectWithoutCompanyInput[]
    upsert?: ItemGradeUpsertWithWhereUniqueWithoutCompanyInput | ItemGradeUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ItemGradeCreateManyCompanyInputEnvelope
    set?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
    disconnect?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
    delete?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
    connect?: ItemGradeWhereUniqueInput | ItemGradeWhereUniqueInput[]
    update?: ItemGradeUpdateWithWhereUniqueWithoutCompanyInput | ItemGradeUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ItemGradeUpdateManyWithWhereWithoutCompanyInput | ItemGradeUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ItemGradeScalarWhereInput | ItemGradeScalarWhereInput[]
  }

  export type UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UnitConversionCreateWithoutCompanyInput, UnitConversionUncheckedCreateWithoutCompanyInput> | UnitConversionCreateWithoutCompanyInput[] | UnitConversionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UnitConversionCreateOrConnectWithoutCompanyInput | UnitConversionCreateOrConnectWithoutCompanyInput[]
    upsert?: UnitConversionUpsertWithWhereUniqueWithoutCompanyInput | UnitConversionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UnitConversionCreateManyCompanyInputEnvelope
    set?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    disconnect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    delete?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    connect?: UnitConversionWhereUniqueInput | UnitConversionWhereUniqueInput[]
    update?: UnitConversionUpdateWithWhereUniqueWithoutCompanyInput | UnitConversionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UnitConversionUpdateManyWithWhereWithoutCompanyInput | UnitConversionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UnitConversionScalarWhereInput | UnitConversionScalarWhereInput[]
  }

  export type ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ItemMasterCreateWithoutCompanyInput, ItemMasterUncheckedCreateWithoutCompanyInput> | ItemMasterCreateWithoutCompanyInput[] | ItemMasterUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutCompanyInput | ItemMasterCreateOrConnectWithoutCompanyInput[]
    upsert?: ItemMasterUpsertWithWhereUniqueWithoutCompanyInput | ItemMasterUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ItemMasterCreateManyCompanyInputEnvelope
    set?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    disconnect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    delete?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    update?: ItemMasterUpdateWithWhereUniqueWithoutCompanyInput | ItemMasterUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ItemMasterUpdateManyWithWhereWithoutCompanyInput | ItemMasterUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput> | PurchaseOrderCreateWithoutCompanyInput[] | PurchaseOrderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCompanyInput | PurchaseOrderCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseOrderCreateManyCompanyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCompanyInput | PurchaseOrderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type GRNUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<GRNCreateWithoutCompanyInput, GRNUncheckedCreateWithoutCompanyInput> | GRNCreateWithoutCompanyInput[] | GRNUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutCompanyInput | GRNCreateOrConnectWithoutCompanyInput[]
    upsert?: GRNUpsertWithWhereUniqueWithoutCompanyInput | GRNUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: GRNCreateManyCompanyInputEnvelope
    set?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    disconnect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    delete?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    update?: GRNUpdateWithWhereUniqueWithoutCompanyInput | GRNUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: GRNUpdateManyWithWhereWithoutCompanyInput | GRNUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: GRNScalarWhereInput | GRNScalarWhereInput[]
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput> | PurchaseInvoiceCreateWithoutCompanyInput[] | PurchaseInvoiceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutCompanyInput | PurchaseInvoiceCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseInvoiceCreateManyCompanyInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput | PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PurchaseReturnCreateWithoutCompanyInput, PurchaseReturnUncheckedCreateWithoutCompanyInput> | PurchaseReturnCreateWithoutCompanyInput[] | PurchaseReturnUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutCompanyInput | PurchaseReturnCreateOrConnectWithoutCompanyInput[]
    upsert?: PurchaseReturnUpsertWithWhereUniqueWithoutCompanyInput | PurchaseReturnUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PurchaseReturnCreateManyCompanyInputEnvelope
    set?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    disconnect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    delete?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    update?: PurchaseReturnUpdateWithWhereUniqueWithoutCompanyInput | PurchaseReturnUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PurchaseReturnUpdateManyWithWhereWithoutCompanyInput | PurchaseReturnUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
  }

  export type PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<PackingUnitCreateWithoutCompanyInput, PackingUnitUncheckedCreateWithoutCompanyInput> | PackingUnitCreateWithoutCompanyInput[] | PackingUnitUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: PackingUnitCreateOrConnectWithoutCompanyInput | PackingUnitCreateOrConnectWithoutCompanyInput[]
    upsert?: PackingUnitUpsertWithWhereUniqueWithoutCompanyInput | PackingUnitUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: PackingUnitCreateManyCompanyInputEnvelope
    set?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
    disconnect?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
    delete?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
    connect?: PackingUnitWhereUniqueInput | PackingUnitWhereUniqueInput[]
    update?: PackingUnitUpdateWithWhereUniqueWithoutCompanyInput | PackingUnitUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: PackingUnitUpdateManyWithWhereWithoutCompanyInput | PackingUnitUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: PackingUnitScalarWhereInput | PackingUnitScalarWhereInput[]
  }

  export type JournalEntryCreateNestedManyWithoutFiscalYearInput = {
    create?: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput> | JournalEntryCreateWithoutFiscalYearInput[] | JournalEntryUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutFiscalYearInput | JournalEntryCreateOrConnectWithoutFiscalYearInput[]
    createMany?: JournalEntryCreateManyFiscalYearInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutFiscalYearInput = {
    create?: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput> | JournalEntryCreateWithoutFiscalYearInput[] | JournalEntryUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutFiscalYearInput | JournalEntryCreateOrConnectWithoutFiscalYearInput[]
    createMany?: JournalEntryCreateManyFiscalYearInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type JournalEntryUpdateManyWithoutFiscalYearNestedInput = {
    create?: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput> | JournalEntryCreateWithoutFiscalYearInput[] | JournalEntryUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutFiscalYearInput | JournalEntryCreateOrConnectWithoutFiscalYearInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput | JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput[]
    createMany?: JournalEntryCreateManyFiscalYearInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput | JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutFiscalYearInput | JournalEntryUpdateManyWithWhereWithoutFiscalYearInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type JournalEntryUncheckedUpdateManyWithoutFiscalYearNestedInput = {
    create?: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput> | JournalEntryCreateWithoutFiscalYearInput[] | JournalEntryUncheckedCreateWithoutFiscalYearInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutFiscalYearInput | JournalEntryCreateOrConnectWithoutFiscalYearInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput | JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput[]
    createMany?: JournalEntryCreateManyFiscalYearInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput | JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutFiscalYearInput | JournalEntryUpdateManyWithWhereWithoutFiscalYearInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCurrencyInput, PurchaseOrderUncheckedCreateWithoutCurrencyInput> | PurchaseOrderCreateWithoutCurrencyInput[] | PurchaseOrderUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCurrencyInput | PurchaseOrderCreateOrConnectWithoutCurrencyInput[]
    createMany?: PurchaseOrderCreateManyCurrencyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<PurchaseOrderCreateWithoutCurrencyInput, PurchaseOrderUncheckedCreateWithoutCurrencyInput> | PurchaseOrderCreateWithoutCurrencyInput[] | PurchaseOrderUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCurrencyInput | PurchaseOrderCreateOrConnectWithoutCurrencyInput[]
    createMany?: PurchaseOrderCreateManyCurrencyInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCurrencyInput, PurchaseOrderUncheckedCreateWithoutCurrencyInput> | PurchaseOrderCreateWithoutCurrencyInput[] | PurchaseOrderUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCurrencyInput | PurchaseOrderCreateOrConnectWithoutCurrencyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCurrencyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: PurchaseOrderCreateManyCurrencyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCurrencyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCurrencyInput | PurchaseOrderUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCurrencyInput, PurchaseOrderUncheckedCreateWithoutCurrencyInput> | PurchaseOrderCreateWithoutCurrencyInput[] | PurchaseOrderUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCurrencyInput | PurchaseOrderCreateOrConnectWithoutCurrencyInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCurrencyInput | PurchaseOrderUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: PurchaseOrderCreateManyCurrencyInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCurrencyInput | PurchaseOrderUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCurrencyInput | PurchaseOrderUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutProductsInput = {
    create?: XOR<UnitCreateWithoutProductsInput, UnitUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutProductsInput
    connect?: UnitWhereUniqueInput
  }

  export type VariantCreateNestedManyWithoutProductInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
  }

  export type VariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type UnitUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<UnitCreateWithoutProductsInput, UnitUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutProductsInput
    upsert?: UnitUpsertWithoutProductsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutProductsInput, UnitUpdateWithoutProductsInput>, UnitUncheckedUpdateWithoutProductsInput>
  }

  export type VariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    upsert?: VariantUpsertWithWhereUniqueWithoutProductInput | VariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    set?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    disconnect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    delete?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    update?: VariantUpdateWithWhereUniqueWithoutProductInput | VariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VariantUpdateManyWithWhereWithoutProductInput | VariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VariantScalarWhereInput | VariantScalarWhereInput[]
  }

  export type VariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    upsert?: VariantUpsertWithWhereUniqueWithoutProductInput | VariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    set?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    disconnect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    delete?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    update?: VariantUpdateWithWhereUniqueWithoutProductInput | VariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VariantUpdateManyWithWhereWithoutProductInput | VariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VariantScalarWhereInput | VariantScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type MachineCreateNestedManyWithoutLocationInput = {
    create?: XOR<MachineCreateWithoutLocationInput, MachineUncheckedCreateWithoutLocationInput> | MachineCreateWithoutLocationInput[] | MachineUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutLocationInput | MachineCreateOrConnectWithoutLocationInput[]
    createMany?: MachineCreateManyLocationInputEnvelope
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
  }

  export type MachineUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<MachineCreateWithoutLocationInput, MachineUncheckedCreateWithoutLocationInput> | MachineCreateWithoutLocationInput[] | MachineUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutLocationInput | MachineCreateOrConnectWithoutLocationInput[]
    createMany?: MachineCreateManyLocationInputEnvelope
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
  }

  export type MachineUpdateManyWithoutLocationNestedInput = {
    create?: XOR<MachineCreateWithoutLocationInput, MachineUncheckedCreateWithoutLocationInput> | MachineCreateWithoutLocationInput[] | MachineUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutLocationInput | MachineCreateOrConnectWithoutLocationInput[]
    upsert?: MachineUpsertWithWhereUniqueWithoutLocationInput | MachineUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: MachineCreateManyLocationInputEnvelope
    set?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    disconnect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    delete?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    update?: MachineUpdateWithWhereUniqueWithoutLocationInput | MachineUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: MachineUpdateManyWithWhereWithoutLocationInput | MachineUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: MachineScalarWhereInput | MachineScalarWhereInput[]
  }

  export type MachineUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<MachineCreateWithoutLocationInput, MachineUncheckedCreateWithoutLocationInput> | MachineCreateWithoutLocationInput[] | MachineUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: MachineCreateOrConnectWithoutLocationInput | MachineCreateOrConnectWithoutLocationInput[]
    upsert?: MachineUpsertWithWhereUniqueWithoutLocationInput | MachineUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: MachineCreateManyLocationInputEnvelope
    set?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    disconnect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    delete?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    connect?: MachineWhereUniqueInput | MachineWhereUniqueInput[]
    update?: MachineUpdateWithWhereUniqueWithoutLocationInput | MachineUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: MachineUpdateManyWithWhereWithoutLocationInput | MachineUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: MachineScalarWhereInput | MachineScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutMachinesInput = {
    create?: XOR<LocationCreateWithoutMachinesInput, LocationUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutMachinesInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationUpdateOneWithoutMachinesNestedInput = {
    create?: XOR<LocationCreateWithoutMachinesInput, LocationUncheckedCreateWithoutMachinesInput>
    connectOrCreate?: LocationCreateOrConnectWithoutMachinesInput
    upsert?: LocationUpsertWithoutMachinesInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutMachinesInput, LocationUpdateWithoutMachinesInput>, LocationUncheckedUpdateWithoutMachinesInput>
  }

  export type AccountCreateNestedOneWithoutChildrenInput = {
    create?: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildrenInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type JournalLineCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutAccountInput = {
    create?: XOR<PurchaseOrderCreateWithoutAccountInput, PurchaseOrderUncheckedCreateWithoutAccountInput> | PurchaseOrderCreateWithoutAccountInput[] | PurchaseOrderUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutAccountInput | PurchaseOrderCreateOrConnectWithoutAccountInput[]
    createMany?: PurchaseOrderCreateManyAccountInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseInvoiceCreateNestedManyWithoutAccountInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutAccountInput, PurchaseInvoiceUncheckedCreateWithoutAccountInput> | PurchaseInvoiceCreateWithoutAccountInput[] | PurchaseInvoiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutAccountInput | PurchaseInvoiceCreateOrConnectWithoutAccountInput[]
    createMany?: PurchaseInvoiceCreateManyAccountInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type PurchaseReturnCreateNestedManyWithoutAccountInput = {
    create?: XOR<PurchaseReturnCreateWithoutAccountInput, PurchaseReturnUncheckedCreateWithoutAccountInput> | PurchaseReturnCreateWithoutAccountInput[] | PurchaseReturnUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutAccountInput | PurchaseReturnCreateOrConnectWithoutAccountInput[]
    createMany?: PurchaseReturnCreateManyAccountInputEnvelope
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PurchaseOrderCreateWithoutAccountInput, PurchaseOrderUncheckedCreateWithoutAccountInput> | PurchaseOrderCreateWithoutAccountInput[] | PurchaseOrderUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutAccountInput | PurchaseOrderCreateOrConnectWithoutAccountInput[]
    createMany?: PurchaseOrderCreateManyAccountInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseInvoiceUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutAccountInput, PurchaseInvoiceUncheckedCreateWithoutAccountInput> | PurchaseInvoiceCreateWithoutAccountInput[] | PurchaseInvoiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutAccountInput | PurchaseInvoiceCreateOrConnectWithoutAccountInput[]
    createMany?: PurchaseInvoiceCreateManyAccountInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type PurchaseReturnUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PurchaseReturnCreateWithoutAccountInput, PurchaseReturnUncheckedCreateWithoutAccountInput> | PurchaseReturnCreateWithoutAccountInput[] | PurchaseReturnUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutAccountInput | PurchaseReturnCreateOrConnectWithoutAccountInput[]
    createMany?: PurchaseReturnCreateManyAccountInputEnvelope
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type EnumBalanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.BalanceType
  }

  export type AccountUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AccountCreateOrConnectWithoutChildrenInput
    upsert?: AccountUpsertWithoutChildrenInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutChildrenInput, AccountUpdateWithoutChildrenInput>, AccountUncheckedUpdateWithoutChildrenInput>
  }

  export type AccountUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentInput | AccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentInput | AccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentInput | AccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type JournalLineUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAccountInput | JournalLineUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAccountInput | JournalLineUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAccountInput | JournalLineUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutAccountInput, PurchaseOrderUncheckedCreateWithoutAccountInput> | PurchaseOrderCreateWithoutAccountInput[] | PurchaseOrderUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutAccountInput | PurchaseOrderCreateOrConnectWithoutAccountInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutAccountInput | PurchaseOrderUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PurchaseOrderCreateManyAccountInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutAccountInput | PurchaseOrderUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutAccountInput | PurchaseOrderUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseInvoiceUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutAccountInput, PurchaseInvoiceUncheckedCreateWithoutAccountInput> | PurchaseInvoiceCreateWithoutAccountInput[] | PurchaseInvoiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutAccountInput | PurchaseInvoiceCreateOrConnectWithoutAccountInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutAccountInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PurchaseInvoiceCreateManyAccountInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutAccountInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutAccountInput | PurchaseInvoiceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PurchaseReturnUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PurchaseReturnCreateWithoutAccountInput, PurchaseReturnUncheckedCreateWithoutAccountInput> | PurchaseReturnCreateWithoutAccountInput[] | PurchaseReturnUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutAccountInput | PurchaseReturnCreateOrConnectWithoutAccountInput[]
    upsert?: PurchaseReturnUpsertWithWhereUniqueWithoutAccountInput | PurchaseReturnUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PurchaseReturnCreateManyAccountInputEnvelope
    set?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    disconnect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    delete?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    update?: PurchaseReturnUpdateWithWhereUniqueWithoutAccountInput | PurchaseReturnUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PurchaseReturnUpdateManyWithWhereWithoutAccountInput | PurchaseReturnUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput> | AccountCreateWithoutParentInput[] | AccountUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutParentInput | AccountCreateOrConnectWithoutParentInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutParentInput | AccountUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AccountCreateManyParentInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutParentInput | AccountUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutParentInput | AccountUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput> | JournalLineCreateWithoutAccountInput[] | JournalLineUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutAccountInput | JournalLineCreateOrConnectWithoutAccountInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutAccountInput | JournalLineUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: JournalLineCreateManyAccountInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutAccountInput | JournalLineUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutAccountInput | JournalLineUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutAccountInput, PurchaseOrderUncheckedCreateWithoutAccountInput> | PurchaseOrderCreateWithoutAccountInput[] | PurchaseOrderUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutAccountInput | PurchaseOrderCreateOrConnectWithoutAccountInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutAccountInput | PurchaseOrderUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PurchaseOrderCreateManyAccountInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutAccountInput | PurchaseOrderUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutAccountInput | PurchaseOrderUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutAccountInput, PurchaseInvoiceUncheckedCreateWithoutAccountInput> | PurchaseInvoiceCreateWithoutAccountInput[] | PurchaseInvoiceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutAccountInput | PurchaseInvoiceCreateOrConnectWithoutAccountInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutAccountInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PurchaseInvoiceCreateManyAccountInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutAccountInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutAccountInput | PurchaseInvoiceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PurchaseReturnUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PurchaseReturnCreateWithoutAccountInput, PurchaseReturnUncheckedCreateWithoutAccountInput> | PurchaseReturnCreateWithoutAccountInput[] | PurchaseReturnUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutAccountInput | PurchaseReturnCreateOrConnectWithoutAccountInput[]
    upsert?: PurchaseReturnUpsertWithWhereUniqueWithoutAccountInput | PurchaseReturnUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PurchaseReturnCreateManyAccountInputEnvelope
    set?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    disconnect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    delete?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    update?: PurchaseReturnUpdateWithWhereUniqueWithoutAccountInput | PurchaseReturnUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PurchaseReturnUpdateManyWithWhereWithoutAccountInput | PurchaseReturnUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
  }

  export type FiscalYearCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<FiscalYearCreateWithoutJournalEntriesInput, FiscalYearUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: FiscalYearCreateOrConnectWithoutJournalEntriesInput
    connect?: FiscalYearWhereUniqueInput
  }

  export type JournalLineCreateNestedManyWithoutEntryInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type JournalLineUncheckedCreateNestedManyWithoutEntryInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
  }

  export type EnumVoucherTypeFieldUpdateOperationsInput = {
    set?: $Enums.VoucherType
  }

  export type FiscalYearUpdateOneWithoutJournalEntriesNestedInput = {
    create?: XOR<FiscalYearCreateWithoutJournalEntriesInput, FiscalYearUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: FiscalYearCreateOrConnectWithoutJournalEntriesInput
    upsert?: FiscalYearUpsertWithoutJournalEntriesInput
    disconnect?: FiscalYearWhereInput | boolean
    delete?: FiscalYearWhereInput | boolean
    connect?: FiscalYearWhereUniqueInput
    update?: XOR<XOR<FiscalYearUpdateToOneWithWhereWithoutJournalEntriesInput, FiscalYearUpdateWithoutJournalEntriesInput>, FiscalYearUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type JournalLineUpdateManyWithoutEntryNestedInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutEntryInput | JournalLineUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutEntryInput | JournalLineUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutEntryInput | JournalLineUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type JournalLineUncheckedUpdateManyWithoutEntryNestedInput = {
    create?: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput> | JournalLineCreateWithoutEntryInput[] | JournalLineUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: JournalLineCreateOrConnectWithoutEntryInput | JournalLineCreateOrConnectWithoutEntryInput[]
    upsert?: JournalLineUpsertWithWhereUniqueWithoutEntryInput | JournalLineUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: JournalLineCreateManyEntryInputEnvelope
    set?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    disconnect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    delete?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    connect?: JournalLineWhereUniqueInput | JournalLineWhereUniqueInput[]
    update?: JournalLineUpdateWithWhereUniqueWithoutEntryInput | JournalLineUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: JournalLineUpdateManyWithWhereWithoutEntryInput | JournalLineUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutJournalLinesInput = {
    create?: XOR<AccountCreateWithoutJournalLinesInput, AccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutJournalLinesInput
    connect?: AccountWhereUniqueInput
  }

  export type JournalEntryCreateNestedOneWithoutLinesInput = {
    create?: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutLinesInput
    connect?: JournalEntryWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutJournalLinesNestedInput = {
    create?: XOR<AccountCreateWithoutJournalLinesInput, AccountUncheckedCreateWithoutJournalLinesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutJournalLinesInput
    upsert?: AccountUpsertWithoutJournalLinesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutJournalLinesInput, AccountUpdateWithoutJournalLinesInput>, AccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type JournalEntryUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    connectOrCreate?: JournalEntryCreateOrConnectWithoutLinesInput
    upsert?: JournalEntryUpsertWithoutLinesInput
    connect?: JournalEntryWhereUniqueInput
    update?: XOR<XOR<JournalEntryUpdateToOneWithWhereWithoutLinesInput, JournalEntryUpdateWithoutLinesInput>, JournalEntryUncheckedUpdateWithoutLinesInput>
  }

  export type ItemGroupCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ItemGroupCreateWithoutChildrenInput, ItemGroupUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ItemGroupCreateOrConnectWithoutChildrenInput
    connect?: ItemGroupWhereUniqueInput
  }

  export type ItemGroupCreateNestedManyWithoutParentInput = {
    create?: XOR<ItemGroupCreateWithoutParentInput, ItemGroupUncheckedCreateWithoutParentInput> | ItemGroupCreateWithoutParentInput[] | ItemGroupUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemGroupCreateOrConnectWithoutParentInput | ItemGroupCreateOrConnectWithoutParentInput[]
    createMany?: ItemGroupCreateManyParentInputEnvelope
    connect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutItemGroupsInput = {
    create?: XOR<CompanyCreateWithoutItemGroupsInput, CompanyUncheckedCreateWithoutItemGroupsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutItemGroupsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ItemMasterCreateNestedManyWithoutItemGroupInput = {
    create?: XOR<ItemMasterCreateWithoutItemGroupInput, ItemMasterUncheckedCreateWithoutItemGroupInput> | ItemMasterCreateWithoutItemGroupInput[] | ItemMasterUncheckedCreateWithoutItemGroupInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutItemGroupInput | ItemMasterCreateOrConnectWithoutItemGroupInput[]
    createMany?: ItemMasterCreateManyItemGroupInputEnvelope
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
  }

  export type ItemGroupUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<ItemGroupCreateWithoutParentInput, ItemGroupUncheckedCreateWithoutParentInput> | ItemGroupCreateWithoutParentInput[] | ItemGroupUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemGroupCreateOrConnectWithoutParentInput | ItemGroupCreateOrConnectWithoutParentInput[]
    createMany?: ItemGroupCreateManyParentInputEnvelope
    connect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
  }

  export type ItemMasterUncheckedCreateNestedManyWithoutItemGroupInput = {
    create?: XOR<ItemMasterCreateWithoutItemGroupInput, ItemMasterUncheckedCreateWithoutItemGroupInput> | ItemMasterCreateWithoutItemGroupInput[] | ItemMasterUncheckedCreateWithoutItemGroupInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutItemGroupInput | ItemMasterCreateOrConnectWithoutItemGroupInput[]
    createMany?: ItemMasterCreateManyItemGroupInputEnvelope
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
  }

  export type ItemGroupUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<ItemGroupCreateWithoutChildrenInput, ItemGroupUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ItemGroupCreateOrConnectWithoutChildrenInput
    upsert?: ItemGroupUpsertWithoutChildrenInput
    disconnect?: ItemGroupWhereInput | boolean
    delete?: ItemGroupWhereInput | boolean
    connect?: ItemGroupWhereUniqueInput
    update?: XOR<XOR<ItemGroupUpdateToOneWithWhereWithoutChildrenInput, ItemGroupUpdateWithoutChildrenInput>, ItemGroupUncheckedUpdateWithoutChildrenInput>
  }

  export type ItemGroupUpdateManyWithoutParentNestedInput = {
    create?: XOR<ItemGroupCreateWithoutParentInput, ItemGroupUncheckedCreateWithoutParentInput> | ItemGroupCreateWithoutParentInput[] | ItemGroupUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemGroupCreateOrConnectWithoutParentInput | ItemGroupCreateOrConnectWithoutParentInput[]
    upsert?: ItemGroupUpsertWithWhereUniqueWithoutParentInput | ItemGroupUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ItemGroupCreateManyParentInputEnvelope
    set?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    disconnect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    delete?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    connect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    update?: ItemGroupUpdateWithWhereUniqueWithoutParentInput | ItemGroupUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ItemGroupUpdateManyWithWhereWithoutParentInput | ItemGroupUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ItemGroupScalarWhereInput | ItemGroupScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutItemGroupsNestedInput = {
    create?: XOR<CompanyCreateWithoutItemGroupsInput, CompanyUncheckedCreateWithoutItemGroupsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutItemGroupsInput
    upsert?: CompanyUpsertWithoutItemGroupsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutItemGroupsInput, CompanyUpdateWithoutItemGroupsInput>, CompanyUncheckedUpdateWithoutItemGroupsInput>
  }

  export type ItemMasterUpdateManyWithoutItemGroupNestedInput = {
    create?: XOR<ItemMasterCreateWithoutItemGroupInput, ItemMasterUncheckedCreateWithoutItemGroupInput> | ItemMasterCreateWithoutItemGroupInput[] | ItemMasterUncheckedCreateWithoutItemGroupInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutItemGroupInput | ItemMasterCreateOrConnectWithoutItemGroupInput[]
    upsert?: ItemMasterUpsertWithWhereUniqueWithoutItemGroupInput | ItemMasterUpsertWithWhereUniqueWithoutItemGroupInput[]
    createMany?: ItemMasterCreateManyItemGroupInputEnvelope
    set?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    disconnect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    delete?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    update?: ItemMasterUpdateWithWhereUniqueWithoutItemGroupInput | ItemMasterUpdateWithWhereUniqueWithoutItemGroupInput[]
    updateMany?: ItemMasterUpdateManyWithWhereWithoutItemGroupInput | ItemMasterUpdateManyWithWhereWithoutItemGroupInput[]
    deleteMany?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
  }

  export type ItemGroupUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<ItemGroupCreateWithoutParentInput, ItemGroupUncheckedCreateWithoutParentInput> | ItemGroupCreateWithoutParentInput[] | ItemGroupUncheckedCreateWithoutParentInput[]
    connectOrCreate?: ItemGroupCreateOrConnectWithoutParentInput | ItemGroupCreateOrConnectWithoutParentInput[]
    upsert?: ItemGroupUpsertWithWhereUniqueWithoutParentInput | ItemGroupUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: ItemGroupCreateManyParentInputEnvelope
    set?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    disconnect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    delete?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    connect?: ItemGroupWhereUniqueInput | ItemGroupWhereUniqueInput[]
    update?: ItemGroupUpdateWithWhereUniqueWithoutParentInput | ItemGroupUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: ItemGroupUpdateManyWithWhereWithoutParentInput | ItemGroupUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: ItemGroupScalarWhereInput | ItemGroupScalarWhereInput[]
  }

  export type ItemMasterUncheckedUpdateManyWithoutItemGroupNestedInput = {
    create?: XOR<ItemMasterCreateWithoutItemGroupInput, ItemMasterUncheckedCreateWithoutItemGroupInput> | ItemMasterCreateWithoutItemGroupInput[] | ItemMasterUncheckedCreateWithoutItemGroupInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutItemGroupInput | ItemMasterCreateOrConnectWithoutItemGroupInput[]
    upsert?: ItemMasterUpsertWithWhereUniqueWithoutItemGroupInput | ItemMasterUpsertWithWhereUniqueWithoutItemGroupInput[]
    createMany?: ItemMasterCreateManyItemGroupInputEnvelope
    set?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    disconnect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    delete?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    update?: ItemMasterUpdateWithWhereUniqueWithoutItemGroupInput | ItemMasterUpdateWithWhereUniqueWithoutItemGroupInput[]
    updateMany?: ItemMasterUpdateManyWithWhereWithoutItemGroupInput | ItemMasterUpdateManyWithWhereWithoutItemGroupInput[]
    deleteMany?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutColorsInput = {
    create?: XOR<CompanyCreateWithoutColorsInput, CompanyUncheckedCreateWithoutColorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutColorsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutColorInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutColorInput, PurchaseOrderItemUncheckedCreateWithoutColorInput> | PurchaseOrderItemCreateWithoutColorInput[] | PurchaseOrderItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutColorInput | PurchaseOrderItemCreateOrConnectWithoutColorInput[]
    createMany?: PurchaseOrderItemCreateManyColorInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemCreateNestedManyWithoutColorInput = {
    create?: XOR<GRNItemCreateWithoutColorInput, GRNItemUncheckedCreateWithoutColorInput> | GRNItemCreateWithoutColorInput[] | GRNItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutColorInput | GRNItemCreateOrConnectWithoutColorInput[]
    createMany?: GRNItemCreateManyColorInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutColorInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutColorInput, PurchaseInvoiceItemUncheckedCreateWithoutColorInput> | PurchaseInvoiceItemCreateWithoutColorInput[] | PurchaseInvoiceItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutColorInput | PurchaseInvoiceItemCreateOrConnectWithoutColorInput[]
    createMany?: PurchaseInvoiceItemCreateManyColorInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemCreateNestedManyWithoutColorInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutColorInput, PurchaseReturnItemUncheckedCreateWithoutColorInput> | PurchaseReturnItemCreateWithoutColorInput[] | PurchaseReturnItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutColorInput | PurchaseReturnItemCreateOrConnectWithoutColorInput[]
    createMany?: PurchaseReturnItemCreateManyColorInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutColorInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutColorInput, PurchaseOrderItemUncheckedCreateWithoutColorInput> | PurchaseOrderItemCreateWithoutColorInput[] | PurchaseOrderItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutColorInput | PurchaseOrderItemCreateOrConnectWithoutColorInput[]
    createMany?: PurchaseOrderItemCreateManyColorInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemUncheckedCreateNestedManyWithoutColorInput = {
    create?: XOR<GRNItemCreateWithoutColorInput, GRNItemUncheckedCreateWithoutColorInput> | GRNItemCreateWithoutColorInput[] | GRNItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutColorInput | GRNItemCreateOrConnectWithoutColorInput[]
    createMany?: GRNItemCreateManyColorInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutColorInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutColorInput, PurchaseInvoiceItemUncheckedCreateWithoutColorInput> | PurchaseInvoiceItemCreateWithoutColorInput[] | PurchaseInvoiceItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutColorInput | PurchaseInvoiceItemCreateOrConnectWithoutColorInput[]
    createMany?: PurchaseInvoiceItemCreateManyColorInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemUncheckedCreateNestedManyWithoutColorInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutColorInput, PurchaseReturnItemUncheckedCreateWithoutColorInput> | PurchaseReturnItemCreateWithoutColorInput[] | PurchaseReturnItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutColorInput | PurchaseReturnItemCreateOrConnectWithoutColorInput[]
    createMany?: PurchaseReturnItemCreateManyColorInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutColorsNestedInput = {
    create?: XOR<CompanyCreateWithoutColorsInput, CompanyUncheckedCreateWithoutColorsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutColorsInput
    upsert?: CompanyUpsertWithoutColorsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutColorsInput, CompanyUpdateWithoutColorsInput>, CompanyUncheckedUpdateWithoutColorsInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutColorNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutColorInput, PurchaseOrderItemUncheckedCreateWithoutColorInput> | PurchaseOrderItemCreateWithoutColorInput[] | PurchaseOrderItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutColorInput | PurchaseOrderItemCreateOrConnectWithoutColorInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutColorInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: PurchaseOrderItemCreateManyColorInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutColorInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutColorInput | PurchaseOrderItemUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUpdateManyWithoutColorNestedInput = {
    create?: XOR<GRNItemCreateWithoutColorInput, GRNItemUncheckedCreateWithoutColorInput> | GRNItemCreateWithoutColorInput[] | GRNItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutColorInput | GRNItemCreateOrConnectWithoutColorInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutColorInput | GRNItemUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: GRNItemCreateManyColorInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutColorInput | GRNItemUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutColorInput | GRNItemUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUpdateManyWithoutColorNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutColorInput, PurchaseInvoiceItemUncheckedCreateWithoutColorInput> | PurchaseInvoiceItemCreateWithoutColorInput[] | PurchaseInvoiceItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutColorInput | PurchaseInvoiceItemCreateOrConnectWithoutColorInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutColorInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: PurchaseInvoiceItemCreateManyColorInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutColorInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutColorInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUpdateManyWithoutColorNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutColorInput, PurchaseReturnItemUncheckedCreateWithoutColorInput> | PurchaseReturnItemCreateWithoutColorInput[] | PurchaseReturnItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutColorInput | PurchaseReturnItemCreateOrConnectWithoutColorInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutColorInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: PurchaseReturnItemCreateManyColorInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutColorInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutColorInput | PurchaseReturnItemUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutColorNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutColorInput, PurchaseOrderItemUncheckedCreateWithoutColorInput> | PurchaseOrderItemCreateWithoutColorInput[] | PurchaseOrderItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutColorInput | PurchaseOrderItemCreateOrConnectWithoutColorInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutColorInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: PurchaseOrderItemCreateManyColorInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutColorInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutColorInput | PurchaseOrderItemUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUncheckedUpdateManyWithoutColorNestedInput = {
    create?: XOR<GRNItemCreateWithoutColorInput, GRNItemUncheckedCreateWithoutColorInput> | GRNItemCreateWithoutColorInput[] | GRNItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutColorInput | GRNItemCreateOrConnectWithoutColorInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutColorInput | GRNItemUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: GRNItemCreateManyColorInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutColorInput | GRNItemUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutColorInput | GRNItemUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutColorNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutColorInput, PurchaseInvoiceItemUncheckedCreateWithoutColorInput> | PurchaseInvoiceItemCreateWithoutColorInput[] | PurchaseInvoiceItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutColorInput | PurchaseInvoiceItemCreateOrConnectWithoutColorInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutColorInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: PurchaseInvoiceItemCreateManyColorInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutColorInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutColorInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutColorNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutColorInput, PurchaseReturnItemUncheckedCreateWithoutColorInput> | PurchaseReturnItemCreateWithoutColorInput[] | PurchaseReturnItemUncheckedCreateWithoutColorInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutColorInput | PurchaseReturnItemCreateOrConnectWithoutColorInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutColorInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: PurchaseReturnItemCreateManyColorInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutColorInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutColorInput | PurchaseReturnItemUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutBrandsInput = {
    create?: XOR<CompanyCreateWithoutBrandsInput, CompanyUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBrandsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutBrandInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutBrandInput, PurchaseOrderItemUncheckedCreateWithoutBrandInput> | PurchaseOrderItemCreateWithoutBrandInput[] | PurchaseOrderItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutBrandInput | PurchaseOrderItemCreateOrConnectWithoutBrandInput[]
    createMany?: PurchaseOrderItemCreateManyBrandInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemCreateNestedManyWithoutBrandInput = {
    create?: XOR<GRNItemCreateWithoutBrandInput, GRNItemUncheckedCreateWithoutBrandInput> | GRNItemCreateWithoutBrandInput[] | GRNItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutBrandInput | GRNItemCreateOrConnectWithoutBrandInput[]
    createMany?: GRNItemCreateManyBrandInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutBrandInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutBrandInput, PurchaseInvoiceItemUncheckedCreateWithoutBrandInput> | PurchaseInvoiceItemCreateWithoutBrandInput[] | PurchaseInvoiceItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutBrandInput | PurchaseInvoiceItemCreateOrConnectWithoutBrandInput[]
    createMany?: PurchaseInvoiceItemCreateManyBrandInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemCreateNestedManyWithoutBrandInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutBrandInput, PurchaseReturnItemUncheckedCreateWithoutBrandInput> | PurchaseReturnItemCreateWithoutBrandInput[] | PurchaseReturnItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutBrandInput | PurchaseReturnItemCreateOrConnectWithoutBrandInput[]
    createMany?: PurchaseReturnItemCreateManyBrandInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutBrandInput, PurchaseOrderItemUncheckedCreateWithoutBrandInput> | PurchaseOrderItemCreateWithoutBrandInput[] | PurchaseOrderItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutBrandInput | PurchaseOrderItemCreateOrConnectWithoutBrandInput[]
    createMany?: PurchaseOrderItemCreateManyBrandInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<GRNItemCreateWithoutBrandInput, GRNItemUncheckedCreateWithoutBrandInput> | GRNItemCreateWithoutBrandInput[] | GRNItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutBrandInput | GRNItemCreateOrConnectWithoutBrandInput[]
    createMany?: GRNItemCreateManyBrandInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutBrandInput, PurchaseInvoiceItemUncheckedCreateWithoutBrandInput> | PurchaseInvoiceItemCreateWithoutBrandInput[] | PurchaseInvoiceItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutBrandInput | PurchaseInvoiceItemCreateOrConnectWithoutBrandInput[]
    createMany?: PurchaseInvoiceItemCreateManyBrandInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutBrandInput, PurchaseReturnItemUncheckedCreateWithoutBrandInput> | PurchaseReturnItemCreateWithoutBrandInput[] | PurchaseReturnItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutBrandInput | PurchaseReturnItemCreateOrConnectWithoutBrandInput[]
    createMany?: PurchaseReturnItemCreateManyBrandInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutBrandsNestedInput = {
    create?: XOR<CompanyCreateWithoutBrandsInput, CompanyUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBrandsInput
    upsert?: CompanyUpsertWithoutBrandsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBrandsInput, CompanyUpdateWithoutBrandsInput>, CompanyUncheckedUpdateWithoutBrandsInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutBrandNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutBrandInput, PurchaseOrderItemUncheckedCreateWithoutBrandInput> | PurchaseOrderItemCreateWithoutBrandInput[] | PurchaseOrderItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutBrandInput | PurchaseOrderItemCreateOrConnectWithoutBrandInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutBrandInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: PurchaseOrderItemCreateManyBrandInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutBrandInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutBrandInput | PurchaseOrderItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUpdateManyWithoutBrandNestedInput = {
    create?: XOR<GRNItemCreateWithoutBrandInput, GRNItemUncheckedCreateWithoutBrandInput> | GRNItemCreateWithoutBrandInput[] | GRNItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutBrandInput | GRNItemCreateOrConnectWithoutBrandInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutBrandInput | GRNItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: GRNItemCreateManyBrandInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutBrandInput | GRNItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutBrandInput | GRNItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUpdateManyWithoutBrandNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutBrandInput, PurchaseInvoiceItemUncheckedCreateWithoutBrandInput> | PurchaseInvoiceItemCreateWithoutBrandInput[] | PurchaseInvoiceItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutBrandInput | PurchaseInvoiceItemCreateOrConnectWithoutBrandInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutBrandInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: PurchaseInvoiceItemCreateManyBrandInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutBrandInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutBrandInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUpdateManyWithoutBrandNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutBrandInput, PurchaseReturnItemUncheckedCreateWithoutBrandInput> | PurchaseReturnItemCreateWithoutBrandInput[] | PurchaseReturnItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutBrandInput | PurchaseReturnItemCreateOrConnectWithoutBrandInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutBrandInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: PurchaseReturnItemCreateManyBrandInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutBrandInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutBrandInput | PurchaseReturnItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutBrandInput, PurchaseOrderItemUncheckedCreateWithoutBrandInput> | PurchaseOrderItemCreateWithoutBrandInput[] | PurchaseOrderItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutBrandInput | PurchaseOrderItemCreateOrConnectWithoutBrandInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutBrandInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: PurchaseOrderItemCreateManyBrandInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutBrandInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutBrandInput | PurchaseOrderItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<GRNItemCreateWithoutBrandInput, GRNItemUncheckedCreateWithoutBrandInput> | GRNItemCreateWithoutBrandInput[] | GRNItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutBrandInput | GRNItemCreateOrConnectWithoutBrandInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutBrandInput | GRNItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: GRNItemCreateManyBrandInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutBrandInput | GRNItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutBrandInput | GRNItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutBrandInput, PurchaseInvoiceItemUncheckedCreateWithoutBrandInput> | PurchaseInvoiceItemCreateWithoutBrandInput[] | PurchaseInvoiceItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutBrandInput | PurchaseInvoiceItemCreateOrConnectWithoutBrandInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutBrandInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: PurchaseInvoiceItemCreateManyBrandInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutBrandInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutBrandInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutBrandInput, PurchaseReturnItemUncheckedCreateWithoutBrandInput> | PurchaseReturnItemCreateWithoutBrandInput[] | PurchaseReturnItemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutBrandInput | PurchaseReturnItemCreateOrConnectWithoutBrandInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutBrandInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: PurchaseReturnItemCreateManyBrandInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutBrandInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutBrandInput | PurchaseReturnItemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutItemGradesInput = {
    create?: XOR<CompanyCreateWithoutItemGradesInput, CompanyUncheckedCreateWithoutItemGradesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutItemGradesInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutItemGradeInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutItemGradeInput, PurchaseOrderItemUncheckedCreateWithoutItemGradeInput> | PurchaseOrderItemCreateWithoutItemGradeInput[] | PurchaseOrderItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutItemGradeInput | PurchaseOrderItemCreateOrConnectWithoutItemGradeInput[]
    createMany?: PurchaseOrderItemCreateManyItemGradeInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemCreateNestedManyWithoutItemGradeInput = {
    create?: XOR<GRNItemCreateWithoutItemGradeInput, GRNItemUncheckedCreateWithoutItemGradeInput> | GRNItemCreateWithoutItemGradeInput[] | GRNItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutItemGradeInput | GRNItemCreateOrConnectWithoutItemGradeInput[]
    createMany?: GRNItemCreateManyItemGradeInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutItemGradeInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemGradeInput, PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput> | PurchaseInvoiceItemCreateWithoutItemGradeInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemGradeInput | PurchaseInvoiceItemCreateOrConnectWithoutItemGradeInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemGradeInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemCreateNestedManyWithoutItemGradeInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutItemGradeInput, PurchaseReturnItemUncheckedCreateWithoutItemGradeInput> | PurchaseReturnItemCreateWithoutItemGradeInput[] | PurchaseReturnItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutItemGradeInput | PurchaseReturnItemCreateOrConnectWithoutItemGradeInput[]
    createMany?: PurchaseReturnItemCreateManyItemGradeInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutItemGradeInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutItemGradeInput, PurchaseOrderItemUncheckedCreateWithoutItemGradeInput> | PurchaseOrderItemCreateWithoutItemGradeInput[] | PurchaseOrderItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutItemGradeInput | PurchaseOrderItemCreateOrConnectWithoutItemGradeInput[]
    createMany?: PurchaseOrderItemCreateManyItemGradeInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemUncheckedCreateNestedManyWithoutItemGradeInput = {
    create?: XOR<GRNItemCreateWithoutItemGradeInput, GRNItemUncheckedCreateWithoutItemGradeInput> | GRNItemCreateWithoutItemGradeInput[] | GRNItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutItemGradeInput | GRNItemCreateOrConnectWithoutItemGradeInput[]
    createMany?: GRNItemCreateManyItemGradeInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemGradeInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemGradeInput, PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput> | PurchaseInvoiceItemCreateWithoutItemGradeInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemGradeInput | PurchaseInvoiceItemCreateOrConnectWithoutItemGradeInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemGradeInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemUncheckedCreateNestedManyWithoutItemGradeInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutItemGradeInput, PurchaseReturnItemUncheckedCreateWithoutItemGradeInput> | PurchaseReturnItemCreateWithoutItemGradeInput[] | PurchaseReturnItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutItemGradeInput | PurchaseReturnItemCreateOrConnectWithoutItemGradeInput[]
    createMany?: PurchaseReturnItemCreateManyItemGradeInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutItemGradesNestedInput = {
    create?: XOR<CompanyCreateWithoutItemGradesInput, CompanyUncheckedCreateWithoutItemGradesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutItemGradesInput
    upsert?: CompanyUpsertWithoutItemGradesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutItemGradesInput, CompanyUpdateWithoutItemGradesInput>, CompanyUncheckedUpdateWithoutItemGradesInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutItemGradeNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutItemGradeInput, PurchaseOrderItemUncheckedCreateWithoutItemGradeInput> | PurchaseOrderItemCreateWithoutItemGradeInput[] | PurchaseOrderItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutItemGradeInput | PurchaseOrderItemCreateOrConnectWithoutItemGradeInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutItemGradeInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutItemGradeInput[]
    createMany?: PurchaseOrderItemCreateManyItemGradeInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutItemGradeInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutItemGradeInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutItemGradeInput | PurchaseOrderItemUpdateManyWithWhereWithoutItemGradeInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUpdateManyWithoutItemGradeNestedInput = {
    create?: XOR<GRNItemCreateWithoutItemGradeInput, GRNItemUncheckedCreateWithoutItemGradeInput> | GRNItemCreateWithoutItemGradeInput[] | GRNItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutItemGradeInput | GRNItemCreateOrConnectWithoutItemGradeInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutItemGradeInput | GRNItemUpsertWithWhereUniqueWithoutItemGradeInput[]
    createMany?: GRNItemCreateManyItemGradeInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutItemGradeInput | GRNItemUpdateWithWhereUniqueWithoutItemGradeInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutItemGradeInput | GRNItemUpdateManyWithWhereWithoutItemGradeInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUpdateManyWithoutItemGradeNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemGradeInput, PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput> | PurchaseInvoiceItemCreateWithoutItemGradeInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemGradeInput | PurchaseInvoiceItemCreateOrConnectWithoutItemGradeInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemGradeInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemGradeInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemGradeInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemGradeInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemGradeInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutItemGradeInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutItemGradeInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUpdateManyWithoutItemGradeNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutItemGradeInput, PurchaseReturnItemUncheckedCreateWithoutItemGradeInput> | PurchaseReturnItemCreateWithoutItemGradeInput[] | PurchaseReturnItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutItemGradeInput | PurchaseReturnItemCreateOrConnectWithoutItemGradeInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutItemGradeInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutItemGradeInput[]
    createMany?: PurchaseReturnItemCreateManyItemGradeInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutItemGradeInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutItemGradeInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutItemGradeInput | PurchaseReturnItemUpdateManyWithWhereWithoutItemGradeInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutItemGradeNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutItemGradeInput, PurchaseOrderItemUncheckedCreateWithoutItemGradeInput> | PurchaseOrderItemCreateWithoutItemGradeInput[] | PurchaseOrderItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutItemGradeInput | PurchaseOrderItemCreateOrConnectWithoutItemGradeInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutItemGradeInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutItemGradeInput[]
    createMany?: PurchaseOrderItemCreateManyItemGradeInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutItemGradeInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutItemGradeInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutItemGradeInput | PurchaseOrderItemUpdateManyWithWhereWithoutItemGradeInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUncheckedUpdateManyWithoutItemGradeNestedInput = {
    create?: XOR<GRNItemCreateWithoutItemGradeInput, GRNItemUncheckedCreateWithoutItemGradeInput> | GRNItemCreateWithoutItemGradeInput[] | GRNItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutItemGradeInput | GRNItemCreateOrConnectWithoutItemGradeInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutItemGradeInput | GRNItemUpsertWithWhereUniqueWithoutItemGradeInput[]
    createMany?: GRNItemCreateManyItemGradeInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutItemGradeInput | GRNItemUpdateWithWhereUniqueWithoutItemGradeInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutItemGradeInput | GRNItemUpdateManyWithWhereWithoutItemGradeInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutItemGradeNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemGradeInput, PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput> | PurchaseInvoiceItemCreateWithoutItemGradeInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemGradeInput | PurchaseInvoiceItemCreateOrConnectWithoutItemGradeInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemGradeInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemGradeInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemGradeInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemGradeInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemGradeInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutItemGradeInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutItemGradeInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutItemGradeNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutItemGradeInput, PurchaseReturnItemUncheckedCreateWithoutItemGradeInput> | PurchaseReturnItemCreateWithoutItemGradeInput[] | PurchaseReturnItemUncheckedCreateWithoutItemGradeInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutItemGradeInput | PurchaseReturnItemCreateOrConnectWithoutItemGradeInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutItemGradeInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutItemGradeInput[]
    createMany?: PurchaseReturnItemCreateManyItemGradeInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutItemGradeInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutItemGradeInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutItemGradeInput | PurchaseReturnItemUpdateManyWithWhereWithoutItemGradeInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutPackingUnitsInput = {
    create?: XOR<CompanyCreateWithoutPackingUnitsInput, CompanyUncheckedCreateWithoutPackingUnitsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPackingUnitsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ItemMasterCreateNestedManyWithoutPackingUnitInput = {
    create?: XOR<ItemMasterCreateWithoutPackingUnitInput, ItemMasterUncheckedCreateWithoutPackingUnitInput> | ItemMasterCreateWithoutPackingUnitInput[] | ItemMasterUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPackingUnitInput | ItemMasterCreateOrConnectWithoutPackingUnitInput[]
    createMany?: ItemMasterCreateManyPackingUnitInputEnvelope
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
  }

  export type PurchaseOrderItemCreateNestedManyWithoutPackingUnitInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPackingUnitInput, PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput> | PurchaseOrderItemCreateWithoutPackingUnitInput[] | PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPackingUnitInput | PurchaseOrderItemCreateOrConnectWithoutPackingUnitInput[]
    createMany?: PurchaseOrderItemCreateManyPackingUnitInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemCreateNestedManyWithoutPackingUnitInput = {
    create?: XOR<GRNItemCreateWithoutPackingUnitInput, GRNItemUncheckedCreateWithoutPackingUnitInput> | GRNItemCreateWithoutPackingUnitInput[] | GRNItemUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutPackingUnitInput | GRNItemCreateOrConnectWithoutPackingUnitInput[]
    createMany?: GRNItemCreateManyPackingUnitInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type ItemMasterUncheckedCreateNestedManyWithoutPackingUnitInput = {
    create?: XOR<ItemMasterCreateWithoutPackingUnitInput, ItemMasterUncheckedCreateWithoutPackingUnitInput> | ItemMasterCreateWithoutPackingUnitInput[] | ItemMasterUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPackingUnitInput | ItemMasterCreateOrConnectWithoutPackingUnitInput[]
    createMany?: ItemMasterCreateManyPackingUnitInputEnvelope
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutPackingUnitInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPackingUnitInput, PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput> | PurchaseOrderItemCreateWithoutPackingUnitInput[] | PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPackingUnitInput | PurchaseOrderItemCreateOrConnectWithoutPackingUnitInput[]
    createMany?: PurchaseOrderItemCreateManyPackingUnitInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemUncheckedCreateNestedManyWithoutPackingUnitInput = {
    create?: XOR<GRNItemCreateWithoutPackingUnitInput, GRNItemUncheckedCreateWithoutPackingUnitInput> | GRNItemCreateWithoutPackingUnitInput[] | GRNItemUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutPackingUnitInput | GRNItemCreateOrConnectWithoutPackingUnitInput[]
    createMany?: GRNItemCreateManyPackingUnitInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutPackingUnitsNestedInput = {
    create?: XOR<CompanyCreateWithoutPackingUnitsInput, CompanyUncheckedCreateWithoutPackingUnitsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPackingUnitsInput
    upsert?: CompanyUpsertWithoutPackingUnitsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPackingUnitsInput, CompanyUpdateWithoutPackingUnitsInput>, CompanyUncheckedUpdateWithoutPackingUnitsInput>
  }

  export type ItemMasterUpdateManyWithoutPackingUnitNestedInput = {
    create?: XOR<ItemMasterCreateWithoutPackingUnitInput, ItemMasterUncheckedCreateWithoutPackingUnitInput> | ItemMasterCreateWithoutPackingUnitInput[] | ItemMasterUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPackingUnitInput | ItemMasterCreateOrConnectWithoutPackingUnitInput[]
    upsert?: ItemMasterUpsertWithWhereUniqueWithoutPackingUnitInput | ItemMasterUpsertWithWhereUniqueWithoutPackingUnitInput[]
    createMany?: ItemMasterCreateManyPackingUnitInputEnvelope
    set?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    disconnect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    delete?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    update?: ItemMasterUpdateWithWhereUniqueWithoutPackingUnitInput | ItemMasterUpdateWithWhereUniqueWithoutPackingUnitInput[]
    updateMany?: ItemMasterUpdateManyWithWhereWithoutPackingUnitInput | ItemMasterUpdateManyWithWhereWithoutPackingUnitInput[]
    deleteMany?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
  }

  export type PurchaseOrderItemUpdateManyWithoutPackingUnitNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPackingUnitInput, PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput> | PurchaseOrderItemCreateWithoutPackingUnitInput[] | PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPackingUnitInput | PurchaseOrderItemCreateOrConnectWithoutPackingUnitInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPackingUnitInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPackingUnitInput[]
    createMany?: PurchaseOrderItemCreateManyPackingUnitInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPackingUnitInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPackingUnitInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPackingUnitInput | PurchaseOrderItemUpdateManyWithWhereWithoutPackingUnitInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUpdateManyWithoutPackingUnitNestedInput = {
    create?: XOR<GRNItemCreateWithoutPackingUnitInput, GRNItemUncheckedCreateWithoutPackingUnitInput> | GRNItemCreateWithoutPackingUnitInput[] | GRNItemUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutPackingUnitInput | GRNItemCreateOrConnectWithoutPackingUnitInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutPackingUnitInput | GRNItemUpsertWithWhereUniqueWithoutPackingUnitInput[]
    createMany?: GRNItemCreateManyPackingUnitInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutPackingUnitInput | GRNItemUpdateWithWhereUniqueWithoutPackingUnitInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutPackingUnitInput | GRNItemUpdateManyWithWhereWithoutPackingUnitInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type ItemMasterUncheckedUpdateManyWithoutPackingUnitNestedInput = {
    create?: XOR<ItemMasterCreateWithoutPackingUnitInput, ItemMasterUncheckedCreateWithoutPackingUnitInput> | ItemMasterCreateWithoutPackingUnitInput[] | ItemMasterUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPackingUnitInput | ItemMasterCreateOrConnectWithoutPackingUnitInput[]
    upsert?: ItemMasterUpsertWithWhereUniqueWithoutPackingUnitInput | ItemMasterUpsertWithWhereUniqueWithoutPackingUnitInput[]
    createMany?: ItemMasterCreateManyPackingUnitInputEnvelope
    set?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    disconnect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    delete?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    connect?: ItemMasterWhereUniqueInput | ItemMasterWhereUniqueInput[]
    update?: ItemMasterUpdateWithWhereUniqueWithoutPackingUnitInput | ItemMasterUpdateWithWhereUniqueWithoutPackingUnitInput[]
    updateMany?: ItemMasterUpdateManyWithWhereWithoutPackingUnitInput | ItemMasterUpdateManyWithWhereWithoutPackingUnitInput[]
    deleteMany?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPackingUnitNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPackingUnitInput, PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput> | PurchaseOrderItemCreateWithoutPackingUnitInput[] | PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPackingUnitInput | PurchaseOrderItemCreateOrConnectWithoutPackingUnitInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPackingUnitInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPackingUnitInput[]
    createMany?: PurchaseOrderItemCreateManyPackingUnitInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPackingUnitInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPackingUnitInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPackingUnitInput | PurchaseOrderItemUpdateManyWithWhereWithoutPackingUnitInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUncheckedUpdateManyWithoutPackingUnitNestedInput = {
    create?: XOR<GRNItemCreateWithoutPackingUnitInput, GRNItemUncheckedCreateWithoutPackingUnitInput> | GRNItemCreateWithoutPackingUnitInput[] | GRNItemUncheckedCreateWithoutPackingUnitInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutPackingUnitInput | GRNItemCreateOrConnectWithoutPackingUnitInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutPackingUnitInput | GRNItemUpsertWithWhereUniqueWithoutPackingUnitInput[]
    createMany?: GRNItemCreateManyPackingUnitInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutPackingUnitInput | GRNItemUpdateWithWhereUniqueWithoutPackingUnitInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutPackingUnitInput | GRNItemUpdateManyWithWhereWithoutPackingUnitInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type ItemGroupCreateNestedOneWithoutItemMastersInput = {
    create?: XOR<ItemGroupCreateWithoutItemMastersInput, ItemGroupUncheckedCreateWithoutItemMastersInput>
    connectOrCreate?: ItemGroupCreateOrConnectWithoutItemMastersInput
    connect?: ItemGroupWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutItemMastersInput = {
    create?: XOR<UnitCreateWithoutItemMastersInput, UnitUncheckedCreateWithoutItemMastersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemMastersInput
    connect?: UnitWhereUniqueInput
  }

  export type PackingUnitCreateNestedOneWithoutItemMastersInput = {
    create?: XOR<PackingUnitCreateWithoutItemMastersInput, PackingUnitUncheckedCreateWithoutItemMastersInput>
    connectOrCreate?: PackingUnitCreateOrConnectWithoutItemMastersInput
    connect?: PackingUnitWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutItemMastersInput = {
    create?: XOR<CompanyCreateWithoutItemMastersInput, CompanyUncheckedCreateWithoutItemMastersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutItemMastersInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutItemMasterInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutItemMasterInput, PurchaseOrderItemUncheckedCreateWithoutItemMasterInput> | PurchaseOrderItemCreateWithoutItemMasterInput[] | PurchaseOrderItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutItemMasterInput | PurchaseOrderItemCreateOrConnectWithoutItemMasterInput[]
    createMany?: PurchaseOrderItemCreateManyItemMasterInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemCreateNestedManyWithoutItemMasterInput = {
    create?: XOR<GRNItemCreateWithoutItemMasterInput, GRNItemUncheckedCreateWithoutItemMasterInput> | GRNItemCreateWithoutItemMasterInput[] | GRNItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutItemMasterInput | GRNItemCreateOrConnectWithoutItemMasterInput[]
    createMany?: GRNItemCreateManyItemMasterInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutItemMasterInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemMasterInput, PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput> | PurchaseInvoiceItemCreateWithoutItemMasterInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemMasterInput | PurchaseInvoiceItemCreateOrConnectWithoutItemMasterInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemMasterInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemCreateNestedManyWithoutItemMasterInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutItemMasterInput, PurchaseReturnItemUncheckedCreateWithoutItemMasterInput> | PurchaseReturnItemCreateWithoutItemMasterInput[] | PurchaseReturnItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutItemMasterInput | PurchaseReturnItemCreateOrConnectWithoutItemMasterInput[]
    createMany?: PurchaseReturnItemCreateManyItemMasterInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutItemMasterInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutItemMasterInput, PurchaseOrderItemUncheckedCreateWithoutItemMasterInput> | PurchaseOrderItemCreateWithoutItemMasterInput[] | PurchaseOrderItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutItemMasterInput | PurchaseOrderItemCreateOrConnectWithoutItemMasterInput[]
    createMany?: PurchaseOrderItemCreateManyItemMasterInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNItemUncheckedCreateNestedManyWithoutItemMasterInput = {
    create?: XOR<GRNItemCreateWithoutItemMasterInput, GRNItemUncheckedCreateWithoutItemMasterInput> | GRNItemCreateWithoutItemMasterInput[] | GRNItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutItemMasterInput | GRNItemCreateOrConnectWithoutItemMasterInput[]
    createMany?: GRNItemCreateManyItemMasterInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemMasterInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemMasterInput, PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput> | PurchaseInvoiceItemCreateWithoutItemMasterInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemMasterInput | PurchaseInvoiceItemCreateOrConnectWithoutItemMasterInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemMasterInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemUncheckedCreateNestedManyWithoutItemMasterInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutItemMasterInput, PurchaseReturnItemUncheckedCreateWithoutItemMasterInput> | PurchaseReturnItemCreateWithoutItemMasterInput[] | PurchaseReturnItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutItemMasterInput | PurchaseReturnItemCreateOrConnectWithoutItemMasterInput[]
    createMany?: PurchaseReturnItemCreateManyItemMasterInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type ItemGroupUpdateOneRequiredWithoutItemMastersNestedInput = {
    create?: XOR<ItemGroupCreateWithoutItemMastersInput, ItemGroupUncheckedCreateWithoutItemMastersInput>
    connectOrCreate?: ItemGroupCreateOrConnectWithoutItemMastersInput
    upsert?: ItemGroupUpsertWithoutItemMastersInput
    connect?: ItemGroupWhereUniqueInput
    update?: XOR<XOR<ItemGroupUpdateToOneWithWhereWithoutItemMastersInput, ItemGroupUpdateWithoutItemMastersInput>, ItemGroupUncheckedUpdateWithoutItemMastersInput>
  }

  export type UnitUpdateOneRequiredWithoutItemMastersNestedInput = {
    create?: XOR<UnitCreateWithoutItemMastersInput, UnitUncheckedCreateWithoutItemMastersInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemMastersInput
    upsert?: UnitUpsertWithoutItemMastersInput
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutItemMastersInput, UnitUpdateWithoutItemMastersInput>, UnitUncheckedUpdateWithoutItemMastersInput>
  }

  export type PackingUnitUpdateOneWithoutItemMastersNestedInput = {
    create?: XOR<PackingUnitCreateWithoutItemMastersInput, PackingUnitUncheckedCreateWithoutItemMastersInput>
    connectOrCreate?: PackingUnitCreateOrConnectWithoutItemMastersInput
    upsert?: PackingUnitUpsertWithoutItemMastersInput
    disconnect?: PackingUnitWhereInput | boolean
    delete?: PackingUnitWhereInput | boolean
    connect?: PackingUnitWhereUniqueInput
    update?: XOR<XOR<PackingUnitUpdateToOneWithWhereWithoutItemMastersInput, PackingUnitUpdateWithoutItemMastersInput>, PackingUnitUncheckedUpdateWithoutItemMastersInput>
  }

  export type CompanyUpdateOneRequiredWithoutItemMastersNestedInput = {
    create?: XOR<CompanyCreateWithoutItemMastersInput, CompanyUncheckedCreateWithoutItemMastersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutItemMastersInput
    upsert?: CompanyUpsertWithoutItemMastersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutItemMastersInput, CompanyUpdateWithoutItemMastersInput>, CompanyUncheckedUpdateWithoutItemMastersInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutItemMasterNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutItemMasterInput, PurchaseOrderItemUncheckedCreateWithoutItemMasterInput> | PurchaseOrderItemCreateWithoutItemMasterInput[] | PurchaseOrderItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutItemMasterInput | PurchaseOrderItemCreateOrConnectWithoutItemMasterInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutItemMasterInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutItemMasterInput[]
    createMany?: PurchaseOrderItemCreateManyItemMasterInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutItemMasterInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutItemMasterInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutItemMasterInput | PurchaseOrderItemUpdateManyWithWhereWithoutItemMasterInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUpdateManyWithoutItemMasterNestedInput = {
    create?: XOR<GRNItemCreateWithoutItemMasterInput, GRNItemUncheckedCreateWithoutItemMasterInput> | GRNItemCreateWithoutItemMasterInput[] | GRNItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutItemMasterInput | GRNItemCreateOrConnectWithoutItemMasterInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutItemMasterInput | GRNItemUpsertWithWhereUniqueWithoutItemMasterInput[]
    createMany?: GRNItemCreateManyItemMasterInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutItemMasterInput | GRNItemUpdateWithWhereUniqueWithoutItemMasterInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutItemMasterInput | GRNItemUpdateManyWithWhereWithoutItemMasterInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUpdateManyWithoutItemMasterNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemMasterInput, PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput> | PurchaseInvoiceItemCreateWithoutItemMasterInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemMasterInput | PurchaseInvoiceItemCreateOrConnectWithoutItemMasterInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemMasterInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemMasterInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemMasterInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemMasterInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemMasterInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutItemMasterInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutItemMasterInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUpdateManyWithoutItemMasterNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutItemMasterInput, PurchaseReturnItemUncheckedCreateWithoutItemMasterInput> | PurchaseReturnItemCreateWithoutItemMasterInput[] | PurchaseReturnItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutItemMasterInput | PurchaseReturnItemCreateOrConnectWithoutItemMasterInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutItemMasterInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutItemMasterInput[]
    createMany?: PurchaseReturnItemCreateManyItemMasterInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutItemMasterInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutItemMasterInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutItemMasterInput | PurchaseReturnItemUpdateManyWithWhereWithoutItemMasterInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutItemMasterInput, PurchaseOrderItemUncheckedCreateWithoutItemMasterInput> | PurchaseOrderItemCreateWithoutItemMasterInput[] | PurchaseOrderItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutItemMasterInput | PurchaseOrderItemCreateOrConnectWithoutItemMasterInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutItemMasterInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutItemMasterInput[]
    createMany?: PurchaseOrderItemCreateManyItemMasterInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutItemMasterInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutItemMasterInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutItemMasterInput | PurchaseOrderItemUpdateManyWithWhereWithoutItemMasterInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNItemUncheckedUpdateManyWithoutItemMasterNestedInput = {
    create?: XOR<GRNItemCreateWithoutItemMasterInput, GRNItemUncheckedCreateWithoutItemMasterInput> | GRNItemCreateWithoutItemMasterInput[] | GRNItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutItemMasterInput | GRNItemCreateOrConnectWithoutItemMasterInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutItemMasterInput | GRNItemUpsertWithWhereUniqueWithoutItemMasterInput[]
    createMany?: GRNItemCreateManyItemMasterInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutItemMasterInput | GRNItemUpdateWithWhereUniqueWithoutItemMasterInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutItemMasterInput | GRNItemUpdateManyWithWhereWithoutItemMasterInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemMasterInput, PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput> | PurchaseInvoiceItemCreateWithoutItemMasterInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemMasterInput | PurchaseInvoiceItemCreateOrConnectWithoutItemMasterInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemMasterInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemMasterInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemMasterInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemMasterInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemMasterInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutItemMasterInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutItemMasterInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutItemMasterInput, PurchaseReturnItemUncheckedCreateWithoutItemMasterInput> | PurchaseReturnItemCreateWithoutItemMasterInput[] | PurchaseReturnItemUncheckedCreateWithoutItemMasterInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutItemMasterInput | PurchaseReturnItemCreateOrConnectWithoutItemMasterInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutItemMasterInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutItemMasterInput[]
    createMany?: PurchaseReturnItemCreateManyItemMasterInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutItemMasterInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutItemMasterInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutItemMasterInput | PurchaseReturnItemUpdateManyWithWhereWithoutItemMasterInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<AccountCreateWithoutPurchaseOrdersInput, AccountUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPurchaseOrdersInput
    connect?: AccountWhereUniqueInput
  }

  export type WarehouseCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutPurchaseOrdersInput
    connect?: WarehouseWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<CurrencyCreateWithoutPurchaseOrdersInput, CurrencyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPurchaseOrdersInput
    connect?: CurrencyWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseOrdersInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<GRNCreateWithoutPurchaseOrderInput, GRNUncheckedCreateWithoutPurchaseOrderInput> | GRNCreateWithoutPurchaseOrderInput[] | GRNUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutPurchaseOrderInput | GRNCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: GRNCreateManyPurchaseOrderInputEnvelope
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
  }

  export type PurchaseInvoiceCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutPurchaseOrderInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput> | PurchaseInvoiceCreateWithoutPurchaseOrderInput[] | PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutPurchaseOrderInput | PurchaseInvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseInvoiceCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type GRNUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<GRNCreateWithoutPurchaseOrderInput, GRNUncheckedCreateWithoutPurchaseOrderInput> | GRNCreateWithoutPurchaseOrderInput[] | GRNUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutPurchaseOrderInput | GRNCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: GRNCreateManyPurchaseOrderInputEnvelope
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
  }

  export type PurchaseInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutPurchaseOrderInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput> | PurchaseInvoiceCreateWithoutPurchaseOrderInput[] | PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutPurchaseOrderInput | PurchaseInvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    createMany?: PurchaseInvoiceCreateManyPurchaseOrderInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type EnumPurchaseOrderTypeFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseOrderType
  }

  export type EnumPurchaseOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseOrderStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<AccountCreateWithoutPurchaseOrdersInput, AccountUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: AccountUpsertWithoutPurchaseOrdersInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutPurchaseOrdersInput, AccountUpdateWithoutPurchaseOrdersInput>, AccountUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type WarehouseUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: WarehouseCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: WarehouseUpsertWithoutPurchaseOrdersInput
    disconnect?: WarehouseWhereInput | boolean
    delete?: WarehouseWhereInput | boolean
    connect?: WarehouseWhereUniqueInput
    update?: XOR<XOR<WarehouseUpdateToOneWithWhereWithoutPurchaseOrdersInput, WarehouseUpdateWithoutPurchaseOrdersInput>, WarehouseUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type CurrencyUpdateOneWithoutPurchaseOrdersNestedInput = {
    create?: XOR<CurrencyCreateWithoutPurchaseOrdersInput, CurrencyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: CurrencyUpsertWithoutPurchaseOrdersInput
    disconnect?: CurrencyWhereInput | boolean
    delete?: CurrencyWhereInput | boolean
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutPurchaseOrdersInput, CurrencyUpdateWithoutPurchaseOrdersInput>, CurrencyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: CompanyUpsertWithoutPurchaseOrdersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPurchaseOrdersInput, CompanyUpdateWithoutPurchaseOrdersInput>, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<GRNCreateWithoutPurchaseOrderInput, GRNUncheckedCreateWithoutPurchaseOrderInput> | GRNCreateWithoutPurchaseOrderInput[] | GRNUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutPurchaseOrderInput | GRNCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: GRNUpsertWithWhereUniqueWithoutPurchaseOrderInput | GRNUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: GRNCreateManyPurchaseOrderInputEnvelope
    set?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    disconnect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    delete?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    update?: GRNUpdateWithWhereUniqueWithoutPurchaseOrderInput | GRNUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: GRNUpdateManyWithWhereWithoutPurchaseOrderInput | GRNUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: GRNScalarWhereInput | GRNScalarWhereInput[]
  }

  export type PurchaseInvoiceUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutPurchaseOrderInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput> | PurchaseInvoiceCreateWithoutPurchaseOrderInput[] | PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutPurchaseOrderInput | PurchaseInvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseInvoiceCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput> | PurchaseOrderItemCreateWithoutPurchaseOrderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput | PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type GRNUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<GRNCreateWithoutPurchaseOrderInput, GRNUncheckedCreateWithoutPurchaseOrderInput> | GRNCreateWithoutPurchaseOrderInput[] | GRNUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutPurchaseOrderInput | GRNCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: GRNUpsertWithWhereUniqueWithoutPurchaseOrderInput | GRNUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: GRNCreateManyPurchaseOrderInputEnvelope
    set?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    disconnect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    delete?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    update?: GRNUpdateWithWhereUniqueWithoutPurchaseOrderInput | GRNUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: GRNUpdateManyWithWhereWithoutPurchaseOrderInput | GRNUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: GRNScalarWhereInput | GRNScalarWhereInput[]
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutPurchaseOrderInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput> | PurchaseInvoiceCreateWithoutPurchaseOrderInput[] | PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutPurchaseOrderInput | PurchaseInvoiceCreateOrConnectWithoutPurchaseOrderInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput[]
    createMany?: PurchaseInvoiceCreateManyPurchaseOrderInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput | PurchaseInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<ItemMasterCreateWithoutPurchaseOrderItemsInput, ItemMasterUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: ItemMasterWhereUniqueInput
  }

  export type ColorCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<ColorCreateWithoutPurchaseOrderItemsInput, ColorUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ColorCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: ColorWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<BrandCreateWithoutPurchaseOrderItemsInput, BrandUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: BrandWhereUniqueInput
  }

  export type ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<ItemGradeCreateWithoutPurchaseOrderItemsInput, ItemGradeUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ItemGradeCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: ItemGradeWhereUniqueInput
  }

  export type PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<PackingUnitCreateWithoutPurchaseOrderItemsInput, PackingUnitUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: PackingUnitCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: PackingUnitWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutPurchaseOrderItemsInput = {
    create?: XOR<UnitCreateWithoutPurchaseOrderItemsInput, UnitUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutPurchaseOrderItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type GRNItemCreateNestedManyWithoutPurchaseOrderItemInput = {
    create?: XOR<GRNItemCreateWithoutPurchaseOrderItemInput, GRNItemUncheckedCreateWithoutPurchaseOrderItemInput> | GRNItemCreateWithoutPurchaseOrderItemInput[] | GRNItemUncheckedCreateWithoutPurchaseOrderItemInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutPurchaseOrderItemInput | GRNItemCreateOrConnectWithoutPurchaseOrderItemInput[]
    createMany?: GRNItemCreateManyPurchaseOrderItemInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput> | PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseOrderItemInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseOrderItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseOrderItemInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput = {
    create?: XOR<GRNItemCreateWithoutPurchaseOrderItemInput, GRNItemUncheckedCreateWithoutPurchaseOrderItemInput> | GRNItemCreateWithoutPurchaseOrderItemInput[] | GRNItemUncheckedCreateWithoutPurchaseOrderItemInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutPurchaseOrderItemInput | GRNItemCreateOrConnectWithoutPurchaseOrderItemInput[]
    createMany?: GRNItemCreateManyPurchaseOrderItemInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput> | PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseOrderItemInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseOrderItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseOrderItemInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type NullableEnumPackingTypeFieldUpdateOperationsInput = {
    set?: $Enums.PackingType | null
  }

  export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: PurchaseOrderUpsertWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput, PurchaseOrderUpdateWithoutItemsInput>, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<ItemMasterCreateWithoutPurchaseOrderItemsInput, ItemMasterUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: ItemMasterUpsertWithoutPurchaseOrderItemsInput
    connect?: ItemMasterWhereUniqueInput
    update?: XOR<XOR<ItemMasterUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, ItemMasterUpdateWithoutPurchaseOrderItemsInput>, ItemMasterUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type ColorUpdateOneWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<ColorCreateWithoutPurchaseOrderItemsInput, ColorUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ColorCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: ColorUpsertWithoutPurchaseOrderItemsInput
    disconnect?: ColorWhereInput | boolean
    delete?: ColorWhereInput | boolean
    connect?: ColorWhereUniqueInput
    update?: XOR<XOR<ColorUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, ColorUpdateWithoutPurchaseOrderItemsInput>, ColorUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type BrandUpdateOneWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<BrandCreateWithoutPurchaseOrderItemsInput, BrandUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: BrandUpsertWithoutPurchaseOrderItemsInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, BrandUpdateWithoutPurchaseOrderItemsInput>, BrandUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<ItemGradeCreateWithoutPurchaseOrderItemsInput, ItemGradeUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: ItemGradeCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: ItemGradeUpsertWithoutPurchaseOrderItemsInput
    disconnect?: ItemGradeWhereInput | boolean
    delete?: ItemGradeWhereInput | boolean
    connect?: ItemGradeWhereUniqueInput
    update?: XOR<XOR<ItemGradeUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, ItemGradeUpdateWithoutPurchaseOrderItemsInput>, ItemGradeUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<PackingUnitCreateWithoutPurchaseOrderItemsInput, PackingUnitUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: PackingUnitCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: PackingUnitUpsertWithoutPurchaseOrderItemsInput
    disconnect?: PackingUnitWhereInput | boolean
    delete?: PackingUnitWhereInput | boolean
    connect?: PackingUnitWhereUniqueInput
    update?: XOR<XOR<PackingUnitUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, PackingUnitUpdateWithoutPurchaseOrderItemsInput>, PackingUnitUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type UnitUpdateOneWithoutPurchaseOrderItemsNestedInput = {
    create?: XOR<UnitCreateWithoutPurchaseOrderItemsInput, UnitUncheckedCreateWithoutPurchaseOrderItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutPurchaseOrderItemsInput
    upsert?: UnitUpsertWithoutPurchaseOrderItemsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutPurchaseOrderItemsInput, UnitUpdateWithoutPurchaseOrderItemsInput>, UnitUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput = {
    create?: XOR<GRNItemCreateWithoutPurchaseOrderItemInput, GRNItemUncheckedCreateWithoutPurchaseOrderItemInput> | GRNItemCreateWithoutPurchaseOrderItemInput[] | GRNItemUncheckedCreateWithoutPurchaseOrderItemInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutPurchaseOrderItemInput | GRNItemCreateOrConnectWithoutPurchaseOrderItemInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput | GRNItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput[]
    createMany?: GRNItemCreateManyPurchaseOrderItemInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput | GRNItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutPurchaseOrderItemInput | GRNItemUpdateManyWithWhereWithoutPurchaseOrderItemInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput> | PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseOrderItemInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseOrderItemInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseOrderItemInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseOrderItemInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseOrderItemInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput = {
    create?: XOR<GRNItemCreateWithoutPurchaseOrderItemInput, GRNItemUncheckedCreateWithoutPurchaseOrderItemInput> | GRNItemCreateWithoutPurchaseOrderItemInput[] | GRNItemUncheckedCreateWithoutPurchaseOrderItemInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutPurchaseOrderItemInput | GRNItemCreateOrConnectWithoutPurchaseOrderItemInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput | GRNItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput[]
    createMany?: GRNItemCreateManyPurchaseOrderItemInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput | GRNItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutPurchaseOrderItemInput | GRNItemUpdateManyWithWhereWithoutPurchaseOrderItemInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput> | PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseOrderItemInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseOrderItemInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseOrderItemInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseOrderItemInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseOrderItemInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutGrnsInput = {
    create?: XOR<PurchaseOrderCreateWithoutGrnsInput, PurchaseOrderUncheckedCreateWithoutGrnsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutGrnsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutGrnsInput = {
    create?: XOR<CompanyCreateWithoutGrnsInput, CompanyUncheckedCreateWithoutGrnsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGrnsInput
    connect?: CompanyWhereUniqueInput
  }

  export type GRNItemCreateNestedManyWithoutGrnInput = {
    create?: XOR<GRNItemCreateWithoutGrnInput, GRNItemUncheckedCreateWithoutGrnInput> | GRNItemCreateWithoutGrnInput[] | GRNItemUncheckedCreateWithoutGrnInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutGrnInput | GRNItemCreateOrConnectWithoutGrnInput[]
    createMany?: GRNItemCreateManyGrnInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseReturnCreateNestedManyWithoutGrnInput = {
    create?: XOR<PurchaseReturnCreateWithoutGrnInput, PurchaseReturnUncheckedCreateWithoutGrnInput> | PurchaseReturnCreateWithoutGrnInput[] | PurchaseReturnUncheckedCreateWithoutGrnInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutGrnInput | PurchaseReturnCreateOrConnectWithoutGrnInput[]
    createMany?: PurchaseReturnCreateManyGrnInputEnvelope
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
  }

  export type GRNItemUncheckedCreateNestedManyWithoutGrnInput = {
    create?: XOR<GRNItemCreateWithoutGrnInput, GRNItemUncheckedCreateWithoutGrnInput> | GRNItemCreateWithoutGrnInput[] | GRNItemUncheckedCreateWithoutGrnInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutGrnInput | GRNItemCreateOrConnectWithoutGrnInput[]
    createMany?: GRNItemCreateManyGrnInputEnvelope
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
  }

  export type PurchaseReturnUncheckedCreateNestedManyWithoutGrnInput = {
    create?: XOR<PurchaseReturnCreateWithoutGrnInput, PurchaseReturnUncheckedCreateWithoutGrnInput> | PurchaseReturnCreateWithoutGrnInput[] | PurchaseReturnUncheckedCreateWithoutGrnInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutGrnInput | PurchaseReturnCreateOrConnectWithoutGrnInput[]
    createMany?: PurchaseReturnCreateManyGrnInputEnvelope
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
  }

  export type PurchaseOrderUpdateOneRequiredWithoutGrnsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutGrnsInput, PurchaseOrderUncheckedCreateWithoutGrnsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutGrnsInput
    upsert?: PurchaseOrderUpsertWithoutGrnsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutGrnsInput, PurchaseOrderUpdateWithoutGrnsInput>, PurchaseOrderUncheckedUpdateWithoutGrnsInput>
  }

  export type CompanyUpdateOneRequiredWithoutGrnsNestedInput = {
    create?: XOR<CompanyCreateWithoutGrnsInput, CompanyUncheckedCreateWithoutGrnsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutGrnsInput
    upsert?: CompanyUpsertWithoutGrnsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutGrnsInput, CompanyUpdateWithoutGrnsInput>, CompanyUncheckedUpdateWithoutGrnsInput>
  }

  export type GRNItemUpdateManyWithoutGrnNestedInput = {
    create?: XOR<GRNItemCreateWithoutGrnInput, GRNItemUncheckedCreateWithoutGrnInput> | GRNItemCreateWithoutGrnInput[] | GRNItemUncheckedCreateWithoutGrnInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutGrnInput | GRNItemCreateOrConnectWithoutGrnInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutGrnInput | GRNItemUpsertWithWhereUniqueWithoutGrnInput[]
    createMany?: GRNItemCreateManyGrnInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutGrnInput | GRNItemUpdateWithWhereUniqueWithoutGrnInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutGrnInput | GRNItemUpdateManyWithWhereWithoutGrnInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseReturnUpdateManyWithoutGrnNestedInput = {
    create?: XOR<PurchaseReturnCreateWithoutGrnInput, PurchaseReturnUncheckedCreateWithoutGrnInput> | PurchaseReturnCreateWithoutGrnInput[] | PurchaseReturnUncheckedCreateWithoutGrnInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutGrnInput | PurchaseReturnCreateOrConnectWithoutGrnInput[]
    upsert?: PurchaseReturnUpsertWithWhereUniqueWithoutGrnInput | PurchaseReturnUpsertWithWhereUniqueWithoutGrnInput[]
    createMany?: PurchaseReturnCreateManyGrnInputEnvelope
    set?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    disconnect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    delete?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    update?: PurchaseReturnUpdateWithWhereUniqueWithoutGrnInput | PurchaseReturnUpdateWithWhereUniqueWithoutGrnInput[]
    updateMany?: PurchaseReturnUpdateManyWithWhereWithoutGrnInput | PurchaseReturnUpdateManyWithWhereWithoutGrnInput[]
    deleteMany?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
  }

  export type GRNItemUncheckedUpdateManyWithoutGrnNestedInput = {
    create?: XOR<GRNItemCreateWithoutGrnInput, GRNItemUncheckedCreateWithoutGrnInput> | GRNItemCreateWithoutGrnInput[] | GRNItemUncheckedCreateWithoutGrnInput[]
    connectOrCreate?: GRNItemCreateOrConnectWithoutGrnInput | GRNItemCreateOrConnectWithoutGrnInput[]
    upsert?: GRNItemUpsertWithWhereUniqueWithoutGrnInput | GRNItemUpsertWithWhereUniqueWithoutGrnInput[]
    createMany?: GRNItemCreateManyGrnInputEnvelope
    set?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    disconnect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    delete?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    connect?: GRNItemWhereUniqueInput | GRNItemWhereUniqueInput[]
    update?: GRNItemUpdateWithWhereUniqueWithoutGrnInput | GRNItemUpdateWithWhereUniqueWithoutGrnInput[]
    updateMany?: GRNItemUpdateManyWithWhereWithoutGrnInput | GRNItemUpdateManyWithWhereWithoutGrnInput[]
    deleteMany?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
  }

  export type PurchaseReturnUncheckedUpdateManyWithoutGrnNestedInput = {
    create?: XOR<PurchaseReturnCreateWithoutGrnInput, PurchaseReturnUncheckedCreateWithoutGrnInput> | PurchaseReturnCreateWithoutGrnInput[] | PurchaseReturnUncheckedCreateWithoutGrnInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutGrnInput | PurchaseReturnCreateOrConnectWithoutGrnInput[]
    upsert?: PurchaseReturnUpsertWithWhereUniqueWithoutGrnInput | PurchaseReturnUpsertWithWhereUniqueWithoutGrnInput[]
    createMany?: PurchaseReturnCreateManyGrnInputEnvelope
    set?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    disconnect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    delete?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    update?: PurchaseReturnUpdateWithWhereUniqueWithoutGrnInput | PurchaseReturnUpdateWithWhereUniqueWithoutGrnInput[]
    updateMany?: PurchaseReturnUpdateManyWithWhereWithoutGrnInput | PurchaseReturnUpdateManyWithWhereWithoutGrnInput[]
    deleteMany?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
  }

  export type GRNCreateNestedOneWithoutItemsInput = {
    create?: XOR<GRNCreateWithoutItemsInput, GRNUncheckedCreateWithoutItemsInput>
    connectOrCreate?: GRNCreateOrConnectWithoutItemsInput
    connect?: GRNWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutGrnItemsInput, PurchaseOrderItemUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutGrnItemsInput
    connect?: PurchaseOrderItemWhereUniqueInput
  }

  export type ItemMasterCreateNestedOneWithoutGrnItemsInput = {
    create?: XOR<ItemMasterCreateWithoutGrnItemsInput, ItemMasterUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: ItemMasterCreateOrConnectWithoutGrnItemsInput
    connect?: ItemMasterWhereUniqueInput
  }

  export type ColorCreateNestedOneWithoutGrnItemsInput = {
    create?: XOR<ColorCreateWithoutGrnItemsInput, ColorUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: ColorCreateOrConnectWithoutGrnItemsInput
    connect?: ColorWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutGrnItemsInput = {
    create?: XOR<BrandCreateWithoutGrnItemsInput, BrandUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutGrnItemsInput
    connect?: BrandWhereUniqueInput
  }

  export type ItemGradeCreateNestedOneWithoutGrnItemsInput = {
    create?: XOR<ItemGradeCreateWithoutGrnItemsInput, ItemGradeUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: ItemGradeCreateOrConnectWithoutGrnItemsInput
    connect?: ItemGradeWhereUniqueInput
  }

  export type PackingUnitCreateNestedOneWithoutGrnItemsInput = {
    create?: XOR<PackingUnitCreateWithoutGrnItemsInput, PackingUnitUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: PackingUnitCreateOrConnectWithoutGrnItemsInput
    connect?: PackingUnitWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutGrnItemsInput = {
    create?: XOR<UnitCreateWithoutGrnItemsInput, UnitUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutGrnItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutGrnItemInput, PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput> | PurchaseInvoiceItemCreateWithoutGrnItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutGrnItemInput | PurchaseInvoiceItemCreateOrConnectWithoutGrnItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyGrnItemInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutGrnItemInput, PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput> | PurchaseInvoiceItemCreateWithoutGrnItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutGrnItemInput | PurchaseInvoiceItemCreateOrConnectWithoutGrnItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyGrnItemInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type GRNUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<GRNCreateWithoutItemsInput, GRNUncheckedCreateWithoutItemsInput>
    connectOrCreate?: GRNCreateOrConnectWithoutItemsInput
    upsert?: GRNUpsertWithoutItemsInput
    connect?: GRNWhereUniqueInput
    update?: XOR<XOR<GRNUpdateToOneWithWhereWithoutItemsInput, GRNUpdateWithoutItemsInput>, GRNUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutGrnItemsInput, PurchaseOrderItemUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutGrnItemsInput
    upsert?: PurchaseOrderItemUpsertWithoutGrnItemsInput
    connect?: PurchaseOrderItemWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderItemUpdateToOneWithWhereWithoutGrnItemsInput, PurchaseOrderItemUpdateWithoutGrnItemsInput>, PurchaseOrderItemUncheckedUpdateWithoutGrnItemsInput>
  }

  export type ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput = {
    create?: XOR<ItemMasterCreateWithoutGrnItemsInput, ItemMasterUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: ItemMasterCreateOrConnectWithoutGrnItemsInput
    upsert?: ItemMasterUpsertWithoutGrnItemsInput
    connect?: ItemMasterWhereUniqueInput
    update?: XOR<XOR<ItemMasterUpdateToOneWithWhereWithoutGrnItemsInput, ItemMasterUpdateWithoutGrnItemsInput>, ItemMasterUncheckedUpdateWithoutGrnItemsInput>
  }

  export type ColorUpdateOneWithoutGrnItemsNestedInput = {
    create?: XOR<ColorCreateWithoutGrnItemsInput, ColorUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: ColorCreateOrConnectWithoutGrnItemsInput
    upsert?: ColorUpsertWithoutGrnItemsInput
    disconnect?: ColorWhereInput | boolean
    delete?: ColorWhereInput | boolean
    connect?: ColorWhereUniqueInput
    update?: XOR<XOR<ColorUpdateToOneWithWhereWithoutGrnItemsInput, ColorUpdateWithoutGrnItemsInput>, ColorUncheckedUpdateWithoutGrnItemsInput>
  }

  export type BrandUpdateOneWithoutGrnItemsNestedInput = {
    create?: XOR<BrandCreateWithoutGrnItemsInput, BrandUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutGrnItemsInput
    upsert?: BrandUpsertWithoutGrnItemsInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutGrnItemsInput, BrandUpdateWithoutGrnItemsInput>, BrandUncheckedUpdateWithoutGrnItemsInput>
  }

  export type ItemGradeUpdateOneWithoutGrnItemsNestedInput = {
    create?: XOR<ItemGradeCreateWithoutGrnItemsInput, ItemGradeUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: ItemGradeCreateOrConnectWithoutGrnItemsInput
    upsert?: ItemGradeUpsertWithoutGrnItemsInput
    disconnect?: ItemGradeWhereInput | boolean
    delete?: ItemGradeWhereInput | boolean
    connect?: ItemGradeWhereUniqueInput
    update?: XOR<XOR<ItemGradeUpdateToOneWithWhereWithoutGrnItemsInput, ItemGradeUpdateWithoutGrnItemsInput>, ItemGradeUncheckedUpdateWithoutGrnItemsInput>
  }

  export type PackingUnitUpdateOneWithoutGrnItemsNestedInput = {
    create?: XOR<PackingUnitCreateWithoutGrnItemsInput, PackingUnitUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: PackingUnitCreateOrConnectWithoutGrnItemsInput
    upsert?: PackingUnitUpsertWithoutGrnItemsInput
    disconnect?: PackingUnitWhereInput | boolean
    delete?: PackingUnitWhereInput | boolean
    connect?: PackingUnitWhereUniqueInput
    update?: XOR<XOR<PackingUnitUpdateToOneWithWhereWithoutGrnItemsInput, PackingUnitUpdateWithoutGrnItemsInput>, PackingUnitUncheckedUpdateWithoutGrnItemsInput>
  }

  export type UnitUpdateOneWithoutGrnItemsNestedInput = {
    create?: XOR<UnitCreateWithoutGrnItemsInput, UnitUncheckedCreateWithoutGrnItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutGrnItemsInput
    upsert?: UnitUpsertWithoutGrnItemsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutGrnItemsInput, UnitUpdateWithoutGrnItemsInput>, UnitUncheckedUpdateWithoutGrnItemsInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutGrnItemInput, PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput> | PurchaseInvoiceItemCreateWithoutGrnItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutGrnItemInput | PurchaseInvoiceItemCreateOrConnectWithoutGrnItemInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutGrnItemInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutGrnItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyGrnItemInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutGrnItemInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutGrnItemInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutGrnItemInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutGrnItemInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutGrnItemInput, PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput> | PurchaseInvoiceItemCreateWithoutGrnItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutGrnItemInput | PurchaseInvoiceItemCreateOrConnectWithoutGrnItemInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutGrnItemInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutGrnItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyGrnItemInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutGrnItemInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutGrnItemInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutGrnItemInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutGrnItemInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutInvoicesInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutPurchaseInvoicesInput = {
    create?: XOR<AccountCreateWithoutPurchaseInvoicesInput, AccountUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPurchaseInvoicesInput
    connect?: AccountWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutPurchaseInvoicesInput = {
    create?: XOR<CompanyCreateWithoutPurchaseInvoicesInput, CompanyUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseInvoicesInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput> | PurchaseInvoiceItemCreateWithoutInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnCreateNestedManyWithoutPurchaseInvoiceInput = {
    create?: XOR<PurchaseReturnCreateWithoutPurchaseInvoiceInput, PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseReturnCreateWithoutPurchaseInvoiceInput[] | PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseReturnCreateOrConnectWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseReturnCreateManyPurchaseInvoiceInputEnvelope
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput> | PurchaseInvoiceItemCreateWithoutInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyInvoiceInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnUncheckedCreateNestedManyWithoutPurchaseInvoiceInput = {
    create?: XOR<PurchaseReturnCreateWithoutPurchaseInvoiceInput, PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseReturnCreateWithoutPurchaseInvoiceInput[] | PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseReturnCreateOrConnectWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseReturnCreateManyPurchaseInvoiceInputEnvelope
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
  }

  export type PurchaseOrderUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutInvoicesInput
    upsert?: PurchaseOrderUpsertWithoutInvoicesInput
    disconnect?: PurchaseOrderWhereInput | boolean
    delete?: PurchaseOrderWhereInput | boolean
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutInvoicesInput, PurchaseOrderUpdateWithoutInvoicesInput>, PurchaseOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type AccountUpdateOneWithoutPurchaseInvoicesNestedInput = {
    create?: XOR<AccountCreateWithoutPurchaseInvoicesInput, AccountUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPurchaseInvoicesInput
    upsert?: AccountUpsertWithoutPurchaseInvoicesInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutPurchaseInvoicesInput, AccountUpdateWithoutPurchaseInvoicesInput>, AccountUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput = {
    create?: XOR<CompanyCreateWithoutPurchaseInvoicesInput, CompanyUncheckedCreateWithoutPurchaseInvoicesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseInvoicesInput
    upsert?: CompanyUpsertWithoutPurchaseInvoicesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPurchaseInvoicesInput, CompanyUpdateWithoutPurchaseInvoicesInput>, CompanyUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput> | PurchaseInvoiceItemCreateWithoutInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyInvoiceInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnUpdateManyWithoutPurchaseInvoiceNestedInput = {
    create?: XOR<PurchaseReturnCreateWithoutPurchaseInvoiceInput, PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseReturnCreateWithoutPurchaseInvoiceInput[] | PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseReturnCreateOrConnectWithoutPurchaseInvoiceInput[]
    upsert?: PurchaseReturnUpsertWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseReturnUpsertWithWhereUniqueWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseReturnCreateManyPurchaseInvoiceInputEnvelope
    set?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    disconnect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    delete?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    update?: PurchaseReturnUpdateWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseReturnUpdateWithWhereUniqueWithoutPurchaseInvoiceInput[]
    updateMany?: PurchaseReturnUpdateManyWithWhereWithoutPurchaseInvoiceInput | PurchaseReturnUpdateManyWithWhereWithoutPurchaseInvoiceInput[]
    deleteMany?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput> | PurchaseInvoiceItemCreateWithoutInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyInvoiceInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput = {
    create?: XOR<PurchaseReturnCreateWithoutPurchaseInvoiceInput, PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseReturnCreateWithoutPurchaseInvoiceInput[] | PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseReturnCreateOrConnectWithoutPurchaseInvoiceInput[]
    upsert?: PurchaseReturnUpsertWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseReturnUpsertWithWhereUniqueWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseReturnCreateManyPurchaseInvoiceInputEnvelope
    set?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    disconnect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    delete?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    connect?: PurchaseReturnWhereUniqueInput | PurchaseReturnWhereUniqueInput[]
    update?: PurchaseReturnUpdateWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseReturnUpdateWithWhereUniqueWithoutPurchaseInvoiceInput[]
    updateMany?: PurchaseReturnUpdateManyWithWhereWithoutPurchaseInvoiceInput | PurchaseReturnUpdateManyWithWhereWithoutPurchaseInvoiceInput[]
    deleteMany?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
  }

  export type PurchaseInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutItemsInput
    connect?: PurchaseInvoiceWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutInvoiceItemsInput, PurchaseOrderItemUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutInvoiceItemsInput
    connect?: PurchaseOrderItemWhereUniqueInput
  }

  export type GRNItemCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<GRNItemCreateWithoutInvoiceItemsInput, GRNItemUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: GRNItemCreateOrConnectWithoutInvoiceItemsInput
    connect?: GRNItemWhereUniqueInput
  }

  export type ItemMasterCreateNestedOneWithoutPurchaseInvoiceItemsInput = {
    create?: XOR<ItemMasterCreateWithoutPurchaseInvoiceItemsInput, ItemMasterUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPurchaseInvoiceItemsInput
    connect?: ItemMasterWhereUniqueInput
  }

  export type ColorCreateNestedOneWithoutPurchaseInvoiceItemsInput = {
    create?: XOR<ColorCreateWithoutPurchaseInvoiceItemsInput, ColorUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: ColorCreateOrConnectWithoutPurchaseInvoiceItemsInput
    connect?: ColorWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutPurchaseInvoiceItemsInput = {
    create?: XOR<BrandCreateWithoutPurchaseInvoiceItemsInput, BrandUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutPurchaseInvoiceItemsInput
    connect?: BrandWhereUniqueInput
  }

  export type ItemGradeCreateNestedOneWithoutPurchaseInvoiceItemsInput = {
    create?: XOR<ItemGradeCreateWithoutPurchaseInvoiceItemsInput, ItemGradeUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: ItemGradeCreateOrConnectWithoutPurchaseInvoiceItemsInput
    connect?: ItemGradeWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutPurchaseInvoiceItemsInput = {
    create?: XOR<UnitCreateWithoutPurchaseInvoiceItemsInput, UnitUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutPurchaseInvoiceItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutItemsInput
    upsert?: PurchaseInvoiceUpsertWithoutItemsInput
    connect?: PurchaseInvoiceWhereUniqueInput
    update?: XOR<XOR<PurchaseInvoiceUpdateToOneWithWhereWithoutItemsInput, PurchaseInvoiceUpdateWithoutItemsInput>, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderItemUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutInvoiceItemsInput, PurchaseOrderItemUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutInvoiceItemsInput
    upsert?: PurchaseOrderItemUpsertWithoutInvoiceItemsInput
    disconnect?: PurchaseOrderItemWhereInput | boolean
    delete?: PurchaseOrderItemWhereInput | boolean
    connect?: PurchaseOrderItemWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderItemUpdateToOneWithWhereWithoutInvoiceItemsInput, PurchaseOrderItemUpdateWithoutInvoiceItemsInput>, PurchaseOrderItemUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type GRNItemUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<GRNItemCreateWithoutInvoiceItemsInput, GRNItemUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: GRNItemCreateOrConnectWithoutInvoiceItemsInput
    upsert?: GRNItemUpsertWithoutInvoiceItemsInput
    disconnect?: GRNItemWhereInput | boolean
    delete?: GRNItemWhereInput | boolean
    connect?: GRNItemWhereUniqueInput
    update?: XOR<XOR<GRNItemUpdateToOneWithWhereWithoutInvoiceItemsInput, GRNItemUpdateWithoutInvoiceItemsInput>, GRNItemUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ItemMasterUpdateOneWithoutPurchaseInvoiceItemsNestedInput = {
    create?: XOR<ItemMasterCreateWithoutPurchaseInvoiceItemsInput, ItemMasterUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPurchaseInvoiceItemsInput
    upsert?: ItemMasterUpsertWithoutPurchaseInvoiceItemsInput
    disconnect?: ItemMasterWhereInput | boolean
    delete?: ItemMasterWhereInput | boolean
    connect?: ItemMasterWhereUniqueInput
    update?: XOR<XOR<ItemMasterUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput, ItemMasterUpdateWithoutPurchaseInvoiceItemsInput>, ItemMasterUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type ColorUpdateOneWithoutPurchaseInvoiceItemsNestedInput = {
    create?: XOR<ColorCreateWithoutPurchaseInvoiceItemsInput, ColorUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: ColorCreateOrConnectWithoutPurchaseInvoiceItemsInput
    upsert?: ColorUpsertWithoutPurchaseInvoiceItemsInput
    disconnect?: ColorWhereInput | boolean
    delete?: ColorWhereInput | boolean
    connect?: ColorWhereUniqueInput
    update?: XOR<XOR<ColorUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput, ColorUpdateWithoutPurchaseInvoiceItemsInput>, ColorUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type BrandUpdateOneWithoutPurchaseInvoiceItemsNestedInput = {
    create?: XOR<BrandCreateWithoutPurchaseInvoiceItemsInput, BrandUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutPurchaseInvoiceItemsInput
    upsert?: BrandUpsertWithoutPurchaseInvoiceItemsInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput, BrandUpdateWithoutPurchaseInvoiceItemsInput>, BrandUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type ItemGradeUpdateOneWithoutPurchaseInvoiceItemsNestedInput = {
    create?: XOR<ItemGradeCreateWithoutPurchaseInvoiceItemsInput, ItemGradeUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: ItemGradeCreateOrConnectWithoutPurchaseInvoiceItemsInput
    upsert?: ItemGradeUpsertWithoutPurchaseInvoiceItemsInput
    disconnect?: ItemGradeWhereInput | boolean
    delete?: ItemGradeWhereInput | boolean
    connect?: ItemGradeWhereUniqueInput
    update?: XOR<XOR<ItemGradeUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput, ItemGradeUpdateWithoutPurchaseInvoiceItemsInput>, ItemGradeUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type UnitUpdateOneWithoutPurchaseInvoiceItemsNestedInput = {
    create?: XOR<UnitCreateWithoutPurchaseInvoiceItemsInput, UnitUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutPurchaseInvoiceItemsInput
    upsert?: UnitUpsertWithoutPurchaseInvoiceItemsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput, UnitUpdateWithoutPurchaseInvoiceItemsInput>, UnitUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnsInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutPurchaseReturnsInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutPurchaseReturnsInput
    connect?: PurchaseInvoiceWhereUniqueInput
  }

  export type GRNCreateNestedOneWithoutPurchaseReturnsInput = {
    create?: XOR<GRNCreateWithoutPurchaseReturnsInput, GRNUncheckedCreateWithoutPurchaseReturnsInput>
    connectOrCreate?: GRNCreateOrConnectWithoutPurchaseReturnsInput
    connect?: GRNWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutPurchaseReturnsInput = {
    create?: XOR<AccountCreateWithoutPurchaseReturnsInput, AccountUncheckedCreateWithoutPurchaseReturnsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPurchaseReturnsInput
    connect?: AccountWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutPurchaseReturnsInput = {
    create?: XOR<CompanyCreateWithoutPurchaseReturnsInput, CompanyUncheckedCreateWithoutPurchaseReturnsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseReturnsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PurchaseReturnItemCreateNestedManyWithoutReturnInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutReturnInput, PurchaseReturnItemUncheckedCreateWithoutReturnInput> | PurchaseReturnItemCreateWithoutReturnInput[] | PurchaseReturnItemUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutReturnInput | PurchaseReturnItemCreateOrConnectWithoutReturnInput[]
    createMany?: PurchaseReturnItemCreateManyReturnInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type PurchaseReturnItemUncheckedCreateNestedManyWithoutReturnInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutReturnInput, PurchaseReturnItemUncheckedCreateWithoutReturnInput> | PurchaseReturnItemCreateWithoutReturnInput[] | PurchaseReturnItemUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutReturnInput | PurchaseReturnItemCreateOrConnectWithoutReturnInput[]
    createMany?: PurchaseReturnItemCreateManyReturnInputEnvelope
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
  }

  export type PurchaseInvoiceUpdateOneWithoutPurchaseReturnsNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutPurchaseReturnsInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutPurchaseReturnsInput
    upsert?: PurchaseInvoiceUpsertWithoutPurchaseReturnsInput
    disconnect?: PurchaseInvoiceWhereInput | boolean
    delete?: PurchaseInvoiceWhereInput | boolean
    connect?: PurchaseInvoiceWhereUniqueInput
    update?: XOR<XOR<PurchaseInvoiceUpdateToOneWithWhereWithoutPurchaseReturnsInput, PurchaseInvoiceUpdateWithoutPurchaseReturnsInput>, PurchaseInvoiceUncheckedUpdateWithoutPurchaseReturnsInput>
  }

  export type GRNUpdateOneWithoutPurchaseReturnsNestedInput = {
    create?: XOR<GRNCreateWithoutPurchaseReturnsInput, GRNUncheckedCreateWithoutPurchaseReturnsInput>
    connectOrCreate?: GRNCreateOrConnectWithoutPurchaseReturnsInput
    upsert?: GRNUpsertWithoutPurchaseReturnsInput
    disconnect?: GRNWhereInput | boolean
    delete?: GRNWhereInput | boolean
    connect?: GRNWhereUniqueInput
    update?: XOR<XOR<GRNUpdateToOneWithWhereWithoutPurchaseReturnsInput, GRNUpdateWithoutPurchaseReturnsInput>, GRNUncheckedUpdateWithoutPurchaseReturnsInput>
  }

  export type AccountUpdateOneWithoutPurchaseReturnsNestedInput = {
    create?: XOR<AccountCreateWithoutPurchaseReturnsInput, AccountUncheckedCreateWithoutPurchaseReturnsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPurchaseReturnsInput
    upsert?: AccountUpsertWithoutPurchaseReturnsInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutPurchaseReturnsInput, AccountUpdateWithoutPurchaseReturnsInput>, AccountUncheckedUpdateWithoutPurchaseReturnsInput>
  }

  export type CompanyUpdateOneRequiredWithoutPurchaseReturnsNestedInput = {
    create?: XOR<CompanyCreateWithoutPurchaseReturnsInput, CompanyUncheckedCreateWithoutPurchaseReturnsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutPurchaseReturnsInput
    upsert?: CompanyUpsertWithoutPurchaseReturnsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutPurchaseReturnsInput, CompanyUpdateWithoutPurchaseReturnsInput>, CompanyUncheckedUpdateWithoutPurchaseReturnsInput>
  }

  export type PurchaseReturnItemUpdateManyWithoutReturnNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutReturnInput, PurchaseReturnItemUncheckedCreateWithoutReturnInput> | PurchaseReturnItemCreateWithoutReturnInput[] | PurchaseReturnItemUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutReturnInput | PurchaseReturnItemCreateOrConnectWithoutReturnInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutReturnInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutReturnInput[]
    createMany?: PurchaseReturnItemCreateManyReturnInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutReturnInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutReturnInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutReturnInput | PurchaseReturnItemUpdateManyWithWhereWithoutReturnInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutReturnNestedInput = {
    create?: XOR<PurchaseReturnItemCreateWithoutReturnInput, PurchaseReturnItemUncheckedCreateWithoutReturnInput> | PurchaseReturnItemCreateWithoutReturnInput[] | PurchaseReturnItemUncheckedCreateWithoutReturnInput[]
    connectOrCreate?: PurchaseReturnItemCreateOrConnectWithoutReturnInput | PurchaseReturnItemCreateOrConnectWithoutReturnInput[]
    upsert?: PurchaseReturnItemUpsertWithWhereUniqueWithoutReturnInput | PurchaseReturnItemUpsertWithWhereUniqueWithoutReturnInput[]
    createMany?: PurchaseReturnItemCreateManyReturnInputEnvelope
    set?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    disconnect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    delete?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    connect?: PurchaseReturnItemWhereUniqueInput | PurchaseReturnItemWhereUniqueInput[]
    update?: PurchaseReturnItemUpdateWithWhereUniqueWithoutReturnInput | PurchaseReturnItemUpdateWithWhereUniqueWithoutReturnInput[]
    updateMany?: PurchaseReturnItemUpdateManyWithWhereWithoutReturnInput | PurchaseReturnItemUpdateManyWithWhereWithoutReturnInput[]
    deleteMany?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
  }

  export type PurchaseReturnCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseReturnCreateWithoutItemsInput, PurchaseReturnUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutItemsInput
    connect?: PurchaseReturnWhereUniqueInput
  }

  export type ItemMasterCreateNestedOneWithoutPurchaseReturnItemsInput = {
    create?: XOR<ItemMasterCreateWithoutPurchaseReturnItemsInput, ItemMasterUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPurchaseReturnItemsInput
    connect?: ItemMasterWhereUniqueInput
  }

  export type ColorCreateNestedOneWithoutPurchaseReturnItemsInput = {
    create?: XOR<ColorCreateWithoutPurchaseReturnItemsInput, ColorUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: ColorCreateOrConnectWithoutPurchaseReturnItemsInput
    connect?: ColorWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutPurchaseReturnItemsInput = {
    create?: XOR<BrandCreateWithoutPurchaseReturnItemsInput, BrandUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutPurchaseReturnItemsInput
    connect?: BrandWhereUniqueInput
  }

  export type ItemGradeCreateNestedOneWithoutPurchaseReturnItemsInput = {
    create?: XOR<ItemGradeCreateWithoutPurchaseReturnItemsInput, ItemGradeUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: ItemGradeCreateOrConnectWithoutPurchaseReturnItemsInput
    connect?: ItemGradeWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutPurchaseReturnItemsInput = {
    create?: XOR<UnitCreateWithoutPurchaseReturnItemsInput, UnitUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutPurchaseReturnItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseReturnCreateWithoutItemsInput, PurchaseReturnUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseReturnCreateOrConnectWithoutItemsInput
    upsert?: PurchaseReturnUpsertWithoutItemsInput
    connect?: PurchaseReturnWhereUniqueInput
    update?: XOR<XOR<PurchaseReturnUpdateToOneWithWhereWithoutItemsInput, PurchaseReturnUpdateWithoutItemsInput>, PurchaseReturnUncheckedUpdateWithoutItemsInput>
  }

  export type ItemMasterUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput = {
    create?: XOR<ItemMasterCreateWithoutPurchaseReturnItemsInput, ItemMasterUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: ItemMasterCreateOrConnectWithoutPurchaseReturnItemsInput
    upsert?: ItemMasterUpsertWithoutPurchaseReturnItemsInput
    connect?: ItemMasterWhereUniqueInput
    update?: XOR<XOR<ItemMasterUpdateToOneWithWhereWithoutPurchaseReturnItemsInput, ItemMasterUpdateWithoutPurchaseReturnItemsInput>, ItemMasterUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type ColorUpdateOneWithoutPurchaseReturnItemsNestedInput = {
    create?: XOR<ColorCreateWithoutPurchaseReturnItemsInput, ColorUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: ColorCreateOrConnectWithoutPurchaseReturnItemsInput
    upsert?: ColorUpsertWithoutPurchaseReturnItemsInput
    disconnect?: ColorWhereInput | boolean
    delete?: ColorWhereInput | boolean
    connect?: ColorWhereUniqueInput
    update?: XOR<XOR<ColorUpdateToOneWithWhereWithoutPurchaseReturnItemsInput, ColorUpdateWithoutPurchaseReturnItemsInput>, ColorUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type BrandUpdateOneWithoutPurchaseReturnItemsNestedInput = {
    create?: XOR<BrandCreateWithoutPurchaseReturnItemsInput, BrandUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutPurchaseReturnItemsInput
    upsert?: BrandUpsertWithoutPurchaseReturnItemsInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutPurchaseReturnItemsInput, BrandUpdateWithoutPurchaseReturnItemsInput>, BrandUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type ItemGradeUpdateOneWithoutPurchaseReturnItemsNestedInput = {
    create?: XOR<ItemGradeCreateWithoutPurchaseReturnItemsInput, ItemGradeUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: ItemGradeCreateOrConnectWithoutPurchaseReturnItemsInput
    upsert?: ItemGradeUpsertWithoutPurchaseReturnItemsInput
    disconnect?: ItemGradeWhereInput | boolean
    delete?: ItemGradeWhereInput | boolean
    connect?: ItemGradeWhereUniqueInput
    update?: XOR<XOR<ItemGradeUpdateToOneWithWhereWithoutPurchaseReturnItemsInput, ItemGradeUpdateWithoutPurchaseReturnItemsInput>, ItemGradeUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type UnitUpdateOneWithoutPurchaseReturnItemsNestedInput = {
    create?: XOR<UnitCreateWithoutPurchaseReturnItemsInput, UnitUncheckedCreateWithoutPurchaseReturnItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutPurchaseReturnItemsInput
    upsert?: UnitUpsertWithoutPurchaseReturnItemsInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutPurchaseReturnItemsInput, UnitUpdateWithoutPurchaseReturnItemsInput>, UnitUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumBalanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeFilter<$PrismaModel> | $Enums.BalanceType
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumBalanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BalanceType | EnumBalanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BalanceType[] | ListEnumBalanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBalanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.BalanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBalanceTypeFilter<$PrismaModel>
    _max?: NestedEnumBalanceTypeFilter<$PrismaModel>
  }

  export type NestedEnumVoucherTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeFilter<$PrismaModel> | $Enums.VoucherType
  }

  export type NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoucherType | EnumVoucherTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoucherType[] | ListEnumVoucherTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoucherTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoucherType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoucherTypeFilter<$PrismaModel>
    _max?: NestedEnumVoucherTypeFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderType | EnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderType[] | ListEnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderType[] | ListEnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderTypeFilter<$PrismaModel> | $Enums.PurchaseOrderType
  }

  export type NestedEnumPurchaseOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPurchaseOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderType | EnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderType[] | ListEnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderType[] | ListEnumPurchaseOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseOrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumPurchaseOrderTypeFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseOrderStatus | EnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseOrderStatus[] | ListEnumPurchaseOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseOrderStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPackingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PackingType | EnumPackingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PackingType[] | ListEnumPackingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PackingType[] | ListEnumPackingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPackingTypeNullableFilter<$PrismaModel> | $Enums.PackingType | null
  }

  export type NestedEnumPackingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PackingType | EnumPackingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PackingType[] | ListEnumPackingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PackingType[] | ListEnumPackingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPackingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PackingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPackingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPackingTypeNullableFilter<$PrismaModel>
  }

  export type PostCreateWithoutAuthorInput = {
    title: string
    content?: string | null
    published?: boolean
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: number
    title: string
    content?: string | null
    published?: boolean
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    module: string
    resourceId?: string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    module: string
    resourceId?: string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutUsersInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateOrConnectWithoutUsersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
  }

  export type AuditAccessCreateWithoutSeniorInput = {
    junior: UserCreateNestedOneWithoutVisibleToAuditInput
  }

  export type AuditAccessUncheckedCreateWithoutSeniorInput = {
    id?: number
    juniorId: number
  }

  export type AuditAccessCreateOrConnectWithoutSeniorInput = {
    where: AuditAccessWhereUniqueInput
    create: XOR<AuditAccessCreateWithoutSeniorInput, AuditAccessUncheckedCreateWithoutSeniorInput>
  }

  export type AuditAccessCreateManySeniorInputEnvelope = {
    data: AuditAccessCreateManySeniorInput | AuditAccessCreateManySeniorInput[]
    skipDuplicates?: boolean
  }

  export type AuditAccessCreateWithoutJuniorInput = {
    senior: UserCreateNestedOneWithoutAuditLogPermissionsInput
  }

  export type AuditAccessUncheckedCreateWithoutJuniorInput = {
    id?: number
    seniorId: number
  }

  export type AuditAccessCreateOrConnectWithoutJuniorInput = {
    where: AuditAccessWhereUniqueInput
    create: XOR<AuditAccessCreateWithoutJuniorInput, AuditAccessUncheckedCreateWithoutJuniorInput>
  }

  export type AuditAccessCreateManyJuniorInputEnvelope = {
    data: AuditAccessCreateManyJuniorInput | AuditAccessCreateManyJuniorInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUserInput = {
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: number
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserWarehouseCreateWithoutUserInput = {
    assignedAt?: Date | string
    warehouse: WarehouseCreateNestedOneWithoutUserWarehousesInput
  }

  export type UserWarehouseUncheckedCreateWithoutUserInput = {
    warehouseId: number
    assignedAt?: Date | string
  }

  export type UserWarehouseCreateOrConnectWithoutUserInput = {
    where: UserWarehouseWhereUniqueInput
    create: XOR<UserWarehouseCreateWithoutUserInput, UserWarehouseUncheckedCreateWithoutUserInput>
  }

  export type UserWarehouseCreateManyUserInputEnvelope = {
    data: UserWarehouseCreateManyUserInput | UserWarehouseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    published?: BoolFilter<"Post"> | boolean
    authorId?: IntFilter<"Post"> | number
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: IntFilter<"AuditLog"> | number
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    before?: JsonNullableFilter<"AuditLog">
    after?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DepartmentUpsertWithoutUsersInput = {
    update: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUsersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAccessUpsertWithWhereUniqueWithoutSeniorInput = {
    where: AuditAccessWhereUniqueInput
    update: XOR<AuditAccessUpdateWithoutSeniorInput, AuditAccessUncheckedUpdateWithoutSeniorInput>
    create: XOR<AuditAccessCreateWithoutSeniorInput, AuditAccessUncheckedCreateWithoutSeniorInput>
  }

  export type AuditAccessUpdateWithWhereUniqueWithoutSeniorInput = {
    where: AuditAccessWhereUniqueInput
    data: XOR<AuditAccessUpdateWithoutSeniorInput, AuditAccessUncheckedUpdateWithoutSeniorInput>
  }

  export type AuditAccessUpdateManyWithWhereWithoutSeniorInput = {
    where: AuditAccessScalarWhereInput
    data: XOR<AuditAccessUpdateManyMutationInput, AuditAccessUncheckedUpdateManyWithoutSeniorInput>
  }

  export type AuditAccessScalarWhereInput = {
    AND?: AuditAccessScalarWhereInput | AuditAccessScalarWhereInput[]
    OR?: AuditAccessScalarWhereInput[]
    NOT?: AuditAccessScalarWhereInput | AuditAccessScalarWhereInput[]
    id?: IntFilter<"AuditAccess"> | number
    seniorId?: IntFilter<"AuditAccess"> | number
    juniorId?: IntFilter<"AuditAccess"> | number
  }

  export type AuditAccessUpsertWithWhereUniqueWithoutJuniorInput = {
    where: AuditAccessWhereUniqueInput
    update: XOR<AuditAccessUpdateWithoutJuniorInput, AuditAccessUncheckedUpdateWithoutJuniorInput>
    create: XOR<AuditAccessCreateWithoutJuniorInput, AuditAccessUncheckedCreateWithoutJuniorInput>
  }

  export type AuditAccessUpdateWithWhereUniqueWithoutJuniorInput = {
    where: AuditAccessWhereUniqueInput
    data: XOR<AuditAccessUpdateWithoutJuniorInput, AuditAccessUncheckedUpdateWithoutJuniorInput>
  }

  export type AuditAccessUpdateManyWithWhereWithoutJuniorInput = {
    where: AuditAccessScalarWhereInput
    data: XOR<AuditAccessUpdateManyMutationInput, AuditAccessUncheckedUpdateManyWithoutJuniorInput>
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    assignedAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type UserWarehouseUpsertWithWhereUniqueWithoutUserInput = {
    where: UserWarehouseWhereUniqueInput
    update: XOR<UserWarehouseUpdateWithoutUserInput, UserWarehouseUncheckedUpdateWithoutUserInput>
    create: XOR<UserWarehouseCreateWithoutUserInput, UserWarehouseUncheckedCreateWithoutUserInput>
  }

  export type UserWarehouseUpdateWithWhereUniqueWithoutUserInput = {
    where: UserWarehouseWhereUniqueInput
    data: XOR<UserWarehouseUpdateWithoutUserInput, UserWarehouseUncheckedUpdateWithoutUserInput>
  }

  export type UserWarehouseUpdateManyWithWhereWithoutUserInput = {
    where: UserWarehouseScalarWhereInput
    data: XOR<UserWarehouseUpdateManyMutationInput, UserWarehouseUncheckedUpdateManyWithoutUserInput>
  }

  export type UserWarehouseScalarWhereInput = {
    AND?: UserWarehouseScalarWhereInput | UserWarehouseScalarWhereInput[]
    OR?: UserWarehouseScalarWhereInput[]
    NOT?: UserWarehouseScalarWhereInput | UserWarehouseScalarWhereInput[]
    userId?: IntFilter<"UserWarehouse"> | number
    warehouseId?: IntFilter<"UserWarehouse"> | number
    assignedAt?: DateTimeFilter<"UserWarehouse"> | Date | string
  }

  export type UserCreateWithoutAuditLogPermissionsInput = {
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    posts?: PostCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    visibleToAudit?: AuditAccessCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogPermissionsInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    visibleToAudit?: AuditAccessUncheckedCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogPermissionsInput, UserUncheckedCreateWithoutAuditLogPermissionsInput>
  }

  export type UserCreateWithoutVisibleToAuditInput = {
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    posts?: PostCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    auditLogPermissions?: AuditAccessCreateNestedManyWithoutSeniorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVisibleToAuditInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    auditLogPermissions?: AuditAccessUncheckedCreateNestedManyWithoutSeniorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVisibleToAuditInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVisibleToAuditInput, UserUncheckedCreateWithoutVisibleToAuditInput>
  }

  export type UserUpsertWithoutAuditLogPermissionsInput = {
    update: XOR<UserUpdateWithoutAuditLogPermissionsInput, UserUncheckedUpdateWithoutAuditLogPermissionsInput>
    create: XOR<UserCreateWithoutAuditLogPermissionsInput, UserUncheckedCreateWithoutAuditLogPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogPermissionsInput, UserUncheckedUpdateWithoutAuditLogPermissionsInput>
  }

  export type UserUpdateWithoutAuditLogPermissionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    visibleToAudit?: AuditAccessUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    visibleToAudit?: AuditAccessUncheckedUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutVisibleToAuditInput = {
    update: XOR<UserUpdateWithoutVisibleToAuditInput, UserUncheckedUpdateWithoutVisibleToAuditInput>
    create: XOR<UserCreateWithoutVisibleToAuditInput, UserUncheckedCreateWithoutVisibleToAuditInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVisibleToAuditInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVisibleToAuditInput, UserUncheckedUpdateWithoutVisibleToAuditInput>
  }

  export type UserUpdateWithoutVisibleToAuditInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    auditLogPermissions?: AuditAccessUpdateManyWithoutSeniorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVisibleToAuditInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    auditLogPermissions?: AuditAccessUncheckedUpdateManyWithoutSeniorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDepartmentInput = {
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    posts?: PostCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    auditLogPermissions?: AuditAccessCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepartmentInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    auditLogPermissions?: AuditAccessUncheckedCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessUncheckedCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserCreateManyDepartmentInputEnvelope = {
    data: UserCreateManyDepartmentInput | UserCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
  }

  export type UserUpdateManyWithWhereWithoutDepartmentInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstLogin?: BoolFilter<"User"> | boolean
    forcePasswordChange?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    departmentId?: IntNullableFilter<"User"> | number | null
  }

  export type UserRoleCreateWithoutRoleInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: number
    assignedAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionCreateWithoutRoleInput = {
    assignedAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    permissionId: number
    assignedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    roleId?: IntFilter<"RolePermission"> | number
    permissionId?: IntFilter<"RolePermission"> | number
    assignedAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    assignedAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    roleId: number
    assignedAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    action: string
    resource: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: number
    action: string
    resource: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutUserRolesInput = {
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    posts?: PostCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    auditLogPermissions?: AuditAccessCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessCreateNestedManyWithoutJuniorInput
    userWarehouses?: UserWarehouseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    auditLogPermissions?: AuditAccessUncheckedCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessUncheckedCreateNestedManyWithoutJuniorInput
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RoleCreateWithoutUserRolesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUserRolesInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUserRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    auditLogPermissions?: AuditAccessUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUpdateManyWithoutJuniorNestedInput
    userWarehouses?: UserWarehouseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    auditLogPermissions?: AuditAccessUncheckedUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUncheckedUpdateManyWithoutJuniorNestedInput
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUserRolesInput = {
    update: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RoleCreateWithoutUserRolesInput, RoleUncheckedCreateWithoutUserRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUserRolesInput, RoleUncheckedUpdateWithoutUserRolesInput>
  }

  export type RoleUpdateWithoutUserRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUserRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserCreateWithoutPostsInput = {
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    auditLogPermissions?: AuditAccessCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: number | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    auditLogPermissions?: AuditAccessUncheckedCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessUncheckedCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    auditLogPermissions?: AuditAccessUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    auditLogPermissions?: AuditAccessUncheckedUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUncheckedUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    posts?: PostCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    auditLogPermissions?: AuditAccessCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    auditLogPermissions?: AuditAccessUncheckedCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessUncheckedCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    auditLogPermissions?: AuditAccessUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    auditLogPermissions?: AuditAccessUncheckedUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUncheckedUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    posts?: PostCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    auditLogPermissions?: AuditAccessCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogPermissions?: AuditAccessUncheckedCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessUncheckedCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    auditLogPermissions?: AuditAccessUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogPermissions?: AuditAccessUncheckedUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUncheckedUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserWarehouseCreateWithoutWarehouseInput = {
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutUserWarehousesInput
  }

  export type UserWarehouseUncheckedCreateWithoutWarehouseInput = {
    userId: number
    assignedAt?: Date | string
  }

  export type UserWarehouseCreateOrConnectWithoutWarehouseInput = {
    where: UserWarehouseWhereUniqueInput
    create: XOR<UserWarehouseCreateWithoutWarehouseInput, UserWarehouseUncheckedCreateWithoutWarehouseInput>
  }

  export type UserWarehouseCreateManyWarehouseInputEnvelope = {
    data: UserWarehouseCreateManyWarehouseInput | UserWarehouseCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutWarehouseInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutPurchaseOrdersInput
    currency?: CurrencyCreateNestedOneWithoutPurchaseOrdersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutWarehouseInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutWarehouseInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput>
  }

  export type PurchaseOrderCreateManyWarehouseInputEnvelope = {
    data: PurchaseOrderCreateManyWarehouseInput | PurchaseOrderCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type UserWarehouseUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: UserWarehouseWhereUniqueInput
    update: XOR<UserWarehouseUpdateWithoutWarehouseInput, UserWarehouseUncheckedUpdateWithoutWarehouseInput>
    create: XOR<UserWarehouseCreateWithoutWarehouseInput, UserWarehouseUncheckedCreateWithoutWarehouseInput>
  }

  export type UserWarehouseUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: UserWarehouseWhereUniqueInput
    data: XOR<UserWarehouseUpdateWithoutWarehouseInput, UserWarehouseUncheckedUpdateWithoutWarehouseInput>
  }

  export type UserWarehouseUpdateManyWithWhereWithoutWarehouseInput = {
    where: UserWarehouseScalarWhereInput
    data: XOR<UserWarehouseUpdateManyMutationInput, UserWarehouseUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutWarehouseInput, PurchaseOrderUncheckedUpdateWithoutWarehouseInput>
    create: XOR<PurchaseOrderCreateWithoutWarehouseInput, PurchaseOrderUncheckedCreateWithoutWarehouseInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutWarehouseInput, PurchaseOrderUncheckedUpdateWithoutWarehouseInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutWarehouseInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    poNumber?: StringFilter<"PurchaseOrder"> | string
    type?: EnumPurchaseOrderTypeFilter<"PurchaseOrder"> | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFilter<"PurchaseOrder"> | $Enums.PurchaseOrderStatus
    date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    accountId?: IntNullableFilter<"PurchaseOrder"> | number | null
    partyName?: StringNullableFilter<"PurchaseOrder"> | string | null
    warehouseId?: IntNullableFilter<"PurchaseOrder"> | number | null
    referenceNo?: StringNullableFilter<"PurchaseOrder"> | string | null
    documentDate?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    fileNo?: StringNullableFilter<"PurchaseOrder"> | string | null
    remarks?: StringNullableFilter<"PurchaseOrder"> | string | null
    totalAmount?: FloatFilter<"PurchaseOrder"> | number
    currencyId?: IntNullableFilter<"PurchaseOrder"> | number | null
    exchangeRate?: FloatFilter<"PurchaseOrder"> | number
    companyId?: IntFilter<"PurchaseOrder"> | number
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type UserCreateWithoutUserWarehousesInput = {
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    posts?: PostCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    auditLogPermissions?: AuditAccessCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserWarehousesInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
    departmentId?: number | null
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    auditLogPermissions?: AuditAccessUncheckedCreateNestedManyWithoutSeniorInput
    visibleToAudit?: AuditAccessUncheckedCreateNestedManyWithoutJuniorInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserWarehousesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserWarehousesInput, UserUncheckedCreateWithoutUserWarehousesInput>
  }

  export type WarehouseCreateWithoutUserWarehousesInput = {
    name: string
    location?: string | null
    contactPerson?: string | null
    contactNumbers?: WarehouseCreatecontactNumbersInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutUserWarehousesInput = {
    id?: number
    name: string
    location?: string | null
    contactPerson?: string | null
    contactNumbers?: WarehouseCreatecontactNumbersInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutUserWarehousesInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutUserWarehousesInput, WarehouseUncheckedCreateWithoutUserWarehousesInput>
  }

  export type UserUpsertWithoutUserWarehousesInput = {
    update: XOR<UserUpdateWithoutUserWarehousesInput, UserUncheckedUpdateWithoutUserWarehousesInput>
    create: XOR<UserCreateWithoutUserWarehousesInput, UserUncheckedCreateWithoutUserWarehousesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserWarehousesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserWarehousesInput, UserUncheckedUpdateWithoutUserWarehousesInput>
  }

  export type UserUpdateWithoutUserWarehousesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    auditLogPermissions?: AuditAccessUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserWarehousesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    auditLogPermissions?: AuditAccessUncheckedUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUncheckedUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WarehouseUpsertWithoutUserWarehousesInput = {
    update: XOR<WarehouseUpdateWithoutUserWarehousesInput, WarehouseUncheckedUpdateWithoutUserWarehousesInput>
    create: XOR<WarehouseCreateWithoutUserWarehousesInput, WarehouseUncheckedCreateWithoutUserWarehousesInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutUserWarehousesInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutUserWarehousesInput, WarehouseUncheckedUpdateWithoutUserWarehousesInput>
  }

  export type WarehouseUpdateWithoutUserWarehousesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumbers?: WarehouseUpdatecontactNumbersInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutUserWarehousesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumbers?: WarehouseUpdatecontactNumbersInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type CompanyCreateWithoutUnitsInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUnitsInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUnitsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUnitsInput, CompanyUncheckedCreateWithoutUnitsInput>
  }

  export type UnitConversionCreateWithoutFromUnitInput = {
    conversionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitConversionsInput
    toUnit: UnitCreateNestedOneWithoutConversionsToInput
  }

  export type UnitConversionUncheckedCreateWithoutFromUnitInput = {
    id?: number
    toUnitId: number
    conversionRate: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitConversionCreateOrConnectWithoutFromUnitInput = {
    where: UnitConversionWhereUniqueInput
    create: XOR<UnitConversionCreateWithoutFromUnitInput, UnitConversionUncheckedCreateWithoutFromUnitInput>
  }

  export type UnitConversionCreateManyFromUnitInputEnvelope = {
    data: UnitConversionCreateManyFromUnitInput | UnitConversionCreateManyFromUnitInput[]
    skipDuplicates?: boolean
  }

  export type UnitConversionCreateWithoutToUnitInput = {
    conversionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitConversionsInput
    fromUnit: UnitCreateNestedOneWithoutConversionsFromInput
  }

  export type UnitConversionUncheckedCreateWithoutToUnitInput = {
    id?: number
    fromUnitId: number
    conversionRate: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitConversionCreateOrConnectWithoutToUnitInput = {
    where: UnitConversionWhereUniqueInput
    create: XOR<UnitConversionCreateWithoutToUnitInput, UnitConversionUncheckedCreateWithoutToUnitInput>
  }

  export type UnitConversionCreateManyToUnitInputEnvelope = {
    data: UnitConversionCreateManyToUnitInput | UnitConversionCreateManyToUnitInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUnitInput = {
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    variants?: VariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUnitInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUnitInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput>
  }

  export type ProductCreateManyUnitInputEnvelope = {
    data: ProductCreateManyUnitInput | ProductCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ItemMasterCreateWithoutBaseUnitInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroup: ItemGroupCreateNestedOneWithoutItemMastersInput
    packingUnit?: PackingUnitCreateNestedOneWithoutItemMastersInput
    company: CompanyCreateNestedOneWithoutItemMastersInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUncheckedCreateWithoutBaseUnitInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterCreateOrConnectWithoutBaseUnitInput = {
    where: ItemMasterWhereUniqueInput
    create: XOR<ItemMasterCreateWithoutBaseUnitInput, ItemMasterUncheckedCreateWithoutBaseUnitInput>
  }

  export type ItemMasterCreateManyBaseUnitInputEnvelope = {
    data: ItemMasterCreateManyBaseUnitInput | ItemMasterCreateManyBaseUnitInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderItemCreateWithoutUnitInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseOrderItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseOrderItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput
    grnItems?: GRNItemCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutUnitInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemCreateOrConnectWithoutUnitInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutUnitInput, PurchaseOrderItemUncheckedCreateWithoutUnitInput>
  }

  export type PurchaseOrderItemCreateManyUnitInputEnvelope = {
    data: PurchaseOrderItemCreateManyUnitInput | PurchaseOrderItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type GRNItemCreateWithoutUnitInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grn: GRNCreateNestedOneWithoutItemsInput
    purchaseOrderItem: PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutGrnItemsInput
    color?: ColorCreateNestedOneWithoutGrnItemsInput
    brand?: BrandCreateNestedOneWithoutGrnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutGrnItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutGrnItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUncheckedCreateWithoutUnitInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemCreateOrConnectWithoutUnitInput = {
    where: GRNItemWhereUniqueInput
    create: XOR<GRNItemCreateWithoutUnitInput, GRNItemUncheckedCreateWithoutUnitInput>
  }

  export type GRNItemCreateManyUnitInputEnvelope = {
    data: GRNItemCreateManyUnitInput | GRNItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceItemCreateWithoutUnitInput = {
    id?: string
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
    purchaseOrderItem?: PurchaseOrderItemCreateNestedOneWithoutInvoiceItemsInput
    grnItem?: GRNItemCreateNestedOneWithoutInvoiceItemsInput
    itemMaster?: ItemMasterCreateNestedOneWithoutPurchaseInvoiceItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseInvoiceItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseInvoiceItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseInvoiceItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutUnitInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutUnitInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutUnitInput, PurchaseInvoiceItemUncheckedCreateWithoutUnitInput>
  }

  export type PurchaseInvoiceItemCreateManyUnitInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyUnitInput | PurchaseInvoiceItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnItemCreateWithoutUnitInput = {
    id?: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    return: PurchaseReturnCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseReturnItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseReturnItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseReturnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseReturnItemsInput
  }

  export type PurchaseReturnItemUncheckedCreateWithoutUnitInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateOrConnectWithoutUnitInput = {
    where: PurchaseReturnItemWhereUniqueInput
    create: XOR<PurchaseReturnItemCreateWithoutUnitInput, PurchaseReturnItemUncheckedCreateWithoutUnitInput>
  }

  export type PurchaseReturnItemCreateManyUnitInputEnvelope = {
    data: PurchaseReturnItemCreateManyUnitInput | PurchaseReturnItemCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutUnitsInput = {
    update: XOR<CompanyUpdateWithoutUnitsInput, CompanyUncheckedUpdateWithoutUnitsInput>
    create: XOR<CompanyCreateWithoutUnitsInput, CompanyUncheckedCreateWithoutUnitsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUnitsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUnitsInput, CompanyUncheckedUpdateWithoutUnitsInput>
  }

  export type CompanyUpdateWithoutUnitsInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UnitConversionUpsertWithWhereUniqueWithoutFromUnitInput = {
    where: UnitConversionWhereUniqueInput
    update: XOR<UnitConversionUpdateWithoutFromUnitInput, UnitConversionUncheckedUpdateWithoutFromUnitInput>
    create: XOR<UnitConversionCreateWithoutFromUnitInput, UnitConversionUncheckedCreateWithoutFromUnitInput>
  }

  export type UnitConversionUpdateWithWhereUniqueWithoutFromUnitInput = {
    where: UnitConversionWhereUniqueInput
    data: XOR<UnitConversionUpdateWithoutFromUnitInput, UnitConversionUncheckedUpdateWithoutFromUnitInput>
  }

  export type UnitConversionUpdateManyWithWhereWithoutFromUnitInput = {
    where: UnitConversionScalarWhereInput
    data: XOR<UnitConversionUpdateManyMutationInput, UnitConversionUncheckedUpdateManyWithoutFromUnitInput>
  }

  export type UnitConversionScalarWhereInput = {
    AND?: UnitConversionScalarWhereInput | UnitConversionScalarWhereInput[]
    OR?: UnitConversionScalarWhereInput[]
    NOT?: UnitConversionScalarWhereInput | UnitConversionScalarWhereInput[]
    id?: IntFilter<"UnitConversion"> | number
    fromUnitId?: IntFilter<"UnitConversion"> | number
    toUnitId?: IntFilter<"UnitConversion"> | number
    conversionRate?: FloatFilter<"UnitConversion"> | number
    companyId?: IntFilter<"UnitConversion"> | number
    createdAt?: DateTimeFilter<"UnitConversion"> | Date | string
    updatedAt?: DateTimeFilter<"UnitConversion"> | Date | string
  }

  export type UnitConversionUpsertWithWhereUniqueWithoutToUnitInput = {
    where: UnitConversionWhereUniqueInput
    update: XOR<UnitConversionUpdateWithoutToUnitInput, UnitConversionUncheckedUpdateWithoutToUnitInput>
    create: XOR<UnitConversionCreateWithoutToUnitInput, UnitConversionUncheckedCreateWithoutToUnitInput>
  }

  export type UnitConversionUpdateWithWhereUniqueWithoutToUnitInput = {
    where: UnitConversionWhereUniqueInput
    data: XOR<UnitConversionUpdateWithoutToUnitInput, UnitConversionUncheckedUpdateWithoutToUnitInput>
  }

  export type UnitConversionUpdateManyWithWhereWithoutToUnitInput = {
    where: UnitConversionScalarWhereInput
    data: XOR<UnitConversionUpdateManyMutationInput, UnitConversionUncheckedUpdateManyWithoutToUnitInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutUnitInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUnitInput, ProductUncheckedUpdateWithoutUnitInput>
    create: XOR<ProductCreateWithoutUnitInput, ProductUncheckedCreateWithoutUnitInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUnitInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUnitInput, ProductUncheckedUpdateWithoutUnitInput>
  }

  export type ProductUpdateManyWithWhereWithoutUnitInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUnitInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    categoryId?: IntFilter<"Product"> | number
    unitId?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ItemMasterUpsertWithWhereUniqueWithoutBaseUnitInput = {
    where: ItemMasterWhereUniqueInput
    update: XOR<ItemMasterUpdateWithoutBaseUnitInput, ItemMasterUncheckedUpdateWithoutBaseUnitInput>
    create: XOR<ItemMasterCreateWithoutBaseUnitInput, ItemMasterUncheckedCreateWithoutBaseUnitInput>
  }

  export type ItemMasterUpdateWithWhereUniqueWithoutBaseUnitInput = {
    where: ItemMasterWhereUniqueInput
    data: XOR<ItemMasterUpdateWithoutBaseUnitInput, ItemMasterUncheckedUpdateWithoutBaseUnitInput>
  }

  export type ItemMasterUpdateManyWithWhereWithoutBaseUnitInput = {
    where: ItemMasterScalarWhereInput
    data: XOR<ItemMasterUpdateManyMutationInput, ItemMasterUncheckedUpdateManyWithoutBaseUnitInput>
  }

  export type ItemMasterScalarWhereInput = {
    AND?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
    OR?: ItemMasterScalarWhereInput[]
    NOT?: ItemMasterScalarWhereInput | ItemMasterScalarWhereInput[]
    id?: StringFilter<"ItemMaster"> | string
    code?: StringFilter<"ItemMaster"> | string
    name?: StringFilter<"ItemMaster"> | string
    shortDescription?: StringNullableFilter<"ItemMaster"> | string | null
    status?: StringFilter<"ItemMaster"> | string
    hsCode?: StringNullableFilter<"ItemMaster"> | string | null
    imageUrl?: StringNullableFilter<"ItemMaster"> | string | null
    itemGroupId?: StringFilter<"ItemMaster"> | string
    baseUnitId?: IntFilter<"ItemMaster"> | number
    packingUnitId?: StringNullableFilter<"ItemMaster"> | string | null
    companyId?: IntFilter<"ItemMaster"> | number
    createdAt?: DateTimeFilter<"ItemMaster"> | Date | string
    updatedAt?: DateTimeFilter<"ItemMaster"> | Date | string
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutUnitInput, PurchaseOrderItemUncheckedUpdateWithoutUnitInput>
    create: XOR<PurchaseOrderItemCreateWithoutUnitInput, PurchaseOrderItemUncheckedCreateWithoutUnitInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutUnitInput, PurchaseOrderItemUncheckedUpdateWithoutUnitInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutUnitInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type PurchaseOrderItemScalarWhereInput = {
    AND?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    OR?: PurchaseOrderItemScalarWhereInput[]
    NOT?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchaseOrderId?: StringFilter<"PurchaseOrderItem"> | string
    itemMasterId?: StringFilter<"PurchaseOrderItem"> | string
    colorId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    brandId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    itemGradeId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    packingUnitId?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    packingType?: EnumPackingTypeNullableFilter<"PurchaseOrderItem"> | $Enums.PackingType | null
    pcs?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    unitSize?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    quantity?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    unitId?: IntNullableFilter<"PurchaseOrderItem"> | number | null
    rate?: FloatFilter<"PurchaseOrderItem"> | number
    amount?: FloatFilter<"PurchaseOrderItem"> | number
    remarks?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
  }

  export type GRNItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: GRNItemWhereUniqueInput
    update: XOR<GRNItemUpdateWithoutUnitInput, GRNItemUncheckedUpdateWithoutUnitInput>
    create: XOR<GRNItemCreateWithoutUnitInput, GRNItemUncheckedCreateWithoutUnitInput>
  }

  export type GRNItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: GRNItemWhereUniqueInput
    data: XOR<GRNItemUpdateWithoutUnitInput, GRNItemUncheckedUpdateWithoutUnitInput>
  }

  export type GRNItemUpdateManyWithWhereWithoutUnitInput = {
    where: GRNItemScalarWhereInput
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type GRNItemScalarWhereInput = {
    AND?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
    OR?: GRNItemScalarWhereInput[]
    NOT?: GRNItemScalarWhereInput | GRNItemScalarWhereInput[]
    id?: StringFilter<"GRNItem"> | string
    grnId?: StringFilter<"GRNItem"> | string
    purchaseOrderItemId?: StringFilter<"GRNItem"> | string
    itemMasterId?: StringFilter<"GRNItem"> | string
    colorId?: StringNullableFilter<"GRNItem"> | string | null
    brandId?: StringNullableFilter<"GRNItem"> | string | null
    itemGradeId?: StringNullableFilter<"GRNItem"> | string | null
    packingUnitId?: StringNullableFilter<"GRNItem"> | string | null
    receivedQty?: FloatFilter<"GRNItem"> | number
    pcs?: FloatNullableFilter<"GRNItem"> | number | null
    unitSize?: FloatNullableFilter<"GRNItem"> | number | null
    packingType?: EnumPackingTypeNullableFilter<"GRNItem"> | $Enums.PackingType | null
    unitId?: IntNullableFilter<"GRNItem"> | number | null
    createdAt?: DateTimeFilter<"GRNItem"> | Date | string
    updatedAt?: DateTimeFilter<"GRNItem"> | Date | string
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutUnitInput, PurchaseInvoiceItemUncheckedUpdateWithoutUnitInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutUnitInput, PurchaseInvoiceItemUncheckedCreateWithoutUnitInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutUnitInput, PurchaseInvoiceItemUncheckedUpdateWithoutUnitInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutUnitInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type PurchaseInvoiceItemScalarWhereInput = {
    AND?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
    OR?: PurchaseInvoiceItemScalarWhereInput[]
    NOT?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
    id?: StringFilter<"PurchaseInvoiceItem"> | string
    invoiceId?: StringFilter<"PurchaseInvoiceItem"> | string
    purchaseOrderItemId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    grnItemId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    itemMasterId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    colorId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    brandId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    itemGradeId?: StringNullableFilter<"PurchaseInvoiceItem"> | string | null
    unitId?: IntNullableFilter<"PurchaseInvoiceItem"> | number | null
    invoicedQty?: FloatFilter<"PurchaseInvoiceItem"> | number
    rate?: FloatFilter<"PurchaseInvoiceItem"> | number
    amount?: FloatFilter<"PurchaseInvoiceItem"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
  }

  export type PurchaseReturnItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: PurchaseReturnItemWhereUniqueInput
    update: XOR<PurchaseReturnItemUpdateWithoutUnitInput, PurchaseReturnItemUncheckedUpdateWithoutUnitInput>
    create: XOR<PurchaseReturnItemCreateWithoutUnitInput, PurchaseReturnItemUncheckedCreateWithoutUnitInput>
  }

  export type PurchaseReturnItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: PurchaseReturnItemWhereUniqueInput
    data: XOR<PurchaseReturnItemUpdateWithoutUnitInput, PurchaseReturnItemUncheckedUpdateWithoutUnitInput>
  }

  export type PurchaseReturnItemUpdateManyWithWhereWithoutUnitInput = {
    where: PurchaseReturnItemScalarWhereInput
    data: XOR<PurchaseReturnItemUpdateManyMutationInput, PurchaseReturnItemUncheckedUpdateManyWithoutUnitInput>
  }

  export type PurchaseReturnItemScalarWhereInput = {
    AND?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
    OR?: PurchaseReturnItemScalarWhereInput[]
    NOT?: PurchaseReturnItemScalarWhereInput | PurchaseReturnItemScalarWhereInput[]
    id?: StringFilter<"PurchaseReturnItem"> | string
    returnId?: StringFilter<"PurchaseReturnItem"> | string
    purchaseInvoiceItemId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    grnItemId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    itemMasterId?: StringFilter<"PurchaseReturnItem"> | string
    colorId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    brandId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    itemGradeId?: StringNullableFilter<"PurchaseReturnItem"> | string | null
    unitId?: IntNullableFilter<"PurchaseReturnItem"> | number | null
    returnedQty?: FloatFilter<"PurchaseReturnItem"> | number
    rate?: FloatFilter<"PurchaseReturnItem"> | number
    amount?: FloatFilter<"PurchaseReturnItem"> | number
    createdAt?: DateTimeFilter<"PurchaseReturnItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturnItem"> | Date | string
  }

  export type CompanyCreateWithoutUnitConversionsInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUnitConversionsInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUnitConversionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUnitConversionsInput, CompanyUncheckedCreateWithoutUnitConversionsInput>
  }

  export type UnitCreateWithoutConversionsFromInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitsInput
    conversionsTo?: UnitConversionCreateNestedManyWithoutToUnitInput
    products?: ProductCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutConversionsFromInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsTo?: UnitConversionUncheckedCreateNestedManyWithoutToUnitInput
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutConversionsFromInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutConversionsFromInput, UnitUncheckedCreateWithoutConversionsFromInput>
  }

  export type UnitCreateWithoutConversionsToInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitsInput
    conversionsFrom?: UnitConversionCreateNestedManyWithoutFromUnitInput
    products?: ProductCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutConversionsToInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutConversionsToInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutConversionsToInput, UnitUncheckedCreateWithoutConversionsToInput>
  }

  export type CompanyUpsertWithoutUnitConversionsInput = {
    update: XOR<CompanyUpdateWithoutUnitConversionsInput, CompanyUncheckedUpdateWithoutUnitConversionsInput>
    create: XOR<CompanyCreateWithoutUnitConversionsInput, CompanyUncheckedCreateWithoutUnitConversionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUnitConversionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUnitConversionsInput, CompanyUncheckedUpdateWithoutUnitConversionsInput>
  }

  export type CompanyUpdateWithoutUnitConversionsInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUnitConversionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UnitUpsertWithoutConversionsFromInput = {
    update: XOR<UnitUpdateWithoutConversionsFromInput, UnitUncheckedUpdateWithoutConversionsFromInput>
    create: XOR<UnitCreateWithoutConversionsFromInput, UnitUncheckedCreateWithoutConversionsFromInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutConversionsFromInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutConversionsFromInput, UnitUncheckedUpdateWithoutConversionsFromInput>
  }

  export type UnitUpdateWithoutConversionsFromInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitsNestedInput
    conversionsTo?: UnitConversionUpdateManyWithoutToUnitNestedInput
    products?: ProductUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutConversionsFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsTo?: UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUpsertWithoutConversionsToInput = {
    update: XOR<UnitUpdateWithoutConversionsToInput, UnitUncheckedUpdateWithoutConversionsToInput>
    create: XOR<UnitCreateWithoutConversionsToInput, UnitUncheckedCreateWithoutConversionsToInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutConversionsToInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutConversionsToInput, UnitUncheckedUpdateWithoutConversionsToInput>
  }

  export type UnitUpdateWithoutConversionsToInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitsNestedInput
    conversionsFrom?: UnitConversionUpdateManyWithoutFromUnitNestedInput
    products?: ProductUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutConversionsToInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ItemGroupCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ItemGroupCreateNestedOneWithoutChildrenInput
    children?: ItemGroupCreateNestedManyWithoutParentInput
    itemMasters?: ItemMasterCreateNestedManyWithoutItemGroupInput
  }

  export type ItemGroupUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ItemGroupUncheckedCreateNestedManyWithoutParentInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutItemGroupInput
  }

  export type ItemGroupCreateOrConnectWithoutCompanyInput = {
    where: ItemGroupWhereUniqueInput
    create: XOR<ItemGroupCreateWithoutCompanyInput, ItemGroupUncheckedCreateWithoutCompanyInput>
  }

  export type ItemGroupCreateManyCompanyInputEnvelope = {
    data: ItemGroupCreateManyCompanyInput | ItemGroupCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ColorCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutColorInput
    grnItems?: GRNItemCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutColorInput
  }

  export type ColorUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutColorInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutColorInput
  }

  export type ColorCreateOrConnectWithoutCompanyInput = {
    where: ColorWhereUniqueInput
    create: XOR<ColorCreateWithoutCompanyInput, ColorUncheckedCreateWithoutCompanyInput>
  }

  export type ColorCreateManyCompanyInputEnvelope = {
    data: ColorCreateManyCompanyInput | ColorCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type BrandCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutBrandInput
    grnItems?: GRNItemCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutBrandInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutCompanyInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutCompanyInput, BrandUncheckedCreateWithoutCompanyInput>
  }

  export type BrandCreateManyCompanyInputEnvelope = {
    data: BrandCreateManyCompanyInput | BrandCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutCompanyInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionCreateNestedManyWithoutToUnitInput
    products?: ProductCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutCompanyInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionUncheckedCreateNestedManyWithoutToUnitInput
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutCompanyInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutCompanyInput, UnitUncheckedCreateWithoutCompanyInput>
  }

  export type UnitCreateManyCompanyInputEnvelope = {
    data: UnitCreateManyCompanyInput | UnitCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ItemGradeCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemGradeInput
    grnItems?: GRNItemCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemGradeInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeCreateOrConnectWithoutCompanyInput = {
    where: ItemGradeWhereUniqueInput
    create: XOR<ItemGradeCreateWithoutCompanyInput, ItemGradeUncheckedCreateWithoutCompanyInput>
  }

  export type ItemGradeCreateManyCompanyInputEnvelope = {
    data: ItemGradeCreateManyCompanyInput | ItemGradeCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UnitConversionCreateWithoutCompanyInput = {
    conversionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUnit: UnitCreateNestedOneWithoutConversionsFromInput
    toUnit: UnitCreateNestedOneWithoutConversionsToInput
  }

  export type UnitConversionUncheckedCreateWithoutCompanyInput = {
    id?: number
    fromUnitId: number
    toUnitId: number
    conversionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitConversionCreateOrConnectWithoutCompanyInput = {
    where: UnitConversionWhereUniqueInput
    create: XOR<UnitConversionCreateWithoutCompanyInput, UnitConversionUncheckedCreateWithoutCompanyInput>
  }

  export type UnitConversionCreateManyCompanyInputEnvelope = {
    data: UnitConversionCreateManyCompanyInput | UnitConversionCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ItemMasterCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroup: ItemGroupCreateNestedOneWithoutItemMastersInput
    baseUnit: UnitCreateNestedOneWithoutItemMastersInput
    packingUnit?: PackingUnitCreateNestedOneWithoutItemMastersInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    packingUnitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterCreateOrConnectWithoutCompanyInput = {
    where: ItemMasterWhereUniqueInput
    create: XOR<ItemMasterCreateWithoutCompanyInput, ItemMasterUncheckedCreateWithoutCompanyInput>
  }

  export type ItemMasterCreateManyCompanyInputEnvelope = {
    data: ItemMasterCreateManyCompanyInput | ItemMasterCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutCompanyInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutPurchaseOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    currency?: CurrencyCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutCompanyInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseOrderCreateManyCompanyInputEnvelope = {
    data: PurchaseOrderCreateManyCompanyInput | PurchaseOrderCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type GRNCreateWithoutCompanyInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutGrnsInput
    items?: GRNItemCreateNestedManyWithoutGrnInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutGrnInput
  }

  export type GRNUncheckedCreateWithoutCompanyInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    purchaseOrderId: string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: GRNItemUncheckedCreateNestedManyWithoutGrnInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutGrnInput
  }

  export type GRNCreateOrConnectWithoutCompanyInput = {
    where: GRNWhereUniqueInput
    create: XOR<GRNCreateWithoutCompanyInput, GRNUncheckedCreateWithoutCompanyInput>
  }

  export type GRNCreateManyCompanyInputEnvelope = {
    data: GRNCreateManyCompanyInput | GRNCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceCreateWithoutCompanyInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    account?: AccountCreateNestedOneWithoutPurchaseInvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutInvoiceInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutCompanyInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    purchaseOrderId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutCompanyInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseInvoiceCreateManyCompanyInputEnvelope = {
    data: PurchaseInvoiceCreateManyCompanyInput | PurchaseInvoiceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnCreateWithoutCompanyInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseInvoice?: PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnsInput
    grn?: GRNCreateNestedOneWithoutPurchaseReturnsInput
    account?: AccountCreateNestedOneWithoutPurchaseReturnsInput
    items?: PurchaseReturnItemCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnUncheckedCreateWithoutCompanyInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    purchaseInvoiceId?: string | null
    grnId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseReturnItemUncheckedCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnCreateOrConnectWithoutCompanyInput = {
    where: PurchaseReturnWhereUniqueInput
    create: XOR<PurchaseReturnCreateWithoutCompanyInput, PurchaseReturnUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseReturnCreateManyCompanyInputEnvelope = {
    data: PurchaseReturnCreateManyCompanyInput | PurchaseReturnCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type PackingUnitCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    itemMasters?: ItemMasterCreateNestedManyWithoutPackingUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutPackingUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitUncheckedCreateWithoutCompanyInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutPackingUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPackingUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitCreateOrConnectWithoutCompanyInput = {
    where: PackingUnitWhereUniqueInput
    create: XOR<PackingUnitCreateWithoutCompanyInput, PackingUnitUncheckedCreateWithoutCompanyInput>
  }

  export type PackingUnitCreateManyCompanyInputEnvelope = {
    data: PackingUnitCreateManyCompanyInput | PackingUnitCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ItemGroupUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ItemGroupWhereUniqueInput
    update: XOR<ItemGroupUpdateWithoutCompanyInput, ItemGroupUncheckedUpdateWithoutCompanyInput>
    create: XOR<ItemGroupCreateWithoutCompanyInput, ItemGroupUncheckedCreateWithoutCompanyInput>
  }

  export type ItemGroupUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ItemGroupWhereUniqueInput
    data: XOR<ItemGroupUpdateWithoutCompanyInput, ItemGroupUncheckedUpdateWithoutCompanyInput>
  }

  export type ItemGroupUpdateManyWithWhereWithoutCompanyInput = {
    where: ItemGroupScalarWhereInput
    data: XOR<ItemGroupUpdateManyMutationInput, ItemGroupUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ItemGroupScalarWhereInput = {
    AND?: ItemGroupScalarWhereInput | ItemGroupScalarWhereInput[]
    OR?: ItemGroupScalarWhereInput[]
    NOT?: ItemGroupScalarWhereInput | ItemGroupScalarWhereInput[]
    id?: StringFilter<"ItemGroup"> | string
    code?: StringFilter<"ItemGroup"> | string
    name?: StringFilter<"ItemGroup"> | string
    description?: StringNullableFilter<"ItemGroup"> | string | null
    status?: StringFilter<"ItemGroup"> | string
    parentId?: StringNullableFilter<"ItemGroup"> | string | null
    companyId?: IntFilter<"ItemGroup"> | number
    createdAt?: DateTimeFilter<"ItemGroup"> | Date | string
    updatedAt?: DateTimeFilter<"ItemGroup"> | Date | string
  }

  export type ColorUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ColorWhereUniqueInput
    update: XOR<ColorUpdateWithoutCompanyInput, ColorUncheckedUpdateWithoutCompanyInput>
    create: XOR<ColorCreateWithoutCompanyInput, ColorUncheckedCreateWithoutCompanyInput>
  }

  export type ColorUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ColorWhereUniqueInput
    data: XOR<ColorUpdateWithoutCompanyInput, ColorUncheckedUpdateWithoutCompanyInput>
  }

  export type ColorUpdateManyWithWhereWithoutCompanyInput = {
    where: ColorScalarWhereInput
    data: XOR<ColorUpdateManyMutationInput, ColorUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ColorScalarWhereInput = {
    AND?: ColorScalarWhereInput | ColorScalarWhereInput[]
    OR?: ColorScalarWhereInput[]
    NOT?: ColorScalarWhereInput | ColorScalarWhereInput[]
    id?: StringFilter<"Color"> | string
    code?: StringFilter<"Color"> | string
    name?: StringFilter<"Color"> | string
    pictureUrl?: StringNullableFilter<"Color"> | string | null
    status?: StringFilter<"Color"> | string
    companyId?: IntFilter<"Color"> | number
    createdAt?: DateTimeFilter<"Color"> | Date | string
    updatedAt?: DateTimeFilter<"Color"> | Date | string
  }

  export type BrandUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BrandWhereUniqueInput
    update: XOR<BrandUpdateWithoutCompanyInput, BrandUncheckedUpdateWithoutCompanyInput>
    create: XOR<BrandCreateWithoutCompanyInput, BrandUncheckedCreateWithoutCompanyInput>
  }

  export type BrandUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BrandWhereUniqueInput
    data: XOR<BrandUpdateWithoutCompanyInput, BrandUncheckedUpdateWithoutCompanyInput>
  }

  export type BrandUpdateManyWithWhereWithoutCompanyInput = {
    where: BrandScalarWhereInput
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyWithoutCompanyInput>
  }

  export type BrandScalarWhereInput = {
    AND?: BrandScalarWhereInput | BrandScalarWhereInput[]
    OR?: BrandScalarWhereInput[]
    NOT?: BrandScalarWhereInput | BrandScalarWhereInput[]
    id?: StringFilter<"Brand"> | string
    code?: StringFilter<"Brand"> | string
    name?: StringFilter<"Brand"> | string
    status?: StringFilter<"Brand"> | string
    companyId?: IntFilter<"Brand"> | number
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
  }

  export type UnitUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutCompanyInput, UnitUncheckedUpdateWithoutCompanyInput>
    create: XOR<UnitCreateWithoutCompanyInput, UnitUncheckedCreateWithoutCompanyInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutCompanyInput, UnitUncheckedUpdateWithoutCompanyInput>
  }

  export type UnitUpdateManyWithWhereWithoutCompanyInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    id?: IntFilter<"Unit"> | number
    code?: StringFilter<"Unit"> | string
    name?: StringFilter<"Unit"> | string
    symbol?: StringFilter<"Unit"> | string
    unitType?: StringFilter<"Unit"> | string
    isBase?: BoolFilter<"Unit"> | boolean
    status?: StringFilter<"Unit"> | string
    companyId?: IntFilter<"Unit"> | number
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
  }

  export type ItemGradeUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ItemGradeWhereUniqueInput
    update: XOR<ItemGradeUpdateWithoutCompanyInput, ItemGradeUncheckedUpdateWithoutCompanyInput>
    create: XOR<ItemGradeCreateWithoutCompanyInput, ItemGradeUncheckedCreateWithoutCompanyInput>
  }

  export type ItemGradeUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ItemGradeWhereUniqueInput
    data: XOR<ItemGradeUpdateWithoutCompanyInput, ItemGradeUncheckedUpdateWithoutCompanyInput>
  }

  export type ItemGradeUpdateManyWithWhereWithoutCompanyInput = {
    where: ItemGradeScalarWhereInput
    data: XOR<ItemGradeUpdateManyMutationInput, ItemGradeUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ItemGradeScalarWhereInput = {
    AND?: ItemGradeScalarWhereInput | ItemGradeScalarWhereInput[]
    OR?: ItemGradeScalarWhereInput[]
    NOT?: ItemGradeScalarWhereInput | ItemGradeScalarWhereInput[]
    id?: StringFilter<"ItemGrade"> | string
    code?: StringFilter<"ItemGrade"> | string
    name?: StringFilter<"ItemGrade"> | string
    status?: StringFilter<"ItemGrade"> | string
    companyId?: IntFilter<"ItemGrade"> | number
    createdAt?: DateTimeFilter<"ItemGrade"> | Date | string
    updatedAt?: DateTimeFilter<"ItemGrade"> | Date | string
  }

  export type UnitConversionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UnitConversionWhereUniqueInput
    update: XOR<UnitConversionUpdateWithoutCompanyInput, UnitConversionUncheckedUpdateWithoutCompanyInput>
    create: XOR<UnitConversionCreateWithoutCompanyInput, UnitConversionUncheckedCreateWithoutCompanyInput>
  }

  export type UnitConversionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UnitConversionWhereUniqueInput
    data: XOR<UnitConversionUpdateWithoutCompanyInput, UnitConversionUncheckedUpdateWithoutCompanyInput>
  }

  export type UnitConversionUpdateManyWithWhereWithoutCompanyInput = {
    where: UnitConversionScalarWhereInput
    data: XOR<UnitConversionUpdateManyMutationInput, UnitConversionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ItemMasterUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ItemMasterWhereUniqueInput
    update: XOR<ItemMasterUpdateWithoutCompanyInput, ItemMasterUncheckedUpdateWithoutCompanyInput>
    create: XOR<ItemMasterCreateWithoutCompanyInput, ItemMasterUncheckedCreateWithoutCompanyInput>
  }

  export type ItemMasterUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ItemMasterWhereUniqueInput
    data: XOR<ItemMasterUpdateWithoutCompanyInput, ItemMasterUncheckedUpdateWithoutCompanyInput>
  }

  export type ItemMasterUpdateManyWithWhereWithoutCompanyInput = {
    where: ItemMasterScalarWhereInput
    data: XOR<ItemMasterUpdateManyMutationInput, ItemMasterUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutCompanyInput, PurchaseOrderUncheckedUpdateWithoutCompanyInput>
    create: XOR<PurchaseOrderCreateWithoutCompanyInput, PurchaseOrderUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutCompanyInput, PurchaseOrderUncheckedUpdateWithoutCompanyInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutCompanyInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutCompanyInput>
  }

  export type GRNUpsertWithWhereUniqueWithoutCompanyInput = {
    where: GRNWhereUniqueInput
    update: XOR<GRNUpdateWithoutCompanyInput, GRNUncheckedUpdateWithoutCompanyInput>
    create: XOR<GRNCreateWithoutCompanyInput, GRNUncheckedCreateWithoutCompanyInput>
  }

  export type GRNUpdateWithWhereUniqueWithoutCompanyInput = {
    where: GRNWhereUniqueInput
    data: XOR<GRNUpdateWithoutCompanyInput, GRNUncheckedUpdateWithoutCompanyInput>
  }

  export type GRNUpdateManyWithWhereWithoutCompanyInput = {
    where: GRNScalarWhereInput
    data: XOR<GRNUpdateManyMutationInput, GRNUncheckedUpdateManyWithoutCompanyInput>
  }

  export type GRNScalarWhereInput = {
    AND?: GRNScalarWhereInput | GRNScalarWhereInput[]
    OR?: GRNScalarWhereInput[]
    NOT?: GRNScalarWhereInput | GRNScalarWhereInput[]
    id?: StringFilter<"GRN"> | string
    grnNumber?: StringFilter<"GRN"> | string
    date?: DateTimeFilter<"GRN"> | Date | string
    purchaseOrderId?: StringFilter<"GRN"> | string
    lotNo?: StringNullableFilter<"GRN"> | string | null
    warehouseRefNo?: StringNullableFilter<"GRN"> | string | null
    remarks?: StringNullableFilter<"GRN"> | string | null
    companyId?: IntFilter<"GRN"> | number
    createdAt?: DateTimeFilter<"GRN"> | Date | string
    updatedAt?: DateTimeFilter<"GRN"> | Date | string
  }

  export type PurchaseInvoiceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseInvoiceWhereUniqueInput
    update: XOR<PurchaseInvoiceUpdateWithoutCompanyInput, PurchaseInvoiceUncheckedUpdateWithoutCompanyInput>
    create: XOR<PurchaseInvoiceCreateWithoutCompanyInput, PurchaseInvoiceUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseInvoiceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseInvoiceWhereUniqueInput
    data: XOR<PurchaseInvoiceUpdateWithoutCompanyInput, PurchaseInvoiceUncheckedUpdateWithoutCompanyInput>
  }

  export type PurchaseInvoiceUpdateManyWithWhereWithoutCompanyInput = {
    where: PurchaseInvoiceScalarWhereInput
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PurchaseInvoiceScalarWhereInput = {
    AND?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    OR?: PurchaseInvoiceScalarWhereInput[]
    NOT?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    id?: StringFilter<"PurchaseInvoice"> | string
    invoiceNumber?: StringFilter<"PurchaseInvoice"> | string
    date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    supplierInvoiceNo?: StringNullableFilter<"PurchaseInvoice"> | string | null
    remarks?: StringNullableFilter<"PurchaseInvoice"> | string | null
    purchaseOrderId?: StringNullableFilter<"PurchaseInvoice"> | string | null
    accountId?: IntNullableFilter<"PurchaseInvoice"> | number | null
    totalAmount?: FloatFilter<"PurchaseInvoice"> | number
    status?: StringFilter<"PurchaseInvoice"> | string
    companyId?: IntFilter<"PurchaseInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
  }

  export type PurchaseReturnUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseReturnWhereUniqueInput
    update: XOR<PurchaseReturnUpdateWithoutCompanyInput, PurchaseReturnUncheckedUpdateWithoutCompanyInput>
    create: XOR<PurchaseReturnCreateWithoutCompanyInput, PurchaseReturnUncheckedCreateWithoutCompanyInput>
  }

  export type PurchaseReturnUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PurchaseReturnWhereUniqueInput
    data: XOR<PurchaseReturnUpdateWithoutCompanyInput, PurchaseReturnUncheckedUpdateWithoutCompanyInput>
  }

  export type PurchaseReturnUpdateManyWithWhereWithoutCompanyInput = {
    where: PurchaseReturnScalarWhereInput
    data: XOR<PurchaseReturnUpdateManyMutationInput, PurchaseReturnUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PurchaseReturnScalarWhereInput = {
    AND?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
    OR?: PurchaseReturnScalarWhereInput[]
    NOT?: PurchaseReturnScalarWhereInput | PurchaseReturnScalarWhereInput[]
    id?: StringFilter<"PurchaseReturn"> | string
    returnNumber?: StringFilter<"PurchaseReturn"> | string
    date?: DateTimeFilter<"PurchaseReturn"> | Date | string
    remarks?: StringNullableFilter<"PurchaseReturn"> | string | null
    purchaseInvoiceId?: StringNullableFilter<"PurchaseReturn"> | string | null
    grnId?: StringNullableFilter<"PurchaseReturn"> | string | null
    accountId?: IntNullableFilter<"PurchaseReturn"> | number | null
    totalAmount?: FloatFilter<"PurchaseReturn"> | number
    status?: StringFilter<"PurchaseReturn"> | string
    companyId?: IntFilter<"PurchaseReturn"> | number
    createdAt?: DateTimeFilter<"PurchaseReturn"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturn"> | Date | string
  }

  export type PackingUnitUpsertWithWhereUniqueWithoutCompanyInput = {
    where: PackingUnitWhereUniqueInput
    update: XOR<PackingUnitUpdateWithoutCompanyInput, PackingUnitUncheckedUpdateWithoutCompanyInput>
    create: XOR<PackingUnitCreateWithoutCompanyInput, PackingUnitUncheckedCreateWithoutCompanyInput>
  }

  export type PackingUnitUpdateWithWhereUniqueWithoutCompanyInput = {
    where: PackingUnitWhereUniqueInput
    data: XOR<PackingUnitUpdateWithoutCompanyInput, PackingUnitUncheckedUpdateWithoutCompanyInput>
  }

  export type PackingUnitUpdateManyWithWhereWithoutCompanyInput = {
    where: PackingUnitScalarWhereInput
    data: XOR<PackingUnitUpdateManyMutationInput, PackingUnitUncheckedUpdateManyWithoutCompanyInput>
  }

  export type PackingUnitScalarWhereInput = {
    AND?: PackingUnitScalarWhereInput | PackingUnitScalarWhereInput[]
    OR?: PackingUnitScalarWhereInput[]
    NOT?: PackingUnitScalarWhereInput | PackingUnitScalarWhereInput[]
    id?: StringFilter<"PackingUnit"> | string
    code?: StringFilter<"PackingUnit"> | string
    name?: StringFilter<"PackingUnit"> | string
    symbol?: StringNullableFilter<"PackingUnit"> | string | null
    status?: StringFilter<"PackingUnit"> | string
    companyId?: IntFilter<"PackingUnit"> | number
    createdAt?: DateTimeFilter<"PackingUnit"> | Date | string
    updatedAt?: DateTimeFilter<"PackingUnit"> | Date | string
  }

  export type JournalEntryCreateWithoutFiscalYearInput = {
    number: string
    date: Date | string
    type: $Enums.VoucherType
    reference?: string | null
    narration?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: JournalLineCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryUncheckedCreateWithoutFiscalYearInput = {
    id?: number
    number: string
    date: Date | string
    type: $Enums.VoucherType
    reference?: string | null
    narration?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: JournalLineUncheckedCreateNestedManyWithoutEntryInput
  }

  export type JournalEntryCreateOrConnectWithoutFiscalYearInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput>
  }

  export type JournalEntryCreateManyFiscalYearInputEnvelope = {
    data: JournalEntryCreateManyFiscalYearInput | JournalEntryCreateManyFiscalYearInput[]
    skipDuplicates?: boolean
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutFiscalYearInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutFiscalYearInput, JournalEntryUncheckedUpdateWithoutFiscalYearInput>
    create: XOR<JournalEntryCreateWithoutFiscalYearInput, JournalEntryUncheckedCreateWithoutFiscalYearInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutFiscalYearInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutFiscalYearInput, JournalEntryUncheckedUpdateWithoutFiscalYearInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutFiscalYearInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutFiscalYearInput>
  }

  export type JournalEntryScalarWhereInput = {
    AND?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    OR?: JournalEntryScalarWhereInput[]
    NOT?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    id?: IntFilter<"JournalEntry"> | number
    number?: StringFilter<"JournalEntry"> | string
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    type?: EnumVoucherTypeFilter<"JournalEntry"> | $Enums.VoucherType
    reference?: StringNullableFilter<"JournalEntry"> | string | null
    narration?: StringNullableFilter<"JournalEntry"> | string | null
    status?: BoolFilter<"JournalEntry"> | boolean
    fiscalYearId?: IntNullableFilter<"JournalEntry"> | number | null
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
  }

  export type PurchaseOrderCreateWithoutCurrencyInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutPurchaseOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutCurrencyInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutCurrencyInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutCurrencyInput, PurchaseOrderUncheckedCreateWithoutCurrencyInput>
  }

  export type PurchaseOrderCreateManyCurrencyInputEnvelope = {
    data: PurchaseOrderCreateManyCurrencyInput | PurchaseOrderCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutCurrencyInput, PurchaseOrderUncheckedUpdateWithoutCurrencyInput>
    create: XOR<PurchaseOrderCreateWithoutCurrencyInput, PurchaseOrderUncheckedCreateWithoutCurrencyInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutCurrencyInput, PurchaseOrderUncheckedUpdateWithoutCurrencyInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutCurrencyInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type ProductCreateWithoutCategoryInput = {
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    unit: UnitCreateNestedOneWithoutProductsInput
    variants?: VariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    unitId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type UnitCreateWithoutProductsInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitsInput
    conversionsFrom?: UnitConversionCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionCreateNestedManyWithoutToUnitInput
    itemMasters?: ItemMasterCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutProductsInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionUncheckedCreateNestedManyWithoutToUnitInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutProductsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutProductsInput, UnitUncheckedCreateWithoutProductsInput>
  }

  export type VariantCreateWithoutProductInput = {
    name: string
    sku: string
    color?: string | null
    count?: string | null
    gsm?: string | null
    width?: string | null
    shade?: string | null
    weave?: string | null
    finish?: string | null
    type?: string | null
    price?: number | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariantUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
    sku: string
    color?: string | null
    count?: string | null
    gsm?: string | null
    width?: string | null
    shade?: string | null
    weave?: string | null
    finish?: string | null
    type?: string | null
    price?: number | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariantCreateOrConnectWithoutProductInput = {
    where: VariantWhereUniqueInput
    create: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput>
  }

  export type VariantCreateManyProductInputEnvelope = {
    data: VariantCreateManyProductInput | VariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpsertWithoutProductsInput = {
    update: XOR<UnitUpdateWithoutProductsInput, UnitUncheckedUpdateWithoutProductsInput>
    create: XOR<UnitCreateWithoutProductsInput, UnitUncheckedCreateWithoutProductsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutProductsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutProductsInput, UnitUncheckedUpdateWithoutProductsInput>
  }

  export type UnitUpdateWithoutProductsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitsNestedInput
    conversionsFrom?: UnitConversionUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUpdateManyWithoutToUnitNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type VariantUpsertWithWhereUniqueWithoutProductInput = {
    where: VariantWhereUniqueInput
    update: XOR<VariantUpdateWithoutProductInput, VariantUncheckedUpdateWithoutProductInput>
    create: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput>
  }

  export type VariantUpdateWithWhereUniqueWithoutProductInput = {
    where: VariantWhereUniqueInput
    data: XOR<VariantUpdateWithoutProductInput, VariantUncheckedUpdateWithoutProductInput>
  }

  export type VariantUpdateManyWithWhereWithoutProductInput = {
    where: VariantScalarWhereInput
    data: XOR<VariantUpdateManyMutationInput, VariantUncheckedUpdateManyWithoutProductInput>
  }

  export type VariantScalarWhereInput = {
    AND?: VariantScalarWhereInput | VariantScalarWhereInput[]
    OR?: VariantScalarWhereInput[]
    NOT?: VariantScalarWhereInput | VariantScalarWhereInput[]
    id?: IntFilter<"Variant"> | number
    name?: StringFilter<"Variant"> | string
    sku?: StringFilter<"Variant"> | string
    productId?: IntFilter<"Variant"> | number
    color?: StringNullableFilter<"Variant"> | string | null
    count?: StringNullableFilter<"Variant"> | string | null
    gsm?: StringNullableFilter<"Variant"> | string | null
    width?: StringNullableFilter<"Variant"> | string | null
    shade?: StringNullableFilter<"Variant"> | string | null
    weave?: StringNullableFilter<"Variant"> | string | null
    finish?: StringNullableFilter<"Variant"> | string | null
    type?: StringNullableFilter<"Variant"> | string | null
    price?: FloatNullableFilter<"Variant"> | number | null
    stock?: FloatNullableFilter<"Variant"> | number | null
    createdAt?: DateTimeFilter<"Variant"> | Date | string
    updatedAt?: DateTimeFilter<"Variant"> | Date | string
  }

  export type ProductCreateWithoutVariantsInput = {
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
    unit: UnitCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    categoryId: number
    unitId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    unit?: UnitUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateWithoutLocationInput = {
    name: string
    code: string
    type?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineUncheckedCreateWithoutLocationInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineCreateOrConnectWithoutLocationInput = {
    where: MachineWhereUniqueInput
    create: XOR<MachineCreateWithoutLocationInput, MachineUncheckedCreateWithoutLocationInput>
  }

  export type MachineCreateManyLocationInputEnvelope = {
    data: MachineCreateManyLocationInput | MachineCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type MachineUpsertWithWhereUniqueWithoutLocationInput = {
    where: MachineWhereUniqueInput
    update: XOR<MachineUpdateWithoutLocationInput, MachineUncheckedUpdateWithoutLocationInput>
    create: XOR<MachineCreateWithoutLocationInput, MachineUncheckedCreateWithoutLocationInput>
  }

  export type MachineUpdateWithWhereUniqueWithoutLocationInput = {
    where: MachineWhereUniqueInput
    data: XOR<MachineUpdateWithoutLocationInput, MachineUncheckedUpdateWithoutLocationInput>
  }

  export type MachineUpdateManyWithWhereWithoutLocationInput = {
    where: MachineScalarWhereInput
    data: XOR<MachineUpdateManyMutationInput, MachineUncheckedUpdateManyWithoutLocationInput>
  }

  export type MachineScalarWhereInput = {
    AND?: MachineScalarWhereInput | MachineScalarWhereInput[]
    OR?: MachineScalarWhereInput[]
    NOT?: MachineScalarWhereInput | MachineScalarWhereInput[]
    id?: IntFilter<"Machine"> | number
    name?: StringFilter<"Machine"> | string
    code?: StringFilter<"Machine"> | string
    type?: StringNullableFilter<"Machine"> | string | null
    status?: StringFilter<"Machine"> | string
    locationId?: IntNullableFilter<"Machine"> | number | null
    createdAt?: DateTimeFilter<"Machine"> | Date | string
    updatedAt?: DateTimeFilter<"Machine"> | Date | string
  }

  export type LocationCreateWithoutMachinesInput = {
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUncheckedCreateWithoutMachinesInput = {
    id?: number
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateOrConnectWithoutMachinesInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutMachinesInput, LocationUncheckedCreateWithoutMachinesInput>
  }

  export type LocationUpsertWithoutMachinesInput = {
    update: XOR<LocationUpdateWithoutMachinesInput, LocationUncheckedUpdateWithoutMachinesInput>
    create: XOR<LocationCreateWithoutMachinesInput, LocationUncheckedCreateWithoutMachinesInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutMachinesInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutMachinesInput, LocationUncheckedUpdateWithoutMachinesInput>
  }

  export type LocationUpdateWithoutMachinesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateWithoutMachinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateWithoutChildrenInput = {
    code: string
    name: string
    type: $Enums.AccountType
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: AccountCreateNestedOneWithoutChildrenInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutChildrenInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    parentId?: number | null
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutChildrenInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
  }

  export type AccountCreateWithoutParentInput = {
    code: string
    name: string
    type: $Enums.AccountType
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: AccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutParentInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutParentInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput>
  }

  export type AccountCreateManyParentInputEnvelope = {
    data: AccountCreateManyParentInput | AccountCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type JournalLineCreateWithoutAccountInput = {
    debit?: number
    credit?: number
    narration?: string | null
    entry: JournalEntryCreateNestedOneWithoutLinesInput
  }

  export type JournalLineUncheckedCreateWithoutAccountInput = {
    id?: number
    entryId: number
    debit?: number
    credit?: number
    narration?: string | null
  }

  export type JournalLineCreateOrConnectWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput>
  }

  export type JournalLineCreateManyAccountInputEnvelope = {
    data: JournalLineCreateManyAccountInput | JournalLineCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutAccountInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse?: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    currency?: CurrencyCreateNestedOneWithoutPurchaseOrdersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutAccountInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutAccountInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutAccountInput, PurchaseOrderUncheckedCreateWithoutAccountInput>
  }

  export type PurchaseOrderCreateManyAccountInputEnvelope = {
    data: PurchaseOrderCreateManyAccountInput | PurchaseOrderCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceCreateWithoutAccountInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    company: CompanyCreateNestedOneWithoutPurchaseInvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutInvoiceInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutAccountInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    purchaseOrderId?: string | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutAccountInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutAccountInput, PurchaseInvoiceUncheckedCreateWithoutAccountInput>
  }

  export type PurchaseInvoiceCreateManyAccountInputEnvelope = {
    data: PurchaseInvoiceCreateManyAccountInput | PurchaseInvoiceCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnCreateWithoutAccountInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseInvoice?: PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnsInput
    grn?: GRNCreateNestedOneWithoutPurchaseReturnsInput
    company: CompanyCreateNestedOneWithoutPurchaseReturnsInput
    items?: PurchaseReturnItemCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnUncheckedCreateWithoutAccountInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    purchaseInvoiceId?: string | null
    grnId?: string | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseReturnItemUncheckedCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnCreateOrConnectWithoutAccountInput = {
    where: PurchaseReturnWhereUniqueInput
    create: XOR<PurchaseReturnCreateWithoutAccountInput, PurchaseReturnUncheckedCreateWithoutAccountInput>
  }

  export type PurchaseReturnCreateManyAccountInputEnvelope = {
    data: PurchaseReturnCreateManyAccountInput | PurchaseReturnCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutChildrenInput = {
    update: XOR<AccountUpdateWithoutChildrenInput, AccountUncheckedUpdateWithoutChildrenInput>
    create: XOR<AccountCreateWithoutChildrenInput, AccountUncheckedCreateWithoutChildrenInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutChildrenInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutChildrenInput, AccountUncheckedUpdateWithoutChildrenInput>
  }

  export type AccountUpdateWithoutChildrenInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutParentInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutParentInput, AccountUncheckedUpdateWithoutParentInput>
    create: XOR<AccountCreateWithoutParentInput, AccountUncheckedCreateWithoutParentInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutParentInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutParentInput, AccountUncheckedUpdateWithoutParentInput>
  }

  export type AccountUpdateManyWithWhereWithoutParentInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutParentInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: IntFilter<"Account"> | number
    code?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    type?: EnumAccountTypeFilter<"Account"> | $Enums.AccountType
    parentId?: IntNullableFilter<"Account"> | number | null
    level?: IntFilter<"Account"> | number
    isPosting?: BoolFilter<"Account"> | boolean
    description?: StringNullableFilter<"Account"> | string | null
    openingBalance?: FloatFilter<"Account"> | number
    openingBalanceType?: EnumBalanceTypeFilter<"Account"> | $Enums.BalanceType
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type JournalLineUpsertWithWhereUniqueWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutAccountInput, JournalLineUncheckedUpdateWithoutAccountInput>
    create: XOR<JournalLineCreateWithoutAccountInput, JournalLineUncheckedCreateWithoutAccountInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutAccountInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutAccountInput, JournalLineUncheckedUpdateWithoutAccountInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutAccountInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutAccountInput>
  }

  export type JournalLineScalarWhereInput = {
    AND?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    OR?: JournalLineScalarWhereInput[]
    NOT?: JournalLineScalarWhereInput | JournalLineScalarWhereInput[]
    id?: IntFilter<"JournalLine"> | number
    entryId?: IntFilter<"JournalLine"> | number
    accountId?: IntFilter<"JournalLine"> | number
    debit?: FloatFilter<"JournalLine"> | number
    credit?: FloatFilter<"JournalLine"> | number
    narration?: StringNullableFilter<"JournalLine"> | string | null
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutAccountInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutAccountInput, PurchaseOrderUncheckedUpdateWithoutAccountInput>
    create: XOR<PurchaseOrderCreateWithoutAccountInput, PurchaseOrderUncheckedCreateWithoutAccountInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutAccountInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutAccountInput, PurchaseOrderUncheckedUpdateWithoutAccountInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutAccountInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutAccountInput>
  }

  export type PurchaseInvoiceUpsertWithWhereUniqueWithoutAccountInput = {
    where: PurchaseInvoiceWhereUniqueInput
    update: XOR<PurchaseInvoiceUpdateWithoutAccountInput, PurchaseInvoiceUncheckedUpdateWithoutAccountInput>
    create: XOR<PurchaseInvoiceCreateWithoutAccountInput, PurchaseInvoiceUncheckedCreateWithoutAccountInput>
  }

  export type PurchaseInvoiceUpdateWithWhereUniqueWithoutAccountInput = {
    where: PurchaseInvoiceWhereUniqueInput
    data: XOR<PurchaseInvoiceUpdateWithoutAccountInput, PurchaseInvoiceUncheckedUpdateWithoutAccountInput>
  }

  export type PurchaseInvoiceUpdateManyWithWhereWithoutAccountInput = {
    where: PurchaseInvoiceScalarWhereInput
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyWithoutAccountInput>
  }

  export type PurchaseReturnUpsertWithWhereUniqueWithoutAccountInput = {
    where: PurchaseReturnWhereUniqueInput
    update: XOR<PurchaseReturnUpdateWithoutAccountInput, PurchaseReturnUncheckedUpdateWithoutAccountInput>
    create: XOR<PurchaseReturnCreateWithoutAccountInput, PurchaseReturnUncheckedCreateWithoutAccountInput>
  }

  export type PurchaseReturnUpdateWithWhereUniqueWithoutAccountInput = {
    where: PurchaseReturnWhereUniqueInput
    data: XOR<PurchaseReturnUpdateWithoutAccountInput, PurchaseReturnUncheckedUpdateWithoutAccountInput>
  }

  export type PurchaseReturnUpdateManyWithWhereWithoutAccountInput = {
    where: PurchaseReturnScalarWhereInput
    data: XOR<PurchaseReturnUpdateManyMutationInput, PurchaseReturnUncheckedUpdateManyWithoutAccountInput>
  }

  export type FiscalYearCreateWithoutJournalEntriesInput = {
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalYearUncheckedCreateWithoutJournalEntriesInput = {
    id?: number
    name: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isLocked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FiscalYearCreateOrConnectWithoutJournalEntriesInput = {
    where: FiscalYearWhereUniqueInput
    create: XOR<FiscalYearCreateWithoutJournalEntriesInput, FiscalYearUncheckedCreateWithoutJournalEntriesInput>
  }

  export type JournalLineCreateWithoutEntryInput = {
    debit?: number
    credit?: number
    narration?: string | null
    account: AccountCreateNestedOneWithoutJournalLinesInput
  }

  export type JournalLineUncheckedCreateWithoutEntryInput = {
    id?: number
    accountId: number
    debit?: number
    credit?: number
    narration?: string | null
  }

  export type JournalLineCreateOrConnectWithoutEntryInput = {
    where: JournalLineWhereUniqueInput
    create: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput>
  }

  export type JournalLineCreateManyEntryInputEnvelope = {
    data: JournalLineCreateManyEntryInput | JournalLineCreateManyEntryInput[]
    skipDuplicates?: boolean
  }

  export type FiscalYearUpsertWithoutJournalEntriesInput = {
    update: XOR<FiscalYearUpdateWithoutJournalEntriesInput, FiscalYearUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<FiscalYearCreateWithoutJournalEntriesInput, FiscalYearUncheckedCreateWithoutJournalEntriesInput>
    where?: FiscalYearWhereInput
  }

  export type FiscalYearUpdateToOneWithWhereWithoutJournalEntriesInput = {
    where?: FiscalYearWhereInput
    data: XOR<FiscalYearUpdateWithoutJournalEntriesInput, FiscalYearUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type FiscalYearUpdateWithoutJournalEntriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FiscalYearUncheckedUpdateWithoutJournalEntriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineUpsertWithWhereUniqueWithoutEntryInput = {
    where: JournalLineWhereUniqueInput
    update: XOR<JournalLineUpdateWithoutEntryInput, JournalLineUncheckedUpdateWithoutEntryInput>
    create: XOR<JournalLineCreateWithoutEntryInput, JournalLineUncheckedCreateWithoutEntryInput>
  }

  export type JournalLineUpdateWithWhereUniqueWithoutEntryInput = {
    where: JournalLineWhereUniqueInput
    data: XOR<JournalLineUpdateWithoutEntryInput, JournalLineUncheckedUpdateWithoutEntryInput>
  }

  export type JournalLineUpdateManyWithWhereWithoutEntryInput = {
    where: JournalLineScalarWhereInput
    data: XOR<JournalLineUpdateManyMutationInput, JournalLineUncheckedUpdateManyWithoutEntryInput>
  }

  export type AccountCreateWithoutJournalLinesInput = {
    code: string
    name: string
    type: $Enums.AccountType
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutJournalLinesInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    parentId?: number | null
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutJournalLinesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutJournalLinesInput, AccountUncheckedCreateWithoutJournalLinesInput>
  }

  export type JournalEntryCreateWithoutLinesInput = {
    number: string
    date: Date | string
    type: $Enums.VoucherType
    reference?: string | null
    narration?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fiscalYear?: FiscalYearCreateNestedOneWithoutJournalEntriesInput
  }

  export type JournalEntryUncheckedCreateWithoutLinesInput = {
    id?: number
    number: string
    date: Date | string
    type: $Enums.VoucherType
    reference?: string | null
    narration?: string | null
    status?: boolean
    fiscalYearId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryCreateOrConnectWithoutLinesInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
  }

  export type AccountUpsertWithoutJournalLinesInput = {
    update: XOR<AccountUpdateWithoutJournalLinesInput, AccountUncheckedUpdateWithoutJournalLinesInput>
    create: XOR<AccountCreateWithoutJournalLinesInput, AccountUncheckedCreateWithoutJournalLinesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutJournalLinesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutJournalLinesInput, AccountUncheckedUpdateWithoutJournalLinesInput>
  }

  export type AccountUpdateWithoutJournalLinesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutJournalLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type JournalEntryUpsertWithoutLinesInput = {
    update: XOR<JournalEntryUpdateWithoutLinesInput, JournalEntryUncheckedUpdateWithoutLinesInput>
    create: XOR<JournalEntryCreateWithoutLinesInput, JournalEntryUncheckedCreateWithoutLinesInput>
    where?: JournalEntryWhereInput
  }

  export type JournalEntryUpdateToOneWithWhereWithoutLinesInput = {
    where?: JournalEntryWhereInput
    data: XOR<JournalEntryUpdateWithoutLinesInput, JournalEntryUncheckedUpdateWithoutLinesInput>
  }

  export type JournalEntryUpdateWithoutLinesInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fiscalYear?: FiscalYearUpdateOneWithoutJournalEntriesNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutLinesInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    fiscalYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGroupCreateWithoutChildrenInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ItemGroupCreateNestedOneWithoutChildrenInput
    company: CompanyCreateNestedOneWithoutItemGroupsInput
    itemMasters?: ItemMasterCreateNestedManyWithoutItemGroupInput
  }

  export type ItemGroupUncheckedCreateWithoutChildrenInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    parentId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutItemGroupInput
  }

  export type ItemGroupCreateOrConnectWithoutChildrenInput = {
    where: ItemGroupWhereUniqueInput
    create: XOR<ItemGroupCreateWithoutChildrenInput, ItemGroupUncheckedCreateWithoutChildrenInput>
  }

  export type ItemGroupCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ItemGroupCreateNestedManyWithoutParentInput
    company: CompanyCreateNestedOneWithoutItemGroupsInput
    itemMasters?: ItemMasterCreateNestedManyWithoutItemGroupInput
  }

  export type ItemGroupUncheckedCreateWithoutParentInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ItemGroupUncheckedCreateNestedManyWithoutParentInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutItemGroupInput
  }

  export type ItemGroupCreateOrConnectWithoutParentInput = {
    where: ItemGroupWhereUniqueInput
    create: XOR<ItemGroupCreateWithoutParentInput, ItemGroupUncheckedCreateWithoutParentInput>
  }

  export type ItemGroupCreateManyParentInputEnvelope = {
    data: ItemGroupCreateManyParentInput | ItemGroupCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutItemGroupsInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutItemGroupsInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutItemGroupsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutItemGroupsInput, CompanyUncheckedCreateWithoutItemGroupsInput>
  }

  export type ItemMasterCreateWithoutItemGroupInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    baseUnit: UnitCreateNestedOneWithoutItemMastersInput
    packingUnit?: PackingUnitCreateNestedOneWithoutItemMastersInput
    company: CompanyCreateNestedOneWithoutItemMastersInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUncheckedCreateWithoutItemGroupInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    baseUnitId: number
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterCreateOrConnectWithoutItemGroupInput = {
    where: ItemMasterWhereUniqueInput
    create: XOR<ItemMasterCreateWithoutItemGroupInput, ItemMasterUncheckedCreateWithoutItemGroupInput>
  }

  export type ItemMasterCreateManyItemGroupInputEnvelope = {
    data: ItemMasterCreateManyItemGroupInput | ItemMasterCreateManyItemGroupInput[]
    skipDuplicates?: boolean
  }

  export type ItemGroupUpsertWithoutChildrenInput = {
    update: XOR<ItemGroupUpdateWithoutChildrenInput, ItemGroupUncheckedUpdateWithoutChildrenInput>
    create: XOR<ItemGroupCreateWithoutChildrenInput, ItemGroupUncheckedCreateWithoutChildrenInput>
    where?: ItemGroupWhereInput
  }

  export type ItemGroupUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ItemGroupWhereInput
    data: XOR<ItemGroupUpdateWithoutChildrenInput, ItemGroupUncheckedUpdateWithoutChildrenInput>
  }

  export type ItemGroupUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ItemGroupUpdateOneWithoutChildrenNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemGroupsNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutItemGroupNestedInput
  }

  export type ItemGroupUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutItemGroupNestedInput
  }

  export type ItemGroupUpsertWithWhereUniqueWithoutParentInput = {
    where: ItemGroupWhereUniqueInput
    update: XOR<ItemGroupUpdateWithoutParentInput, ItemGroupUncheckedUpdateWithoutParentInput>
    create: XOR<ItemGroupCreateWithoutParentInput, ItemGroupUncheckedCreateWithoutParentInput>
  }

  export type ItemGroupUpdateWithWhereUniqueWithoutParentInput = {
    where: ItemGroupWhereUniqueInput
    data: XOR<ItemGroupUpdateWithoutParentInput, ItemGroupUncheckedUpdateWithoutParentInput>
  }

  export type ItemGroupUpdateManyWithWhereWithoutParentInput = {
    where: ItemGroupScalarWhereInput
    data: XOR<ItemGroupUpdateManyMutationInput, ItemGroupUncheckedUpdateManyWithoutParentInput>
  }

  export type CompanyUpsertWithoutItemGroupsInput = {
    update: XOR<CompanyUpdateWithoutItemGroupsInput, CompanyUncheckedUpdateWithoutItemGroupsInput>
    create: XOR<CompanyCreateWithoutItemGroupsInput, CompanyUncheckedCreateWithoutItemGroupsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutItemGroupsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutItemGroupsInput, CompanyUncheckedUpdateWithoutItemGroupsInput>
  }

  export type CompanyUpdateWithoutItemGroupsInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutItemGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ItemMasterUpsertWithWhereUniqueWithoutItemGroupInput = {
    where: ItemMasterWhereUniqueInput
    update: XOR<ItemMasterUpdateWithoutItemGroupInput, ItemMasterUncheckedUpdateWithoutItemGroupInput>
    create: XOR<ItemMasterCreateWithoutItemGroupInput, ItemMasterUncheckedCreateWithoutItemGroupInput>
  }

  export type ItemMasterUpdateWithWhereUniqueWithoutItemGroupInput = {
    where: ItemMasterWhereUniqueInput
    data: XOR<ItemMasterUpdateWithoutItemGroupInput, ItemMasterUncheckedUpdateWithoutItemGroupInput>
  }

  export type ItemMasterUpdateManyWithWhereWithoutItemGroupInput = {
    where: ItemMasterScalarWhereInput
    data: XOR<ItemMasterUpdateManyMutationInput, ItemMasterUncheckedUpdateManyWithoutItemGroupInput>
  }

  export type CompanyCreateWithoutColorsInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutColorsInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutColorsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutColorsInput, CompanyUncheckedCreateWithoutColorsInput>
  }

  export type PurchaseOrderItemCreateWithoutColorInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseOrderItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseOrderItemsInput
    grnItems?: GRNItemCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutColorInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemCreateOrConnectWithoutColorInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutColorInput, PurchaseOrderItemUncheckedCreateWithoutColorInput>
  }

  export type PurchaseOrderItemCreateManyColorInputEnvelope = {
    data: PurchaseOrderItemCreateManyColorInput | PurchaseOrderItemCreateManyColorInput[]
    skipDuplicates?: boolean
  }

  export type GRNItemCreateWithoutColorInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grn: GRNCreateNestedOneWithoutItemsInput
    purchaseOrderItem: PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutGrnItemsInput
    brand?: BrandCreateNestedOneWithoutGrnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutGrnItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutGrnItemsInput
    unit?: UnitCreateNestedOneWithoutGrnItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUncheckedCreateWithoutColorInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemCreateOrConnectWithoutColorInput = {
    where: GRNItemWhereUniqueInput
    create: XOR<GRNItemCreateWithoutColorInput, GRNItemUncheckedCreateWithoutColorInput>
  }

  export type GRNItemCreateManyColorInputEnvelope = {
    data: GRNItemCreateManyColorInput | GRNItemCreateManyColorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceItemCreateWithoutColorInput = {
    id?: string
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
    purchaseOrderItem?: PurchaseOrderItemCreateNestedOneWithoutInvoiceItemsInput
    grnItem?: GRNItemCreateNestedOneWithoutInvoiceItemsInput
    itemMaster?: ItemMasterCreateNestedOneWithoutPurchaseInvoiceItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseInvoiceItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseInvoiceItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseInvoiceItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutColorInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutColorInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutColorInput, PurchaseInvoiceItemUncheckedCreateWithoutColorInput>
  }

  export type PurchaseInvoiceItemCreateManyColorInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyColorInput | PurchaseInvoiceItemCreateManyColorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnItemCreateWithoutColorInput = {
    id?: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    return: PurchaseReturnCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseReturnItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseReturnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseReturnItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseReturnItemsInput
  }

  export type PurchaseReturnItemUncheckedCreateWithoutColorInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateOrConnectWithoutColorInput = {
    where: PurchaseReturnItemWhereUniqueInput
    create: XOR<PurchaseReturnItemCreateWithoutColorInput, PurchaseReturnItemUncheckedCreateWithoutColorInput>
  }

  export type PurchaseReturnItemCreateManyColorInputEnvelope = {
    data: PurchaseReturnItemCreateManyColorInput | PurchaseReturnItemCreateManyColorInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutColorsInput = {
    update: XOR<CompanyUpdateWithoutColorsInput, CompanyUncheckedUpdateWithoutColorsInput>
    create: XOR<CompanyCreateWithoutColorsInput, CompanyUncheckedCreateWithoutColorsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutColorsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutColorsInput, CompanyUncheckedUpdateWithoutColorsInput>
  }

  export type CompanyUpdateWithoutColorsInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutColorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutColorInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutColorInput, PurchaseOrderItemUncheckedUpdateWithoutColorInput>
    create: XOR<PurchaseOrderItemCreateWithoutColorInput, PurchaseOrderItemUncheckedCreateWithoutColorInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutColorInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutColorInput, PurchaseOrderItemUncheckedUpdateWithoutColorInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutColorInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutColorInput>
  }

  export type GRNItemUpsertWithWhereUniqueWithoutColorInput = {
    where: GRNItemWhereUniqueInput
    update: XOR<GRNItemUpdateWithoutColorInput, GRNItemUncheckedUpdateWithoutColorInput>
    create: XOR<GRNItemCreateWithoutColorInput, GRNItemUncheckedCreateWithoutColorInput>
  }

  export type GRNItemUpdateWithWhereUniqueWithoutColorInput = {
    where: GRNItemWhereUniqueInput
    data: XOR<GRNItemUpdateWithoutColorInput, GRNItemUncheckedUpdateWithoutColorInput>
  }

  export type GRNItemUpdateManyWithWhereWithoutColorInput = {
    where: GRNItemScalarWhereInput
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyWithoutColorInput>
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutColorInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutColorInput, PurchaseInvoiceItemUncheckedUpdateWithoutColorInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutColorInput, PurchaseInvoiceItemUncheckedCreateWithoutColorInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutColorInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutColorInput, PurchaseInvoiceItemUncheckedUpdateWithoutColorInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutColorInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutColorInput>
  }

  export type PurchaseReturnItemUpsertWithWhereUniqueWithoutColorInput = {
    where: PurchaseReturnItemWhereUniqueInput
    update: XOR<PurchaseReturnItemUpdateWithoutColorInput, PurchaseReturnItemUncheckedUpdateWithoutColorInput>
    create: XOR<PurchaseReturnItemCreateWithoutColorInput, PurchaseReturnItemUncheckedCreateWithoutColorInput>
  }

  export type PurchaseReturnItemUpdateWithWhereUniqueWithoutColorInput = {
    where: PurchaseReturnItemWhereUniqueInput
    data: XOR<PurchaseReturnItemUpdateWithoutColorInput, PurchaseReturnItemUncheckedUpdateWithoutColorInput>
  }

  export type PurchaseReturnItemUpdateManyWithWhereWithoutColorInput = {
    where: PurchaseReturnItemScalarWhereInput
    data: XOR<PurchaseReturnItemUpdateManyMutationInput, PurchaseReturnItemUncheckedUpdateManyWithoutColorInput>
  }

  export type CompanyCreateWithoutBrandsInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutBrandsInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutBrandsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBrandsInput, CompanyUncheckedCreateWithoutBrandsInput>
  }

  export type PurchaseOrderItemCreateWithoutBrandInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseOrderItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseOrderItemsInput
    grnItems?: GRNItemCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutBrandInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemCreateOrConnectWithoutBrandInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutBrandInput, PurchaseOrderItemUncheckedCreateWithoutBrandInput>
  }

  export type PurchaseOrderItemCreateManyBrandInputEnvelope = {
    data: PurchaseOrderItemCreateManyBrandInput | PurchaseOrderItemCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type GRNItemCreateWithoutBrandInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grn: GRNCreateNestedOneWithoutItemsInput
    purchaseOrderItem: PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutGrnItemsInput
    color?: ColorCreateNestedOneWithoutGrnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutGrnItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutGrnItemsInput
    unit?: UnitCreateNestedOneWithoutGrnItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUncheckedCreateWithoutBrandInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemCreateOrConnectWithoutBrandInput = {
    where: GRNItemWhereUniqueInput
    create: XOR<GRNItemCreateWithoutBrandInput, GRNItemUncheckedCreateWithoutBrandInput>
  }

  export type GRNItemCreateManyBrandInputEnvelope = {
    data: GRNItemCreateManyBrandInput | GRNItemCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceItemCreateWithoutBrandInput = {
    id?: string
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
    purchaseOrderItem?: PurchaseOrderItemCreateNestedOneWithoutInvoiceItemsInput
    grnItem?: GRNItemCreateNestedOneWithoutInvoiceItemsInput
    itemMaster?: ItemMasterCreateNestedOneWithoutPurchaseInvoiceItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseInvoiceItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseInvoiceItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseInvoiceItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutBrandInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutBrandInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutBrandInput, PurchaseInvoiceItemUncheckedCreateWithoutBrandInput>
  }

  export type PurchaseInvoiceItemCreateManyBrandInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyBrandInput | PurchaseInvoiceItemCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnItemCreateWithoutBrandInput = {
    id?: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    return: PurchaseReturnCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseReturnItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseReturnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseReturnItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseReturnItemsInput
  }

  export type PurchaseReturnItemUncheckedCreateWithoutBrandInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateOrConnectWithoutBrandInput = {
    where: PurchaseReturnItemWhereUniqueInput
    create: XOR<PurchaseReturnItemCreateWithoutBrandInput, PurchaseReturnItemUncheckedCreateWithoutBrandInput>
  }

  export type PurchaseReturnItemCreateManyBrandInputEnvelope = {
    data: PurchaseReturnItemCreateManyBrandInput | PurchaseReturnItemCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutBrandsInput = {
    update: XOR<CompanyUpdateWithoutBrandsInput, CompanyUncheckedUpdateWithoutBrandsInput>
    create: XOR<CompanyCreateWithoutBrandsInput, CompanyUncheckedCreateWithoutBrandsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBrandsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBrandsInput, CompanyUncheckedUpdateWithoutBrandsInput>
  }

  export type CompanyUpdateWithoutBrandsInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutBrandInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutBrandInput, PurchaseOrderItemUncheckedUpdateWithoutBrandInput>
    create: XOR<PurchaseOrderItemCreateWithoutBrandInput, PurchaseOrderItemUncheckedCreateWithoutBrandInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutBrandInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutBrandInput, PurchaseOrderItemUncheckedUpdateWithoutBrandInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutBrandInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutBrandInput>
  }

  export type GRNItemUpsertWithWhereUniqueWithoutBrandInput = {
    where: GRNItemWhereUniqueInput
    update: XOR<GRNItemUpdateWithoutBrandInput, GRNItemUncheckedUpdateWithoutBrandInput>
    create: XOR<GRNItemCreateWithoutBrandInput, GRNItemUncheckedCreateWithoutBrandInput>
  }

  export type GRNItemUpdateWithWhereUniqueWithoutBrandInput = {
    where: GRNItemWhereUniqueInput
    data: XOR<GRNItemUpdateWithoutBrandInput, GRNItemUncheckedUpdateWithoutBrandInput>
  }

  export type GRNItemUpdateManyWithWhereWithoutBrandInput = {
    where: GRNItemScalarWhereInput
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyWithoutBrandInput>
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutBrandInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutBrandInput, PurchaseInvoiceItemUncheckedUpdateWithoutBrandInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutBrandInput, PurchaseInvoiceItemUncheckedCreateWithoutBrandInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutBrandInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutBrandInput, PurchaseInvoiceItemUncheckedUpdateWithoutBrandInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutBrandInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutBrandInput>
  }

  export type PurchaseReturnItemUpsertWithWhereUniqueWithoutBrandInput = {
    where: PurchaseReturnItemWhereUniqueInput
    update: XOR<PurchaseReturnItemUpdateWithoutBrandInput, PurchaseReturnItemUncheckedUpdateWithoutBrandInput>
    create: XOR<PurchaseReturnItemCreateWithoutBrandInput, PurchaseReturnItemUncheckedCreateWithoutBrandInput>
  }

  export type PurchaseReturnItemUpdateWithWhereUniqueWithoutBrandInput = {
    where: PurchaseReturnItemWhereUniqueInput
    data: XOR<PurchaseReturnItemUpdateWithoutBrandInput, PurchaseReturnItemUncheckedUpdateWithoutBrandInput>
  }

  export type PurchaseReturnItemUpdateManyWithWhereWithoutBrandInput = {
    where: PurchaseReturnItemScalarWhereInput
    data: XOR<PurchaseReturnItemUpdateManyMutationInput, PurchaseReturnItemUncheckedUpdateManyWithoutBrandInput>
  }

  export type CompanyCreateWithoutItemGradesInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutItemGradesInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutItemGradesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutItemGradesInput, CompanyUncheckedCreateWithoutItemGradesInput>
  }

  export type PurchaseOrderItemCreateWithoutItemGradeInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseOrderItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseOrderItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseOrderItemsInput
    grnItems?: GRNItemCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutItemGradeInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemCreateOrConnectWithoutItemGradeInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutItemGradeInput, PurchaseOrderItemUncheckedCreateWithoutItemGradeInput>
  }

  export type PurchaseOrderItemCreateManyItemGradeInputEnvelope = {
    data: PurchaseOrderItemCreateManyItemGradeInput | PurchaseOrderItemCreateManyItemGradeInput[]
    skipDuplicates?: boolean
  }

  export type GRNItemCreateWithoutItemGradeInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grn: GRNCreateNestedOneWithoutItemsInput
    purchaseOrderItem: PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutGrnItemsInput
    color?: ColorCreateNestedOneWithoutGrnItemsInput
    brand?: BrandCreateNestedOneWithoutGrnItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutGrnItemsInput
    unit?: UnitCreateNestedOneWithoutGrnItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUncheckedCreateWithoutItemGradeInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemCreateOrConnectWithoutItemGradeInput = {
    where: GRNItemWhereUniqueInput
    create: XOR<GRNItemCreateWithoutItemGradeInput, GRNItemUncheckedCreateWithoutItemGradeInput>
  }

  export type GRNItemCreateManyItemGradeInputEnvelope = {
    data: GRNItemCreateManyItemGradeInput | GRNItemCreateManyItemGradeInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceItemCreateWithoutItemGradeInput = {
    id?: string
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
    purchaseOrderItem?: PurchaseOrderItemCreateNestedOneWithoutInvoiceItemsInput
    grnItem?: GRNItemCreateNestedOneWithoutInvoiceItemsInput
    itemMaster?: ItemMasterCreateNestedOneWithoutPurchaseInvoiceItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseInvoiceItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseInvoiceItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseInvoiceItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutItemGradeInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutItemGradeInput, PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput>
  }

  export type PurchaseInvoiceItemCreateManyItemGradeInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyItemGradeInput | PurchaseInvoiceItemCreateManyItemGradeInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnItemCreateWithoutItemGradeInput = {
    id?: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    return: PurchaseReturnCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseReturnItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseReturnItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseReturnItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseReturnItemsInput
  }

  export type PurchaseReturnItemUncheckedCreateWithoutItemGradeInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateOrConnectWithoutItemGradeInput = {
    where: PurchaseReturnItemWhereUniqueInput
    create: XOR<PurchaseReturnItemCreateWithoutItemGradeInput, PurchaseReturnItemUncheckedCreateWithoutItemGradeInput>
  }

  export type PurchaseReturnItemCreateManyItemGradeInputEnvelope = {
    data: PurchaseReturnItemCreateManyItemGradeInput | PurchaseReturnItemCreateManyItemGradeInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutItemGradesInput = {
    update: XOR<CompanyUpdateWithoutItemGradesInput, CompanyUncheckedUpdateWithoutItemGradesInput>
    create: XOR<CompanyCreateWithoutItemGradesInput, CompanyUncheckedCreateWithoutItemGradesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutItemGradesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutItemGradesInput, CompanyUncheckedUpdateWithoutItemGradesInput>
  }

  export type CompanyUpdateWithoutItemGradesInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutItemGradesInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutItemGradeInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutItemGradeInput, PurchaseOrderItemUncheckedUpdateWithoutItemGradeInput>
    create: XOR<PurchaseOrderItemCreateWithoutItemGradeInput, PurchaseOrderItemUncheckedCreateWithoutItemGradeInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutItemGradeInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutItemGradeInput, PurchaseOrderItemUncheckedUpdateWithoutItemGradeInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutItemGradeInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutItemGradeInput>
  }

  export type GRNItemUpsertWithWhereUniqueWithoutItemGradeInput = {
    where: GRNItemWhereUniqueInput
    update: XOR<GRNItemUpdateWithoutItemGradeInput, GRNItemUncheckedUpdateWithoutItemGradeInput>
    create: XOR<GRNItemCreateWithoutItemGradeInput, GRNItemUncheckedCreateWithoutItemGradeInput>
  }

  export type GRNItemUpdateWithWhereUniqueWithoutItemGradeInput = {
    where: GRNItemWhereUniqueInput
    data: XOR<GRNItemUpdateWithoutItemGradeInput, GRNItemUncheckedUpdateWithoutItemGradeInput>
  }

  export type GRNItemUpdateManyWithWhereWithoutItemGradeInput = {
    where: GRNItemScalarWhereInput
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyWithoutItemGradeInput>
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemGradeInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutItemGradeInput, PurchaseInvoiceItemUncheckedUpdateWithoutItemGradeInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutItemGradeInput, PurchaseInvoiceItemUncheckedCreateWithoutItemGradeInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemGradeInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutItemGradeInput, PurchaseInvoiceItemUncheckedUpdateWithoutItemGradeInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutItemGradeInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutItemGradeInput>
  }

  export type PurchaseReturnItemUpsertWithWhereUniqueWithoutItemGradeInput = {
    where: PurchaseReturnItemWhereUniqueInput
    update: XOR<PurchaseReturnItemUpdateWithoutItemGradeInput, PurchaseReturnItemUncheckedUpdateWithoutItemGradeInput>
    create: XOR<PurchaseReturnItemCreateWithoutItemGradeInput, PurchaseReturnItemUncheckedCreateWithoutItemGradeInput>
  }

  export type PurchaseReturnItemUpdateWithWhereUniqueWithoutItemGradeInput = {
    where: PurchaseReturnItemWhereUniqueInput
    data: XOR<PurchaseReturnItemUpdateWithoutItemGradeInput, PurchaseReturnItemUncheckedUpdateWithoutItemGradeInput>
  }

  export type PurchaseReturnItemUpdateManyWithWhereWithoutItemGradeInput = {
    where: PurchaseReturnItemScalarWhereInput
    data: XOR<PurchaseReturnItemUpdateManyMutationInput, PurchaseReturnItemUncheckedUpdateManyWithoutItemGradeInput>
  }

  export type CompanyCreateWithoutPackingUnitsInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPackingUnitsInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPackingUnitsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPackingUnitsInput, CompanyUncheckedCreateWithoutPackingUnitsInput>
  }

  export type ItemMasterCreateWithoutPackingUnitInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroup: ItemGroupCreateNestedOneWithoutItemMastersInput
    baseUnit: UnitCreateNestedOneWithoutItemMastersInput
    company: CompanyCreateNestedOneWithoutItemMastersInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUncheckedCreateWithoutPackingUnitInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterCreateOrConnectWithoutPackingUnitInput = {
    where: ItemMasterWhereUniqueInput
    create: XOR<ItemMasterCreateWithoutPackingUnitInput, ItemMasterUncheckedCreateWithoutPackingUnitInput>
  }

  export type ItemMasterCreateManyPackingUnitInputEnvelope = {
    data: ItemMasterCreateManyPackingUnitInput | ItemMasterCreateManyPackingUnitInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderItemCreateWithoutPackingUnitInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseOrderItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseOrderItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseOrderItemsInput
    grnItems?: GRNItemCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemCreateOrConnectWithoutPackingUnitInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutPackingUnitInput, PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput>
  }

  export type PurchaseOrderItemCreateManyPackingUnitInputEnvelope = {
    data: PurchaseOrderItemCreateManyPackingUnitInput | PurchaseOrderItemCreateManyPackingUnitInput[]
    skipDuplicates?: boolean
  }

  export type GRNItemCreateWithoutPackingUnitInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grn: GRNCreateNestedOneWithoutItemsInput
    purchaseOrderItem: PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutGrnItemsInput
    color?: ColorCreateNestedOneWithoutGrnItemsInput
    brand?: BrandCreateNestedOneWithoutGrnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutGrnItemsInput
    unit?: UnitCreateNestedOneWithoutGrnItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUncheckedCreateWithoutPackingUnitInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemCreateOrConnectWithoutPackingUnitInput = {
    where: GRNItemWhereUniqueInput
    create: XOR<GRNItemCreateWithoutPackingUnitInput, GRNItemUncheckedCreateWithoutPackingUnitInput>
  }

  export type GRNItemCreateManyPackingUnitInputEnvelope = {
    data: GRNItemCreateManyPackingUnitInput | GRNItemCreateManyPackingUnitInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutPackingUnitsInput = {
    update: XOR<CompanyUpdateWithoutPackingUnitsInput, CompanyUncheckedUpdateWithoutPackingUnitsInput>
    create: XOR<CompanyCreateWithoutPackingUnitsInput, CompanyUncheckedCreateWithoutPackingUnitsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPackingUnitsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPackingUnitsInput, CompanyUncheckedUpdateWithoutPackingUnitsInput>
  }

  export type CompanyUpdateWithoutPackingUnitsInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPackingUnitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ItemMasterUpsertWithWhereUniqueWithoutPackingUnitInput = {
    where: ItemMasterWhereUniqueInput
    update: XOR<ItemMasterUpdateWithoutPackingUnitInput, ItemMasterUncheckedUpdateWithoutPackingUnitInput>
    create: XOR<ItemMasterCreateWithoutPackingUnitInput, ItemMasterUncheckedCreateWithoutPackingUnitInput>
  }

  export type ItemMasterUpdateWithWhereUniqueWithoutPackingUnitInput = {
    where: ItemMasterWhereUniqueInput
    data: XOR<ItemMasterUpdateWithoutPackingUnitInput, ItemMasterUncheckedUpdateWithoutPackingUnitInput>
  }

  export type ItemMasterUpdateManyWithWhereWithoutPackingUnitInput = {
    where: ItemMasterScalarWhereInput
    data: XOR<ItemMasterUpdateManyMutationInput, ItemMasterUncheckedUpdateManyWithoutPackingUnitInput>
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPackingUnitInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutPackingUnitInput, PurchaseOrderItemUncheckedUpdateWithoutPackingUnitInput>
    create: XOR<PurchaseOrderItemCreateWithoutPackingUnitInput, PurchaseOrderItemUncheckedCreateWithoutPackingUnitInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPackingUnitInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutPackingUnitInput, PurchaseOrderItemUncheckedUpdateWithoutPackingUnitInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutPackingUnitInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutPackingUnitInput>
  }

  export type GRNItemUpsertWithWhereUniqueWithoutPackingUnitInput = {
    where: GRNItemWhereUniqueInput
    update: XOR<GRNItemUpdateWithoutPackingUnitInput, GRNItemUncheckedUpdateWithoutPackingUnitInput>
    create: XOR<GRNItemCreateWithoutPackingUnitInput, GRNItemUncheckedCreateWithoutPackingUnitInput>
  }

  export type GRNItemUpdateWithWhereUniqueWithoutPackingUnitInput = {
    where: GRNItemWhereUniqueInput
    data: XOR<GRNItemUpdateWithoutPackingUnitInput, GRNItemUncheckedUpdateWithoutPackingUnitInput>
  }

  export type GRNItemUpdateManyWithWhereWithoutPackingUnitInput = {
    where: GRNItemScalarWhereInput
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyWithoutPackingUnitInput>
  }

  export type ItemGroupCreateWithoutItemMastersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ItemGroupCreateNestedOneWithoutChildrenInput
    children?: ItemGroupCreateNestedManyWithoutParentInput
    company: CompanyCreateNestedOneWithoutItemGroupsInput
  }

  export type ItemGroupUncheckedCreateWithoutItemMastersInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    parentId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: ItemGroupUncheckedCreateNestedManyWithoutParentInput
  }

  export type ItemGroupCreateOrConnectWithoutItemMastersInput = {
    where: ItemGroupWhereUniqueInput
    create: XOR<ItemGroupCreateWithoutItemMastersInput, ItemGroupUncheckedCreateWithoutItemMastersInput>
  }

  export type UnitCreateWithoutItemMastersInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitsInput
    conversionsFrom?: UnitConversionCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionCreateNestedManyWithoutToUnitInput
    products?: ProductCreateNestedManyWithoutUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutItemMastersInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionUncheckedCreateNestedManyWithoutToUnitInput
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutItemMastersInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutItemMastersInput, UnitUncheckedCreateWithoutItemMastersInput>
  }

  export type PackingUnitCreateWithoutItemMastersInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPackingUnitsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutPackingUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitUncheckedCreateWithoutItemMastersInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPackingUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitCreateOrConnectWithoutItemMastersInput = {
    where: PackingUnitWhereUniqueInput
    create: XOR<PackingUnitCreateWithoutItemMastersInput, PackingUnitUncheckedCreateWithoutItemMastersInput>
  }

  export type CompanyCreateWithoutItemMastersInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutItemMastersInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutItemMastersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutItemMastersInput, CompanyUncheckedCreateWithoutItemMastersInput>
  }

  export type PurchaseOrderItemCreateWithoutItemMasterInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseOrderItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseOrderItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseOrderItemsInput
    grnItems?: GRNItemCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutItemMasterInput = {
    id?: string
    purchaseOrderId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemCreateOrConnectWithoutItemMasterInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutItemMasterInput, PurchaseOrderItemUncheckedCreateWithoutItemMasterInput>
  }

  export type PurchaseOrderItemCreateManyItemMasterInputEnvelope = {
    data: PurchaseOrderItemCreateManyItemMasterInput | PurchaseOrderItemCreateManyItemMasterInput[]
    skipDuplicates?: boolean
  }

  export type GRNItemCreateWithoutItemMasterInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grn: GRNCreateNestedOneWithoutItemsInput
    purchaseOrderItem: PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput
    color?: ColorCreateNestedOneWithoutGrnItemsInput
    brand?: BrandCreateNestedOneWithoutGrnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutGrnItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutGrnItemsInput
    unit?: UnitCreateNestedOneWithoutGrnItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUncheckedCreateWithoutItemMasterInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemCreateOrConnectWithoutItemMasterInput = {
    where: GRNItemWhereUniqueInput
    create: XOR<GRNItemCreateWithoutItemMasterInput, GRNItemUncheckedCreateWithoutItemMasterInput>
  }

  export type GRNItemCreateManyItemMasterInputEnvelope = {
    data: GRNItemCreateManyItemMasterInput | GRNItemCreateManyItemMasterInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceItemCreateWithoutItemMasterInput = {
    id?: string
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
    purchaseOrderItem?: PurchaseOrderItemCreateNestedOneWithoutInvoiceItemsInput
    grnItem?: GRNItemCreateNestedOneWithoutInvoiceItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseInvoiceItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseInvoiceItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseInvoiceItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseInvoiceItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutItemMasterInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutItemMasterInput, PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput>
  }

  export type PurchaseInvoiceItemCreateManyItemMasterInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyItemMasterInput | PurchaseInvoiceItemCreateManyItemMasterInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnItemCreateWithoutItemMasterInput = {
    id?: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    return: PurchaseReturnCreateNestedOneWithoutItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseReturnItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseReturnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseReturnItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseReturnItemsInput
  }

  export type PurchaseReturnItemUncheckedCreateWithoutItemMasterInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateOrConnectWithoutItemMasterInput = {
    where: PurchaseReturnItemWhereUniqueInput
    create: XOR<PurchaseReturnItemCreateWithoutItemMasterInput, PurchaseReturnItemUncheckedCreateWithoutItemMasterInput>
  }

  export type PurchaseReturnItemCreateManyItemMasterInputEnvelope = {
    data: PurchaseReturnItemCreateManyItemMasterInput | PurchaseReturnItemCreateManyItemMasterInput[]
    skipDuplicates?: boolean
  }

  export type ItemGroupUpsertWithoutItemMastersInput = {
    update: XOR<ItemGroupUpdateWithoutItemMastersInput, ItemGroupUncheckedUpdateWithoutItemMastersInput>
    create: XOR<ItemGroupCreateWithoutItemMastersInput, ItemGroupUncheckedCreateWithoutItemMastersInput>
    where?: ItemGroupWhereInput
  }

  export type ItemGroupUpdateToOneWithWhereWithoutItemMastersInput = {
    where?: ItemGroupWhereInput
    data: XOR<ItemGroupUpdateWithoutItemMastersInput, ItemGroupUncheckedUpdateWithoutItemMastersInput>
  }

  export type ItemGroupUpdateWithoutItemMastersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ItemGroupUpdateOneWithoutChildrenNestedInput
    children?: ItemGroupUpdateManyWithoutParentNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemGroupsNestedInput
  }

  export type ItemGroupUncheckedUpdateWithoutItemMastersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ItemGroupUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UnitUpsertWithoutItemMastersInput = {
    update: XOR<UnitUpdateWithoutItemMastersInput, UnitUncheckedUpdateWithoutItemMastersInput>
    create: XOR<UnitCreateWithoutItemMastersInput, UnitUncheckedCreateWithoutItemMastersInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutItemMastersInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutItemMastersInput, UnitUncheckedUpdateWithoutItemMastersInput>
  }

  export type UnitUpdateWithoutItemMastersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitsNestedInput
    conversionsFrom?: UnitConversionUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUpdateManyWithoutToUnitNestedInput
    products?: ProductUpdateManyWithoutUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutItemMastersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type PackingUnitUpsertWithoutItemMastersInput = {
    update: XOR<PackingUnitUpdateWithoutItemMastersInput, PackingUnitUncheckedUpdateWithoutItemMastersInput>
    create: XOR<PackingUnitCreateWithoutItemMastersInput, PackingUnitUncheckedCreateWithoutItemMastersInput>
    where?: PackingUnitWhereInput
  }

  export type PackingUnitUpdateToOneWithWhereWithoutItemMastersInput = {
    where?: PackingUnitWhereInput
    data: XOR<PackingUnitUpdateWithoutItemMastersInput, PackingUnitUncheckedUpdateWithoutItemMastersInput>
  }

  export type PackingUnitUpdateWithoutItemMastersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPackingUnitsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutPackingUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutPackingUnitNestedInput
  }

  export type PackingUnitUncheckedUpdateWithoutItemMastersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutPackingUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutPackingUnitNestedInput
  }

  export type CompanyUpsertWithoutItemMastersInput = {
    update: XOR<CompanyUpdateWithoutItemMastersInput, CompanyUncheckedUpdateWithoutItemMastersInput>
    create: XOR<CompanyCreateWithoutItemMastersInput, CompanyUncheckedCreateWithoutItemMastersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutItemMastersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutItemMastersInput, CompanyUncheckedUpdateWithoutItemMastersInput>
  }

  export type CompanyUpdateWithoutItemMastersInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutItemMastersInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutItemMasterInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutItemMasterInput, PurchaseOrderItemUncheckedUpdateWithoutItemMasterInput>
    create: XOR<PurchaseOrderItemCreateWithoutItemMasterInput, PurchaseOrderItemUncheckedCreateWithoutItemMasterInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutItemMasterInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutItemMasterInput, PurchaseOrderItemUncheckedUpdateWithoutItemMasterInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutItemMasterInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterInput>
  }

  export type GRNItemUpsertWithWhereUniqueWithoutItemMasterInput = {
    where: GRNItemWhereUniqueInput
    update: XOR<GRNItemUpdateWithoutItemMasterInput, GRNItemUncheckedUpdateWithoutItemMasterInput>
    create: XOR<GRNItemCreateWithoutItemMasterInput, GRNItemUncheckedCreateWithoutItemMasterInput>
  }

  export type GRNItemUpdateWithWhereUniqueWithoutItemMasterInput = {
    where: GRNItemWhereUniqueInput
    data: XOR<GRNItemUpdateWithoutItemMasterInput, GRNItemUncheckedUpdateWithoutItemMasterInput>
  }

  export type GRNItemUpdateManyWithWhereWithoutItemMasterInput = {
    where: GRNItemScalarWhereInput
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyWithoutItemMasterInput>
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemMasterInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutItemMasterInput, PurchaseInvoiceItemUncheckedUpdateWithoutItemMasterInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutItemMasterInput, PurchaseInvoiceItemUncheckedCreateWithoutItemMasterInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemMasterInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutItemMasterInput, PurchaseInvoiceItemUncheckedUpdateWithoutItemMasterInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutItemMasterInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterInput>
  }

  export type PurchaseReturnItemUpsertWithWhereUniqueWithoutItemMasterInput = {
    where: PurchaseReturnItemWhereUniqueInput
    update: XOR<PurchaseReturnItemUpdateWithoutItemMasterInput, PurchaseReturnItemUncheckedUpdateWithoutItemMasterInput>
    create: XOR<PurchaseReturnItemCreateWithoutItemMasterInput, PurchaseReturnItemUncheckedCreateWithoutItemMasterInput>
  }

  export type PurchaseReturnItemUpdateWithWhereUniqueWithoutItemMasterInput = {
    where: PurchaseReturnItemWhereUniqueInput
    data: XOR<PurchaseReturnItemUpdateWithoutItemMasterInput, PurchaseReturnItemUncheckedUpdateWithoutItemMasterInput>
  }

  export type PurchaseReturnItemUpdateManyWithWhereWithoutItemMasterInput = {
    where: PurchaseReturnItemScalarWhereInput
    data: XOR<PurchaseReturnItemUpdateManyMutationInput, PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterInput>
  }

  export type AccountCreateWithoutPurchaseOrdersInput = {
    code: string
    name: string
    type: $Enums.AccountType
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    parentId?: number | null
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutPurchaseOrdersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPurchaseOrdersInput, AccountUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type WarehouseCreateWithoutPurchaseOrdersInput = {
    name: string
    location?: string | null
    contactPerson?: string | null
    contactNumbers?: WarehouseCreatecontactNumbersInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userWarehouses?: UserWarehouseCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    name: string
    location?: string | null
    contactPerson?: string | null
    contactNumbers?: WarehouseCreatecontactNumbersInput | string[]
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userWarehouses?: UserWarehouseUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehouseCreateOrConnectWithoutPurchaseOrdersInput = {
    where: WarehouseWhereUniqueInput
    create: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type CurrencyCreateWithoutPurchaseOrdersInput = {
    code: string
    symbol: string
    isBase?: boolean
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    code: string
    symbol: string
    isBase?: boolean
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyCreateOrConnectWithoutPurchaseOrdersInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutPurchaseOrdersInput, CurrencyUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type CompanyCreateWithoutPurchaseOrdersInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPurchaseOrdersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type PurchaseOrderItemCreateWithoutPurchaseOrderInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseOrderItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseOrderItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseOrderItemsInput
    grnItems?: GRNItemCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseOrderItemCreateManyPurchaseOrderInput | PurchaseOrderItemCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type GRNCreateWithoutPurchaseOrderInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutGrnsInput
    items?: GRNItemCreateNestedManyWithoutGrnInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutGrnInput
  }

  export type GRNUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: GRNItemUncheckedCreateNestedManyWithoutGrnInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutGrnInput
  }

  export type GRNCreateOrConnectWithoutPurchaseOrderInput = {
    where: GRNWhereUniqueInput
    create: XOR<GRNCreateWithoutPurchaseOrderInput, GRNUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type GRNCreateManyPurchaseOrderInputEnvelope = {
    data: GRNCreateManyPurchaseOrderInput | GRNCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceCreateWithoutPurchaseOrderInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutPurchaseInvoicesInput
    company: CompanyCreateNestedOneWithoutPurchaseInvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutInvoiceInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutPurchaseOrderInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutPurchaseOrderInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseInvoiceCreateManyPurchaseOrderInputEnvelope = {
    data: PurchaseInvoiceCreateManyPurchaseOrderInput | PurchaseInvoiceCreateManyPurchaseOrderInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutPurchaseOrdersInput = {
    update: XOR<AccountUpdateWithoutPurchaseOrdersInput, AccountUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<AccountCreateWithoutPurchaseOrdersInput, AccountUncheckedCreateWithoutPurchaseOrdersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutPurchaseOrdersInput, AccountUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type AccountUpdateWithoutPurchaseOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type WarehouseUpsertWithoutPurchaseOrdersInput = {
    update: XOR<WarehouseUpdateWithoutPurchaseOrdersInput, WarehouseUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<WarehouseCreateWithoutPurchaseOrdersInput, WarehouseUncheckedCreateWithoutPurchaseOrdersInput>
    where?: WarehouseWhereInput
  }

  export type WarehouseUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: WarehouseWhereInput
    data: XOR<WarehouseUpdateWithoutPurchaseOrdersInput, WarehouseUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type WarehouseUpdateWithoutPurchaseOrdersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumbers?: WarehouseUpdatecontactNumbersInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userWarehouses?: UserWarehouseUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumbers?: WarehouseUpdatecontactNumbersInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type CurrencyUpsertWithoutPurchaseOrdersInput = {
    update: XOR<CurrencyUpdateWithoutPurchaseOrdersInput, CurrencyUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<CurrencyCreateWithoutPurchaseOrdersInput, CurrencyUncheckedCreateWithoutPurchaseOrdersInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutPurchaseOrdersInput, CurrencyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type CurrencyUpdateWithoutPurchaseOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUpsertWithoutPurchaseOrdersInput = {
    update: XOR<CompanyUpdateWithoutPurchaseOrdersInput, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<CompanyCreateWithoutPurchaseOrdersInput, CompanyUncheckedCreateWithoutPurchaseOrdersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPurchaseOrdersInput, CompanyUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type CompanyUpdateWithoutPurchaseOrdersInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseOrderItemCreateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutPurchaseOrderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type GRNUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: GRNWhereUniqueInput
    update: XOR<GRNUpdateWithoutPurchaseOrderInput, GRNUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<GRNCreateWithoutPurchaseOrderInput, GRNUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type GRNUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: GRNWhereUniqueInput
    data: XOR<GRNUpdateWithoutPurchaseOrderInput, GRNUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type GRNUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: GRNScalarWhereInput
    data: XOR<GRNUpdateManyMutationInput, GRNUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseInvoiceUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseInvoiceWhereUniqueInput
    update: XOR<PurchaseInvoiceUpdateWithoutPurchaseOrderInput, PurchaseInvoiceUncheckedUpdateWithoutPurchaseOrderInput>
    create: XOR<PurchaseInvoiceCreateWithoutPurchaseOrderInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseOrderInput>
  }

  export type PurchaseInvoiceUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
    where: PurchaseInvoiceWhereUniqueInput
    data: XOR<PurchaseInvoiceUpdateWithoutPurchaseOrderInput, PurchaseInvoiceUncheckedUpdateWithoutPurchaseOrderInput>
  }

  export type PurchaseInvoiceUpdateManyWithWhereWithoutPurchaseOrderInput = {
    where: PurchaseInvoiceScalarWhereInput
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderInput>
  }

  export type PurchaseOrderCreateWithoutItemsInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutPurchaseOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    currency?: CurrencyCreateNestedOneWithoutPurchaseOrdersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    grns?: GRNCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    grns?: GRNUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type ItemMasterCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroup: ItemGroupCreateNestedOneWithoutItemMastersInput
    baseUnit: UnitCreateNestedOneWithoutItemMastersInput
    packingUnit?: PackingUnitCreateNestedOneWithoutItemMastersInput
    company: CompanyCreateNestedOneWithoutItemMastersInput
    grnItems?: GRNItemCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: ItemMasterWhereUniqueInput
    create: XOR<ItemMasterCreateWithoutPurchaseOrderItemsInput, ItemMasterUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type ColorCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutColorsInput
    grnItems?: GRNItemCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutColorInput
  }

  export type ColorUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutColorInput
  }

  export type ColorCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: ColorWhereUniqueInput
    create: XOR<ColorCreateWithoutPurchaseOrderItemsInput, ColorUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type BrandCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBrandsInput
    grnItems?: GRNItemCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutPurchaseOrderItemsInput, BrandUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type ItemGradeCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutItemGradesInput
    grnItems?: GRNItemCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: ItemGradeWhereUniqueInput
    create: XOR<ItemGradeCreateWithoutPurchaseOrderItemsInput, ItemGradeUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type PackingUnitCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPackingUnitsInput
    itemMasters?: ItemMasterCreateNestedManyWithoutPackingUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutPackingUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: PackingUnitWhereUniqueInput
    create: XOR<PackingUnitCreateWithoutPurchaseOrderItemsInput, PackingUnitUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type UnitCreateWithoutPurchaseOrderItemsInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitsInput
    conversionsFrom?: UnitConversionCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionCreateNestedManyWithoutToUnitInput
    products?: ProductCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterCreateNestedManyWithoutBaseUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutPurchaseOrderItemsInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionUncheckedCreateNestedManyWithoutToUnitInput
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutPurchaseOrderItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutPurchaseOrderItemsInput, UnitUncheckedCreateWithoutPurchaseOrderItemsInput>
  }

  export type GRNItemCreateWithoutPurchaseOrderItemInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grn: GRNCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutGrnItemsInput
    color?: ColorCreateNestedOneWithoutGrnItemsInput
    brand?: BrandCreateNestedOneWithoutGrnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutGrnItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutGrnItemsInput
    unit?: UnitCreateNestedOneWithoutGrnItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUncheckedCreateWithoutPurchaseOrderItemInput = {
    id?: string
    grnId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemCreateOrConnectWithoutPurchaseOrderItemInput = {
    where: GRNItemWhereUniqueInput
    create: XOR<GRNItemCreateWithoutPurchaseOrderItemInput, GRNItemUncheckedCreateWithoutPurchaseOrderItemInput>
  }

  export type GRNItemCreateManyPurchaseOrderItemInputEnvelope = {
    data: GRNItemCreateManyPurchaseOrderItemInput | GRNItemCreateManyPurchaseOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput = {
    id?: string
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
    grnItem?: GRNItemCreateNestedOneWithoutInvoiceItemsInput
    itemMaster?: ItemMasterCreateNestedOneWithoutPurchaseInvoiceItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseInvoiceItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseInvoiceItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseInvoiceItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseInvoiceItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput = {
    id?: string
    invoiceId: string
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutPurchaseOrderItemInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput>
  }

  export type PurchaseInvoiceItemCreateManyPurchaseOrderItemInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyPurchaseOrderItemInput | PurchaseInvoiceItemCreateManyPurchaseOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutPurchaseOrdersNestedInput
    currency?: CurrencyUpdateOneWithoutPurchaseOrdersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    grns?: GRNUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grns?: GRNUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type ItemMasterUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<ItemMasterUpdateWithoutPurchaseOrderItemsInput, ItemMasterUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<ItemMasterCreateWithoutPurchaseOrderItemsInput, ItemMasterUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: ItemMasterWhereInput
  }

  export type ItemMasterUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: ItemMasterWhereInput
    data: XOR<ItemMasterUpdateWithoutPurchaseOrderItemsInput, ItemMasterUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type ItemMasterUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroup?: ItemGroupUpdateOneRequiredWithoutItemMastersNestedInput
    baseUnit?: UnitUpdateOneRequiredWithoutItemMastersNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutItemMastersNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemMastersNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterNestedInput
  }

  export type ColorUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<ColorUpdateWithoutPurchaseOrderItemsInput, ColorUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<ColorCreateWithoutPurchaseOrderItemsInput, ColorUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: ColorWhereInput
  }

  export type ColorUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: ColorWhereInput
    data: XOR<ColorUpdateWithoutPurchaseOrderItemsInput, ColorUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type ColorUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutColorsNestedInput
    grnItems?: GRNItemUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutColorNestedInput
  }

  export type ColorUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutColorNestedInput
  }

  export type BrandUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<BrandUpdateWithoutPurchaseOrderItemsInput, BrandUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<BrandCreateWithoutPurchaseOrderItemsInput, BrandUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutPurchaseOrderItemsInput, BrandUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type BrandUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBrandsNestedInput
    grnItems?: GRNItemUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ItemGradeUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<ItemGradeUpdateWithoutPurchaseOrderItemsInput, ItemGradeUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<ItemGradeCreateWithoutPurchaseOrderItemsInput, ItemGradeUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: ItemGradeWhereInput
  }

  export type ItemGradeUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: ItemGradeWhereInput
    data: XOR<ItemGradeUpdateWithoutPurchaseOrderItemsInput, ItemGradeUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type ItemGradeUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutItemGradesNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemGradeNestedInput
  }

  export type ItemGradeUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemGradeNestedInput
  }

  export type PackingUnitUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<PackingUnitUpdateWithoutPurchaseOrderItemsInput, PackingUnitUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<PackingUnitCreateWithoutPurchaseOrderItemsInput, PackingUnitUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: PackingUnitWhereInput
  }

  export type PackingUnitUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: PackingUnitWhereInput
    data: XOR<PackingUnitUpdateWithoutPurchaseOrderItemsInput, PackingUnitUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type PackingUnitUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPackingUnitsNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutPackingUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutPackingUnitNestedInput
  }

  export type PackingUnitUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutPackingUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutPackingUnitNestedInput
  }

  export type UnitUpsertWithoutPurchaseOrderItemsInput = {
    update: XOR<UnitUpdateWithoutPurchaseOrderItemsInput, UnitUncheckedUpdateWithoutPurchaseOrderItemsInput>
    create: XOR<UnitCreateWithoutPurchaseOrderItemsInput, UnitUncheckedCreateWithoutPurchaseOrderItemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutPurchaseOrderItemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutPurchaseOrderItemsInput, UnitUncheckedUpdateWithoutPurchaseOrderItemsInput>
  }

  export type UnitUpdateWithoutPurchaseOrderItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitsNestedInput
    conversionsFrom?: UnitConversionUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUpdateManyWithoutToUnitNestedInput
    products?: ProductUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutBaseUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutPurchaseOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type GRNItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput = {
    where: GRNItemWhereUniqueInput
    update: XOR<GRNItemUpdateWithoutPurchaseOrderItemInput, GRNItemUncheckedUpdateWithoutPurchaseOrderItemInput>
    create: XOR<GRNItemCreateWithoutPurchaseOrderItemInput, GRNItemUncheckedCreateWithoutPurchaseOrderItemInput>
  }

  export type GRNItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput = {
    where: GRNItemWhereUniqueInput
    data: XOR<GRNItemUpdateWithoutPurchaseOrderItemInput, GRNItemUncheckedUpdateWithoutPurchaseOrderItemInput>
  }

  export type GRNItemUpdateManyWithWhereWithoutPurchaseOrderItemInput = {
    where: GRNItemScalarWhereInput
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemInput>
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseOrderItemInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutPurchaseOrderItemInput, PurchaseInvoiceItemUncheckedUpdateWithoutPurchaseOrderItemInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutPurchaseOrderItemInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseOrderItemInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseOrderItemInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutPurchaseOrderItemInput, PurchaseInvoiceItemUncheckedUpdateWithoutPurchaseOrderItemInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseOrderItemInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemInput>
  }

  export type PurchaseOrderCreateWithoutGrnsInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutPurchaseOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    currency?: CurrencyCreateNestedOneWithoutPurchaseOrdersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutGrnsInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    invoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutGrnsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutGrnsInput, PurchaseOrderUncheckedCreateWithoutGrnsInput>
  }

  export type CompanyCreateWithoutGrnsInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutGrnsInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutGrnsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutGrnsInput, CompanyUncheckedCreateWithoutGrnsInput>
  }

  export type GRNItemCreateWithoutGrnInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItem: PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutGrnItemsInput
    color?: ColorCreateNestedOneWithoutGrnItemsInput
    brand?: BrandCreateNestedOneWithoutGrnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutGrnItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutGrnItemsInput
    unit?: UnitCreateNestedOneWithoutGrnItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemUncheckedCreateWithoutGrnInput = {
    id?: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutGrnItemInput
  }

  export type GRNItemCreateOrConnectWithoutGrnInput = {
    where: GRNItemWhereUniqueInput
    create: XOR<GRNItemCreateWithoutGrnInput, GRNItemUncheckedCreateWithoutGrnInput>
  }

  export type GRNItemCreateManyGrnInputEnvelope = {
    data: GRNItemCreateManyGrnInput | GRNItemCreateManyGrnInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnCreateWithoutGrnInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseInvoice?: PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnsInput
    account?: AccountCreateNestedOneWithoutPurchaseReturnsInput
    company: CompanyCreateNestedOneWithoutPurchaseReturnsInput
    items?: PurchaseReturnItemCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnUncheckedCreateWithoutGrnInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    purchaseInvoiceId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseReturnItemUncheckedCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnCreateOrConnectWithoutGrnInput = {
    where: PurchaseReturnWhereUniqueInput
    create: XOR<PurchaseReturnCreateWithoutGrnInput, PurchaseReturnUncheckedCreateWithoutGrnInput>
  }

  export type PurchaseReturnCreateManyGrnInputEnvelope = {
    data: PurchaseReturnCreateManyGrnInput | PurchaseReturnCreateManyGrnInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithoutGrnsInput = {
    update: XOR<PurchaseOrderUpdateWithoutGrnsInput, PurchaseOrderUncheckedUpdateWithoutGrnsInput>
    create: XOR<PurchaseOrderCreateWithoutGrnsInput, PurchaseOrderUncheckedCreateWithoutGrnsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutGrnsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutGrnsInput, PurchaseOrderUncheckedUpdateWithoutGrnsInput>
  }

  export type PurchaseOrderUpdateWithoutGrnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutPurchaseOrdersNestedInput
    currency?: CurrencyUpdateOneWithoutPurchaseOrdersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutGrnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type CompanyUpsertWithoutGrnsInput = {
    update: XOR<CompanyUpdateWithoutGrnsInput, CompanyUncheckedUpdateWithoutGrnsInput>
    create: XOR<CompanyCreateWithoutGrnsInput, CompanyUncheckedCreateWithoutGrnsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutGrnsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutGrnsInput, CompanyUncheckedUpdateWithoutGrnsInput>
  }

  export type CompanyUpdateWithoutGrnsInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutGrnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type GRNItemUpsertWithWhereUniqueWithoutGrnInput = {
    where: GRNItemWhereUniqueInput
    update: XOR<GRNItemUpdateWithoutGrnInput, GRNItemUncheckedUpdateWithoutGrnInput>
    create: XOR<GRNItemCreateWithoutGrnInput, GRNItemUncheckedCreateWithoutGrnInput>
  }

  export type GRNItemUpdateWithWhereUniqueWithoutGrnInput = {
    where: GRNItemWhereUniqueInput
    data: XOR<GRNItemUpdateWithoutGrnInput, GRNItemUncheckedUpdateWithoutGrnInput>
  }

  export type GRNItemUpdateManyWithWhereWithoutGrnInput = {
    where: GRNItemScalarWhereInput
    data: XOR<GRNItemUpdateManyMutationInput, GRNItemUncheckedUpdateManyWithoutGrnInput>
  }

  export type PurchaseReturnUpsertWithWhereUniqueWithoutGrnInput = {
    where: PurchaseReturnWhereUniqueInput
    update: XOR<PurchaseReturnUpdateWithoutGrnInput, PurchaseReturnUncheckedUpdateWithoutGrnInput>
    create: XOR<PurchaseReturnCreateWithoutGrnInput, PurchaseReturnUncheckedCreateWithoutGrnInput>
  }

  export type PurchaseReturnUpdateWithWhereUniqueWithoutGrnInput = {
    where: PurchaseReturnWhereUniqueInput
    data: XOR<PurchaseReturnUpdateWithoutGrnInput, PurchaseReturnUncheckedUpdateWithoutGrnInput>
  }

  export type PurchaseReturnUpdateManyWithWhereWithoutGrnInput = {
    where: PurchaseReturnScalarWhereInput
    data: XOR<PurchaseReturnUpdateManyMutationInput, PurchaseReturnUncheckedUpdateManyWithoutGrnInput>
  }

  export type GRNCreateWithoutItemsInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutGrnsInput
    company: CompanyCreateNestedOneWithoutGrnsInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutGrnInput
  }

  export type GRNUncheckedCreateWithoutItemsInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    purchaseOrderId: string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutGrnInput
  }

  export type GRNCreateOrConnectWithoutItemsInput = {
    where: GRNWhereUniqueInput
    create: XOR<GRNCreateWithoutItemsInput, GRNUncheckedCreateWithoutItemsInput>
  }

  export type PurchaseOrderItemCreateWithoutGrnItemsInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseOrderItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseOrderItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseOrderItemsInput
    invoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutGrnItemsInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemCreateOrConnectWithoutGrnItemsInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutGrnItemsInput, PurchaseOrderItemUncheckedCreateWithoutGrnItemsInput>
  }

  export type ItemMasterCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroup: ItemGroupCreateNestedOneWithoutItemMastersInput
    baseUnit: UnitCreateNestedOneWithoutItemMastersInput
    packingUnit?: PackingUnitCreateNestedOneWithoutItemMastersInput
    company: CompanyCreateNestedOneWithoutItemMastersInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUncheckedCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterCreateOrConnectWithoutGrnItemsInput = {
    where: ItemMasterWhereUniqueInput
    create: XOR<ItemMasterCreateWithoutGrnItemsInput, ItemMasterUncheckedCreateWithoutGrnItemsInput>
  }

  export type ColorCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutColorsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutColorInput
  }

  export type ColorUncheckedCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutColorInput
  }

  export type ColorCreateOrConnectWithoutGrnItemsInput = {
    where: ColorWhereUniqueInput
    create: XOR<ColorCreateWithoutGrnItemsInput, ColorUncheckedCreateWithoutGrnItemsInput>
  }

  export type BrandCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBrandsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutGrnItemsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutGrnItemsInput, BrandUncheckedCreateWithoutGrnItemsInput>
  }

  export type ItemGradeCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutItemGradesInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeUncheckedCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeCreateOrConnectWithoutGrnItemsInput = {
    where: ItemGradeWhereUniqueInput
    create: XOR<ItemGradeCreateWithoutGrnItemsInput, ItemGradeUncheckedCreateWithoutGrnItemsInput>
  }

  export type PackingUnitCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutPackingUnitsInput
    itemMasters?: ItemMasterCreateNestedManyWithoutPackingUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitUncheckedCreateWithoutGrnItemsInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutPackingUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPackingUnitInput
  }

  export type PackingUnitCreateOrConnectWithoutGrnItemsInput = {
    where: PackingUnitWhereUniqueInput
    create: XOR<PackingUnitCreateWithoutGrnItemsInput, PackingUnitUncheckedCreateWithoutGrnItemsInput>
  }

  export type UnitCreateWithoutGrnItemsInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitsInput
    conversionsFrom?: UnitConversionCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionCreateNestedManyWithoutToUnitInput
    products?: ProductCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutGrnItemsInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionUncheckedCreateNestedManyWithoutToUnitInput
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutGrnItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutGrnItemsInput, UnitUncheckedCreateWithoutGrnItemsInput>
  }

  export type PurchaseInvoiceItemCreateWithoutGrnItemInput = {
    id?: string
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
    purchaseOrderItem?: PurchaseOrderItemCreateNestedOneWithoutInvoiceItemsInput
    itemMaster?: ItemMasterCreateNestedOneWithoutPurchaseInvoiceItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseInvoiceItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseInvoiceItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseInvoiceItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseInvoiceItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutGrnItemInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutGrnItemInput, PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput>
  }

  export type PurchaseInvoiceItemCreateManyGrnItemInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyGrnItemInput | PurchaseInvoiceItemCreateManyGrnItemInput[]
    skipDuplicates?: boolean
  }

  export type GRNUpsertWithoutItemsInput = {
    update: XOR<GRNUpdateWithoutItemsInput, GRNUncheckedUpdateWithoutItemsInput>
    create: XOR<GRNCreateWithoutItemsInput, GRNUncheckedCreateWithoutItemsInput>
    where?: GRNWhereInput
  }

  export type GRNUpdateToOneWithWhereWithoutItemsInput = {
    where?: GRNWhereInput
    data: XOR<GRNUpdateWithoutItemsInput, GRNUncheckedUpdateWithoutItemsInput>
  }

  export type GRNUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutGrnsNestedInput
    company?: CompanyUpdateOneRequiredWithoutGrnsNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutGrnNestedInput
  }

  export type GRNUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutGrnNestedInput
  }

  export type PurchaseOrderItemUpsertWithoutGrnItemsInput = {
    update: XOR<PurchaseOrderItemUpdateWithoutGrnItemsInput, PurchaseOrderItemUncheckedUpdateWithoutGrnItemsInput>
    create: XOR<PurchaseOrderItemCreateWithoutGrnItemsInput, PurchaseOrderItemUncheckedCreateWithoutGrnItemsInput>
    where?: PurchaseOrderItemWhereInput
  }

  export type PurchaseOrderItemUpdateToOneWithWhereWithoutGrnItemsInput = {
    where?: PurchaseOrderItemWhereInput
    data: XOR<PurchaseOrderItemUpdateWithoutGrnItemsInput, PurchaseOrderItemUncheckedUpdateWithoutGrnItemsInput>
  }

  export type PurchaseOrderItemUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseOrderItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseOrderItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type ItemMasterUpsertWithoutGrnItemsInput = {
    update: XOR<ItemMasterUpdateWithoutGrnItemsInput, ItemMasterUncheckedUpdateWithoutGrnItemsInput>
    create: XOR<ItemMasterCreateWithoutGrnItemsInput, ItemMasterUncheckedCreateWithoutGrnItemsInput>
    where?: ItemMasterWhereInput
  }

  export type ItemMasterUpdateToOneWithWhereWithoutGrnItemsInput = {
    where?: ItemMasterWhereInput
    data: XOR<ItemMasterUpdateWithoutGrnItemsInput, ItemMasterUncheckedUpdateWithoutGrnItemsInput>
  }

  export type ItemMasterUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroup?: ItemGroupUpdateOneRequiredWithoutItemMastersNestedInput
    baseUnit?: UnitUpdateOneRequiredWithoutItemMastersNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutItemMastersNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemMastersNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterNestedInput
  }

  export type ColorUpsertWithoutGrnItemsInput = {
    update: XOR<ColorUpdateWithoutGrnItemsInput, ColorUncheckedUpdateWithoutGrnItemsInput>
    create: XOR<ColorCreateWithoutGrnItemsInput, ColorUncheckedCreateWithoutGrnItemsInput>
    where?: ColorWhereInput
  }

  export type ColorUpdateToOneWithWhereWithoutGrnItemsInput = {
    where?: ColorWhereInput
    data: XOR<ColorUpdateWithoutGrnItemsInput, ColorUncheckedUpdateWithoutGrnItemsInput>
  }

  export type ColorUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutColorsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutColorNestedInput
  }

  export type ColorUncheckedUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutColorNestedInput
  }

  export type BrandUpsertWithoutGrnItemsInput = {
    update: XOR<BrandUpdateWithoutGrnItemsInput, BrandUncheckedUpdateWithoutGrnItemsInput>
    create: XOR<BrandCreateWithoutGrnItemsInput, BrandUncheckedCreateWithoutGrnItemsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutGrnItemsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutGrnItemsInput, BrandUncheckedUpdateWithoutGrnItemsInput>
  }

  export type BrandUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBrandsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ItemGradeUpsertWithoutGrnItemsInput = {
    update: XOR<ItemGradeUpdateWithoutGrnItemsInput, ItemGradeUncheckedUpdateWithoutGrnItemsInput>
    create: XOR<ItemGradeCreateWithoutGrnItemsInput, ItemGradeUncheckedCreateWithoutGrnItemsInput>
    where?: ItemGradeWhereInput
  }

  export type ItemGradeUpdateToOneWithWhereWithoutGrnItemsInput = {
    where?: ItemGradeWhereInput
    data: XOR<ItemGradeUpdateWithoutGrnItemsInput, ItemGradeUncheckedUpdateWithoutGrnItemsInput>
  }

  export type ItemGradeUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutItemGradesNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemGradeNestedInput
  }

  export type ItemGradeUncheckedUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemGradeNestedInput
  }

  export type PackingUnitUpsertWithoutGrnItemsInput = {
    update: XOR<PackingUnitUpdateWithoutGrnItemsInput, PackingUnitUncheckedUpdateWithoutGrnItemsInput>
    create: XOR<PackingUnitCreateWithoutGrnItemsInput, PackingUnitUncheckedCreateWithoutGrnItemsInput>
    where?: PackingUnitWhereInput
  }

  export type PackingUnitUpdateToOneWithWhereWithoutGrnItemsInput = {
    where?: PackingUnitWhereInput
    data: XOR<PackingUnitUpdateWithoutGrnItemsInput, PackingUnitUncheckedUpdateWithoutGrnItemsInput>
  }

  export type PackingUnitUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutPackingUnitsNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutPackingUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutPackingUnitNestedInput
  }

  export type PackingUnitUncheckedUpdateWithoutGrnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutPackingUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutPackingUnitNestedInput
  }

  export type UnitUpsertWithoutGrnItemsInput = {
    update: XOR<UnitUpdateWithoutGrnItemsInput, UnitUncheckedUpdateWithoutGrnItemsInput>
    create: XOR<UnitCreateWithoutGrnItemsInput, UnitUncheckedCreateWithoutGrnItemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutGrnItemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutGrnItemsInput, UnitUncheckedUpdateWithoutGrnItemsInput>
  }

  export type UnitUpdateWithoutGrnItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitsNestedInput
    conversionsFrom?: UnitConversionUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUpdateManyWithoutToUnitNestedInput
    products?: ProductUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutGrnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutGrnItemInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutGrnItemInput, PurchaseInvoiceItemUncheckedUpdateWithoutGrnItemInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutGrnItemInput, PurchaseInvoiceItemUncheckedCreateWithoutGrnItemInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutGrnItemInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutGrnItemInput, PurchaseInvoiceItemUncheckedUpdateWithoutGrnItemInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutGrnItemInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemInput>
  }

  export type PurchaseOrderCreateWithoutInvoicesInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account?: AccountCreateNestedOneWithoutPurchaseOrdersInput
    warehouse?: WarehouseCreateNestedOneWithoutPurchaseOrdersInput
    currency?: CurrencyCreateNestedOneWithoutPurchaseOrdersInput
    company: CompanyCreateNestedOneWithoutPurchaseOrdersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutInvoicesInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchaseOrderInput
    grns?: GRNUncheckedCreateNestedManyWithoutPurchaseOrderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutInvoicesInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
  }

  export type AccountCreateWithoutPurchaseInvoicesInput = {
    code: string
    name: string
    type: $Enums.AccountType
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutPurchaseInvoicesInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    parentId?: number | null
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutAccountInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutPurchaseInvoicesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPurchaseInvoicesInput, AccountUncheckedCreateWithoutPurchaseInvoicesInput>
  }

  export type CompanyCreateWithoutPurchaseInvoicesInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPurchaseInvoicesInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPurchaseInvoicesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPurchaseInvoicesInput, CompanyUncheckedCreateWithoutPurchaseInvoicesInput>
  }

  export type PurchaseInvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItem?: PurchaseOrderItemCreateNestedOneWithoutInvoiceItemsInput
    grnItem?: GRNItemCreateNestedOneWithoutInvoiceItemsInput
    itemMaster?: ItemMasterCreateNestedOneWithoutPurchaseInvoiceItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseInvoiceItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseInvoiceItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseInvoiceItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseInvoiceItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type PurchaseInvoiceItemCreateManyInvoiceInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyInvoiceInput | PurchaseInvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnCreateWithoutPurchaseInvoiceInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grn?: GRNCreateNestedOneWithoutPurchaseReturnsInput
    account?: AccountCreateNestedOneWithoutPurchaseReturnsInput
    company: CompanyCreateNestedOneWithoutPurchaseReturnsInput
    items?: PurchaseReturnItemCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    grnId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseReturnItemUncheckedCreateNestedManyWithoutReturnInput
  }

  export type PurchaseReturnCreateOrConnectWithoutPurchaseInvoiceInput = {
    where: PurchaseReturnWhereUniqueInput
    create: XOR<PurchaseReturnCreateWithoutPurchaseInvoiceInput, PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseReturnCreateManyPurchaseInvoiceInputEnvelope = {
    data: PurchaseReturnCreateManyPurchaseInvoiceInput | PurchaseReturnCreateManyPurchaseInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithoutInvoicesInput = {
    update: XOR<PurchaseOrderUpdateWithoutInvoicesInput, PurchaseOrderUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PurchaseOrderCreateWithoutInvoicesInput, PurchaseOrderUncheckedCreateWithoutInvoicesInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutInvoicesInput, PurchaseOrderUncheckedUpdateWithoutInvoicesInput>
  }

  export type PurchaseOrderUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutPurchaseOrdersNestedInput
    currency?: CurrencyUpdateOneWithoutPurchaseOrdersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type AccountUpsertWithoutPurchaseInvoicesInput = {
    update: XOR<AccountUpdateWithoutPurchaseInvoicesInput, AccountUncheckedUpdateWithoutPurchaseInvoicesInput>
    create: XOR<AccountCreateWithoutPurchaseInvoicesInput, AccountUncheckedCreateWithoutPurchaseInvoicesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutPurchaseInvoicesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutPurchaseInvoicesInput, AccountUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type AccountUpdateWithoutPurchaseInvoicesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutPurchaseInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CompanyUpsertWithoutPurchaseInvoicesInput = {
    update: XOR<CompanyUpdateWithoutPurchaseInvoicesInput, CompanyUncheckedUpdateWithoutPurchaseInvoicesInput>
    create: XOR<CompanyCreateWithoutPurchaseInvoicesInput, CompanyUncheckedCreateWithoutPurchaseInvoicesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPurchaseInvoicesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPurchaseInvoicesInput, CompanyUncheckedUpdateWithoutPurchaseInvoicesInput>
  }

  export type CompanyUpdateWithoutPurchaseInvoicesInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPurchaseInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutInvoiceInput, PurchaseInvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PurchaseReturnUpsertWithWhereUniqueWithoutPurchaseInvoiceInput = {
    where: PurchaseReturnWhereUniqueInput
    update: XOR<PurchaseReturnUpdateWithoutPurchaseInvoiceInput, PurchaseReturnUncheckedUpdateWithoutPurchaseInvoiceInput>
    create: XOR<PurchaseReturnCreateWithoutPurchaseInvoiceInput, PurchaseReturnUncheckedCreateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseReturnUpdateWithWhereUniqueWithoutPurchaseInvoiceInput = {
    where: PurchaseReturnWhereUniqueInput
    data: XOR<PurchaseReturnUpdateWithoutPurchaseInvoiceInput, PurchaseReturnUncheckedUpdateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseReturnUpdateManyWithWhereWithoutPurchaseInvoiceInput = {
    where: PurchaseReturnScalarWhereInput
    data: XOR<PurchaseReturnUpdateManyMutationInput, PurchaseReturnUncheckedUpdateManyWithoutPurchaseInvoiceInput>
  }

  export type PurchaseInvoiceCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    account?: AccountCreateNestedOneWithoutPurchaseInvoicesInput
    company: CompanyCreateNestedOneWithoutPurchaseInvoicesInput
    purchaseReturns?: PurchaseReturnCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    purchaseOrderId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseReturns?: PurchaseReturnUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutItemsInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type PurchaseOrderItemCreateWithoutInvoiceItemsInput = {
    id?: string
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseOrderItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseOrderItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseOrderItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseOrderItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutPurchaseOrderItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseOrderItemsInput
    grnItems?: GRNItemCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutPurchaseOrderItemInput
  }

  export type PurchaseOrderItemCreateOrConnectWithoutInvoiceItemsInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutInvoiceItemsInput, PurchaseOrderItemUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type GRNItemCreateWithoutInvoiceItemsInput = {
    id?: string
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grn: GRNCreateNestedOneWithoutItemsInput
    purchaseOrderItem: PurchaseOrderItemCreateNestedOneWithoutGrnItemsInput
    itemMaster: ItemMasterCreateNestedOneWithoutGrnItemsInput
    color?: ColorCreateNestedOneWithoutGrnItemsInput
    brand?: BrandCreateNestedOneWithoutGrnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutGrnItemsInput
    packingUnit?: PackingUnitCreateNestedOneWithoutGrnItemsInput
    unit?: UnitCreateNestedOneWithoutGrnItemsInput
  }

  export type GRNItemUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemCreateOrConnectWithoutInvoiceItemsInput = {
    where: GRNItemWhereUniqueInput
    create: XOR<GRNItemCreateWithoutInvoiceItemsInput, GRNItemUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type ItemMasterCreateWithoutPurchaseInvoiceItemsInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroup: ItemGroupCreateNestedOneWithoutItemMastersInput
    baseUnit: UnitCreateNestedOneWithoutItemMastersInput
    packingUnit?: PackingUnitCreateNestedOneWithoutItemMastersInput
    company: CompanyCreateNestedOneWithoutItemMastersInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUncheckedCreateWithoutPurchaseInvoiceItemsInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterCreateOrConnectWithoutPurchaseInvoiceItemsInput = {
    where: ItemMasterWhereUniqueInput
    create: XOR<ItemMasterCreateWithoutPurchaseInvoiceItemsInput, ItemMasterUncheckedCreateWithoutPurchaseInvoiceItemsInput>
  }

  export type ColorCreateWithoutPurchaseInvoiceItemsInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutColorsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutColorInput
    grnItems?: GRNItemCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutColorInput
  }

  export type ColorUncheckedCreateWithoutPurchaseInvoiceItemsInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutColorInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutColorInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutColorInput
  }

  export type ColorCreateOrConnectWithoutPurchaseInvoiceItemsInput = {
    where: ColorWhereUniqueInput
    create: XOR<ColorCreateWithoutPurchaseInvoiceItemsInput, ColorUncheckedCreateWithoutPurchaseInvoiceItemsInput>
  }

  export type BrandCreateWithoutPurchaseInvoiceItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBrandsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutBrandInput
    grnItems?: GRNItemCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutPurchaseInvoiceItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutBrandInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutPurchaseInvoiceItemsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutPurchaseInvoiceItemsInput, BrandUncheckedCreateWithoutPurchaseInvoiceItemsInput>
  }

  export type ItemGradeCreateWithoutPurchaseInvoiceItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutItemGradesInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemGradeInput
    grnItems?: GRNItemCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeUncheckedCreateWithoutPurchaseInvoiceItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemGradeInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeCreateOrConnectWithoutPurchaseInvoiceItemsInput = {
    where: ItemGradeWhereUniqueInput
    create: XOR<ItemGradeCreateWithoutPurchaseInvoiceItemsInput, ItemGradeUncheckedCreateWithoutPurchaseInvoiceItemsInput>
  }

  export type UnitCreateWithoutPurchaseInvoiceItemsInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitsInput
    conversionsFrom?: UnitConversionCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionCreateNestedManyWithoutToUnitInput
    products?: ProductCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutPurchaseInvoiceItemsInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionUncheckedCreateNestedManyWithoutToUnitInput
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutPurchaseInvoiceItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutPurchaseInvoiceItemsInput, UnitUncheckedCreateWithoutPurchaseInvoiceItemsInput>
  }

  export type PurchaseInvoiceUpsertWithoutItemsInput = {
    update: XOR<PurchaseInvoiceUpdateWithoutItemsInput, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    where?: PurchaseInvoiceWhereInput
  }

  export type PurchaseInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseInvoiceWhereInput
    data: XOR<PurchaseInvoiceUpdateWithoutItemsInput, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    account?: AccountUpdateOneWithoutPurchaseInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseOrderItemUpsertWithoutInvoiceItemsInput = {
    update: XOR<PurchaseOrderItemUpdateWithoutInvoiceItemsInput, PurchaseOrderItemUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<PurchaseOrderItemCreateWithoutInvoiceItemsInput, PurchaseOrderItemUncheckedCreateWithoutInvoiceItemsInput>
    where?: PurchaseOrderItemWhereInput
  }

  export type PurchaseOrderItemUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: PurchaseOrderItemWhereInput
    data: XOR<PurchaseOrderItemUpdateWithoutInvoiceItemsInput, PurchaseOrderItemUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type PurchaseOrderItemUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseOrderItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseOrderItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    grnItems?: GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type GRNItemUpsertWithoutInvoiceItemsInput = {
    update: XOR<GRNItemUpdateWithoutInvoiceItemsInput, GRNItemUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<GRNItemCreateWithoutInvoiceItemsInput, GRNItemUncheckedCreateWithoutInvoiceItemsInput>
    where?: GRNItemWhereInput
  }

  export type GRNItemUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: GRNItemWhereInput
    data: XOR<GRNItemUpdateWithoutInvoiceItemsInput, GRNItemUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type GRNItemUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput
    color?: ColorUpdateOneWithoutGrnItemsNestedInput
    brand?: BrandUpdateOneWithoutGrnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutGrnItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutGrnItemsNestedInput
    unit?: UnitUpdateOneWithoutGrnItemsNestedInput
  }

  export type GRNItemUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemMasterUpsertWithoutPurchaseInvoiceItemsInput = {
    update: XOR<ItemMasterUpdateWithoutPurchaseInvoiceItemsInput, ItemMasterUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
    create: XOR<ItemMasterCreateWithoutPurchaseInvoiceItemsInput, ItemMasterUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    where?: ItemMasterWhereInput
  }

  export type ItemMasterUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput = {
    where?: ItemMasterWhereInput
    data: XOR<ItemMasterUpdateWithoutPurchaseInvoiceItemsInput, ItemMasterUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type ItemMasterUpdateWithoutPurchaseInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroup?: ItemGroupUpdateOneRequiredWithoutItemMastersNestedInput
    baseUnit?: UnitUpdateOneRequiredWithoutItemMastersNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutItemMastersNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemMastersNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateWithoutPurchaseInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterNestedInput
  }

  export type ColorUpsertWithoutPurchaseInvoiceItemsInput = {
    update: XOR<ColorUpdateWithoutPurchaseInvoiceItemsInput, ColorUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
    create: XOR<ColorCreateWithoutPurchaseInvoiceItemsInput, ColorUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    where?: ColorWhereInput
  }

  export type ColorUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput = {
    where?: ColorWhereInput
    data: XOR<ColorUpdateWithoutPurchaseInvoiceItemsInput, ColorUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type ColorUpdateWithoutPurchaseInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutColorsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutColorNestedInput
    grnItems?: GRNItemUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutColorNestedInput
  }

  export type ColorUncheckedUpdateWithoutPurchaseInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutColorNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutColorNestedInput
  }

  export type BrandUpsertWithoutPurchaseInvoiceItemsInput = {
    update: XOR<BrandUpdateWithoutPurchaseInvoiceItemsInput, BrandUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
    create: XOR<BrandCreateWithoutPurchaseInvoiceItemsInput, BrandUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutPurchaseInvoiceItemsInput, BrandUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type BrandUpdateWithoutPurchaseInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBrandsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutBrandNestedInput
    grnItems?: GRNItemUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutPurchaseInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutBrandNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ItemGradeUpsertWithoutPurchaseInvoiceItemsInput = {
    update: XOR<ItemGradeUpdateWithoutPurchaseInvoiceItemsInput, ItemGradeUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
    create: XOR<ItemGradeCreateWithoutPurchaseInvoiceItemsInput, ItemGradeUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    where?: ItemGradeWhereInput
  }

  export type ItemGradeUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput = {
    where?: ItemGradeWhereInput
    data: XOR<ItemGradeUpdateWithoutPurchaseInvoiceItemsInput, ItemGradeUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type ItemGradeUpdateWithoutPurchaseInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutItemGradesNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemGradeNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemGradeNestedInput
  }

  export type ItemGradeUncheckedUpdateWithoutPurchaseInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemGradeNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemGradeNestedInput
  }

  export type UnitUpsertWithoutPurchaseInvoiceItemsInput = {
    update: XOR<UnitUpdateWithoutPurchaseInvoiceItemsInput, UnitUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
    create: XOR<UnitCreateWithoutPurchaseInvoiceItemsInput, UnitUncheckedCreateWithoutPurchaseInvoiceItemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutPurchaseInvoiceItemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutPurchaseInvoiceItemsInput, UnitUncheckedUpdateWithoutPurchaseInvoiceItemsInput>
  }

  export type UnitUpdateWithoutPurchaseInvoiceItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitsNestedInput
    conversionsFrom?: UnitConversionUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUpdateManyWithoutToUnitNestedInput
    products?: ProductUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutPurchaseInvoiceItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type PurchaseInvoiceCreateWithoutPurchaseReturnsInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder?: PurchaseOrderCreateNestedOneWithoutInvoicesInput
    account?: AccountCreateNestedOneWithoutPurchaseInvoicesInput
    company: CompanyCreateNestedOneWithoutPurchaseInvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnsInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    purchaseOrderId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutPurchaseReturnsInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutPurchaseReturnsInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnsInput>
  }

  export type GRNCreateWithoutPurchaseReturnsInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrder: PurchaseOrderCreateNestedOneWithoutGrnsInput
    company: CompanyCreateNestedOneWithoutGrnsInput
    items?: GRNItemCreateNestedManyWithoutGrnInput
  }

  export type GRNUncheckedCreateWithoutPurchaseReturnsInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    purchaseOrderId: string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: GRNItemUncheckedCreateNestedManyWithoutGrnInput
  }

  export type GRNCreateOrConnectWithoutPurchaseReturnsInput = {
    where: GRNWhereUniqueInput
    create: XOR<GRNCreateWithoutPurchaseReturnsInput, GRNUncheckedCreateWithoutPurchaseReturnsInput>
  }

  export type AccountCreateWithoutPurchaseReturnsInput = {
    code: string
    name: string
    type: $Enums.AccountType
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: AccountCreateNestedOneWithoutChildrenInput
    children?: AccountCreateNestedManyWithoutParentInput
    journalLines?: JournalLineCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutPurchaseReturnsInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    parentId?: number | null
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: AccountUncheckedCreateNestedManyWithoutParentInput
    journalLines?: JournalLineUncheckedCreateNestedManyWithoutAccountInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutAccountInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutPurchaseReturnsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPurchaseReturnsInput, AccountUncheckedCreateWithoutPurchaseReturnsInput>
  }

  export type CompanyCreateWithoutPurchaseReturnsInput = {
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupCreateNestedManyWithoutCompanyInput
    colors?: ColorCreateNestedManyWithoutCompanyInput
    brands?: BrandCreateNestedManyWithoutCompanyInput
    units?: UnitCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutCompanyInput
    grns?: GRNCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutPurchaseReturnsInput = {
    id?: number
    legalName: string
    tradeName?: string | null
    address?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    taxId?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroups?: ItemGroupUncheckedCreateNestedManyWithoutCompanyInput
    colors?: ColorUncheckedCreateNestedManyWithoutCompanyInput
    brands?: BrandUncheckedCreateNestedManyWithoutCompanyInput
    units?: UnitUncheckedCreateNestedManyWithoutCompanyInput
    itemGrades?: ItemGradeUncheckedCreateNestedManyWithoutCompanyInput
    unitConversions?: UnitConversionUncheckedCreateNestedManyWithoutCompanyInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutCompanyInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutCompanyInput
    grns?: GRNUncheckedCreateNestedManyWithoutCompanyInput
    purchaseInvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutCompanyInput
    packingUnits?: PackingUnitUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutPurchaseReturnsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutPurchaseReturnsInput, CompanyUncheckedCreateWithoutPurchaseReturnsInput>
  }

  export type PurchaseReturnItemCreateWithoutReturnInput = {
    id?: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    itemMaster: ItemMasterCreateNestedOneWithoutPurchaseReturnItemsInput
    color?: ColorCreateNestedOneWithoutPurchaseReturnItemsInput
    brand?: BrandCreateNestedOneWithoutPurchaseReturnItemsInput
    itemGrade?: ItemGradeCreateNestedOneWithoutPurchaseReturnItemsInput
    unit?: UnitCreateNestedOneWithoutPurchaseReturnItemsInput
  }

  export type PurchaseReturnItemUncheckedCreateWithoutReturnInput = {
    id?: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateOrConnectWithoutReturnInput = {
    where: PurchaseReturnItemWhereUniqueInput
    create: XOR<PurchaseReturnItemCreateWithoutReturnInput, PurchaseReturnItemUncheckedCreateWithoutReturnInput>
  }

  export type PurchaseReturnItemCreateManyReturnInputEnvelope = {
    data: PurchaseReturnItemCreateManyReturnInput | PurchaseReturnItemCreateManyReturnInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseInvoiceUpsertWithoutPurchaseReturnsInput = {
    update: XOR<PurchaseInvoiceUpdateWithoutPurchaseReturnsInput, PurchaseInvoiceUncheckedUpdateWithoutPurchaseReturnsInput>
    create: XOR<PurchaseInvoiceCreateWithoutPurchaseReturnsInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnsInput>
    where?: PurchaseInvoiceWhereInput
  }

  export type PurchaseInvoiceUpdateToOneWithWhereWithoutPurchaseReturnsInput = {
    where?: PurchaseInvoiceWhereInput
    data: XOR<PurchaseInvoiceUpdateWithoutPurchaseReturnsInput, PurchaseInvoiceUncheckedUpdateWithoutPurchaseReturnsInput>
  }

  export type PurchaseInvoiceUpdateWithoutPurchaseReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    account?: AccountUpdateOneWithoutPurchaseInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutPurchaseReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type GRNUpsertWithoutPurchaseReturnsInput = {
    update: XOR<GRNUpdateWithoutPurchaseReturnsInput, GRNUncheckedUpdateWithoutPurchaseReturnsInput>
    create: XOR<GRNCreateWithoutPurchaseReturnsInput, GRNUncheckedCreateWithoutPurchaseReturnsInput>
    where?: GRNWhereInput
  }

  export type GRNUpdateToOneWithWhereWithoutPurchaseReturnsInput = {
    where?: GRNWhereInput
    data: XOR<GRNUpdateWithoutPurchaseReturnsInput, GRNUncheckedUpdateWithoutPurchaseReturnsInput>
  }

  export type GRNUpdateWithoutPurchaseReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutGrnsNestedInput
    company?: CompanyUpdateOneRequiredWithoutGrnsNestedInput
    items?: GRNItemUpdateManyWithoutGrnNestedInput
  }

  export type GRNUncheckedUpdateWithoutPurchaseReturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: GRNItemUncheckedUpdateManyWithoutGrnNestedInput
  }

  export type AccountUpsertWithoutPurchaseReturnsInput = {
    update: XOR<AccountUpdateWithoutPurchaseReturnsInput, AccountUncheckedUpdateWithoutPurchaseReturnsInput>
    create: XOR<AccountCreateWithoutPurchaseReturnsInput, AccountUncheckedCreateWithoutPurchaseReturnsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutPurchaseReturnsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutPurchaseReturnsInput, AccountUncheckedUpdateWithoutPurchaseReturnsInput>
  }

  export type AccountUpdateWithoutPurchaseReturnsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: AccountUpdateOneWithoutChildrenNestedInput
    children?: AccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutPurchaseReturnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CompanyUpsertWithoutPurchaseReturnsInput = {
    update: XOR<CompanyUpdateWithoutPurchaseReturnsInput, CompanyUncheckedUpdateWithoutPurchaseReturnsInput>
    create: XOR<CompanyCreateWithoutPurchaseReturnsInput, CompanyUncheckedCreateWithoutPurchaseReturnsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutPurchaseReturnsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutPurchaseReturnsInput, CompanyUncheckedUpdateWithoutPurchaseReturnsInput>
  }

  export type CompanyUpdateWithoutPurchaseReturnsInput = {
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUpdateManyWithoutCompanyNestedInput
    colors?: ColorUpdateManyWithoutCompanyNestedInput
    brands?: BrandUpdateManyWithoutCompanyNestedInput
    units?: UnitUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutCompanyNestedInput
    grns?: GRNUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutPurchaseReturnsInput = {
    id?: IntFieldUpdateOperationsInput | number
    legalName?: StringFieldUpdateOperationsInput | string
    tradeName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroups?: ItemGroupUncheckedUpdateManyWithoutCompanyNestedInput
    colors?: ColorUncheckedUpdateManyWithoutCompanyNestedInput
    brands?: BrandUncheckedUpdateManyWithoutCompanyNestedInput
    units?: UnitUncheckedUpdateManyWithoutCompanyNestedInput
    itemGrades?: ItemGradeUncheckedUpdateManyWithoutCompanyNestedInput
    unitConversions?: UnitConversionUncheckedUpdateManyWithoutCompanyNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutCompanyNestedInput
    grns?: GRNUncheckedUpdateManyWithoutCompanyNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutCompanyNestedInput
    packingUnits?: PackingUnitUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PurchaseReturnItemUpsertWithWhereUniqueWithoutReturnInput = {
    where: PurchaseReturnItemWhereUniqueInput
    update: XOR<PurchaseReturnItemUpdateWithoutReturnInput, PurchaseReturnItemUncheckedUpdateWithoutReturnInput>
    create: XOR<PurchaseReturnItemCreateWithoutReturnInput, PurchaseReturnItemUncheckedCreateWithoutReturnInput>
  }

  export type PurchaseReturnItemUpdateWithWhereUniqueWithoutReturnInput = {
    where: PurchaseReturnItemWhereUniqueInput
    data: XOR<PurchaseReturnItemUpdateWithoutReturnInput, PurchaseReturnItemUncheckedUpdateWithoutReturnInput>
  }

  export type PurchaseReturnItemUpdateManyWithWhereWithoutReturnInput = {
    where: PurchaseReturnItemScalarWhereInput
    data: XOR<PurchaseReturnItemUpdateManyMutationInput, PurchaseReturnItemUncheckedUpdateManyWithoutReturnInput>
  }

  export type PurchaseReturnCreateWithoutItemsInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseInvoice?: PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnsInput
    grn?: GRNCreateNestedOneWithoutPurchaseReturnsInput
    account?: AccountCreateNestedOneWithoutPurchaseReturnsInput
    company: CompanyCreateNestedOneWithoutPurchaseReturnsInput
  }

  export type PurchaseReturnUncheckedCreateWithoutItemsInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    purchaseInvoiceId?: string | null
    grnId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnCreateOrConnectWithoutItemsInput = {
    where: PurchaseReturnWhereUniqueInput
    create: XOR<PurchaseReturnCreateWithoutItemsInput, PurchaseReturnUncheckedCreateWithoutItemsInput>
  }

  export type ItemMasterCreateWithoutPurchaseReturnItemsInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemGroup: ItemGroupCreateNestedOneWithoutItemMastersInput
    baseUnit: UnitCreateNestedOneWithoutItemMastersInput
    packingUnit?: PackingUnitCreateNestedOneWithoutItemMastersInput
    company: CompanyCreateNestedOneWithoutItemMastersInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterUncheckedCreateWithoutPurchaseReturnItemsInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemMasterInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemMasterInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemMasterInput
  }

  export type ItemMasterCreateOrConnectWithoutPurchaseReturnItemsInput = {
    where: ItemMasterWhereUniqueInput
    create: XOR<ItemMasterCreateWithoutPurchaseReturnItemsInput, ItemMasterUncheckedCreateWithoutPurchaseReturnItemsInput>
  }

  export type ColorCreateWithoutPurchaseReturnItemsInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutColorsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutColorInput
    grnItems?: GRNItemCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutColorInput
  }

  export type ColorUncheckedCreateWithoutPurchaseReturnItemsInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutColorInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutColorInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutColorInput
  }

  export type ColorCreateOrConnectWithoutPurchaseReturnItemsInput = {
    where: ColorWhereUniqueInput
    create: XOR<ColorCreateWithoutPurchaseReturnItemsInput, ColorUncheckedCreateWithoutPurchaseReturnItemsInput>
  }

  export type BrandCreateWithoutPurchaseReturnItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBrandsInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutBrandInput
    grnItems?: GRNItemCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutPurchaseReturnItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutBrandInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutBrandInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutPurchaseReturnItemsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutPurchaseReturnItemsInput, BrandUncheckedCreateWithoutPurchaseReturnItemsInput>
  }

  export type ItemGradeCreateWithoutPurchaseReturnItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutItemGradesInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutItemGradeInput
    grnItems?: GRNItemCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeUncheckedCreateWithoutPurchaseReturnItemsInput = {
    id?: string
    code: string
    name: string
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutItemGradeInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutItemGradeInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemGradeInput
  }

  export type ItemGradeCreateOrConnectWithoutPurchaseReturnItemsInput = {
    where: ItemGradeWhereUniqueInput
    create: XOR<ItemGradeCreateWithoutPurchaseReturnItemsInput, ItemGradeUncheckedCreateWithoutPurchaseReturnItemsInput>
  }

  export type UnitCreateWithoutPurchaseReturnItemsInput = {
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUnitsInput
    conversionsFrom?: UnitConversionCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionCreateNestedManyWithoutToUnitInput
    products?: ProductCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutPurchaseReturnItemsInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversionsFrom?: UnitConversionUncheckedCreateNestedManyWithoutFromUnitInput
    conversionsTo?: UnitConversionUncheckedCreateNestedManyWithoutToUnitInput
    products?: ProductUncheckedCreateNestedManyWithoutUnitInput
    itemMasters?: ItemMasterUncheckedCreateNestedManyWithoutBaseUnitInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedCreateNestedManyWithoutUnitInput
    grnItems?: GRNItemUncheckedCreateNestedManyWithoutUnitInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutPurchaseReturnItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutPurchaseReturnItemsInput, UnitUncheckedCreateWithoutPurchaseReturnItemsInput>
  }

  export type PurchaseReturnUpsertWithoutItemsInput = {
    update: XOR<PurchaseReturnUpdateWithoutItemsInput, PurchaseReturnUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseReturnCreateWithoutItemsInput, PurchaseReturnUncheckedCreateWithoutItemsInput>
    where?: PurchaseReturnWhereInput
  }

  export type PurchaseReturnUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseReturnWhereInput
    data: XOR<PurchaseReturnUpdateWithoutItemsInput, PurchaseReturnUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseReturnUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseInvoice?: PurchaseInvoiceUpdateOneWithoutPurchaseReturnsNestedInput
    grn?: GRNUpdateOneWithoutPurchaseReturnsNestedInput
    account?: AccountUpdateOneWithoutPurchaseReturnsNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseReturnsNestedInput
  }

  export type PurchaseReturnUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    grnId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemMasterUpsertWithoutPurchaseReturnItemsInput = {
    update: XOR<ItemMasterUpdateWithoutPurchaseReturnItemsInput, ItemMasterUncheckedUpdateWithoutPurchaseReturnItemsInput>
    create: XOR<ItemMasterCreateWithoutPurchaseReturnItemsInput, ItemMasterUncheckedCreateWithoutPurchaseReturnItemsInput>
    where?: ItemMasterWhereInput
  }

  export type ItemMasterUpdateToOneWithWhereWithoutPurchaseReturnItemsInput = {
    where?: ItemMasterWhereInput
    data: XOR<ItemMasterUpdateWithoutPurchaseReturnItemsInput, ItemMasterUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type ItemMasterUpdateWithoutPurchaseReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroup?: ItemGroupUpdateOneRequiredWithoutItemMastersNestedInput
    baseUnit?: UnitUpdateOneRequiredWithoutItemMastersNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutItemMastersNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemMastersNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateWithoutPurchaseReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterNestedInput
  }

  export type ColorUpsertWithoutPurchaseReturnItemsInput = {
    update: XOR<ColorUpdateWithoutPurchaseReturnItemsInput, ColorUncheckedUpdateWithoutPurchaseReturnItemsInput>
    create: XOR<ColorCreateWithoutPurchaseReturnItemsInput, ColorUncheckedCreateWithoutPurchaseReturnItemsInput>
    where?: ColorWhereInput
  }

  export type ColorUpdateToOneWithWhereWithoutPurchaseReturnItemsInput = {
    where?: ColorWhereInput
    data: XOR<ColorUpdateWithoutPurchaseReturnItemsInput, ColorUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type ColorUpdateWithoutPurchaseReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutColorsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutColorNestedInput
    grnItems?: GRNItemUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutColorNestedInput
  }

  export type ColorUncheckedUpdateWithoutPurchaseReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutColorNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutColorNestedInput
  }

  export type BrandUpsertWithoutPurchaseReturnItemsInput = {
    update: XOR<BrandUpdateWithoutPurchaseReturnItemsInput, BrandUncheckedUpdateWithoutPurchaseReturnItemsInput>
    create: XOR<BrandCreateWithoutPurchaseReturnItemsInput, BrandUncheckedCreateWithoutPurchaseReturnItemsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutPurchaseReturnItemsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutPurchaseReturnItemsInput, BrandUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type BrandUpdateWithoutPurchaseReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBrandsNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutBrandNestedInput
    grnItems?: GRNItemUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutPurchaseReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutBrandNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ItemGradeUpsertWithoutPurchaseReturnItemsInput = {
    update: XOR<ItemGradeUpdateWithoutPurchaseReturnItemsInput, ItemGradeUncheckedUpdateWithoutPurchaseReturnItemsInput>
    create: XOR<ItemGradeCreateWithoutPurchaseReturnItemsInput, ItemGradeUncheckedCreateWithoutPurchaseReturnItemsInput>
    where?: ItemGradeWhereInput
  }

  export type ItemGradeUpdateToOneWithWhereWithoutPurchaseReturnItemsInput = {
    where?: ItemGradeWhereInput
    data: XOR<ItemGradeUpdateWithoutPurchaseReturnItemsInput, ItemGradeUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type ItemGradeUpdateWithoutPurchaseReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutItemGradesNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemGradeNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemGradeNestedInput
  }

  export type ItemGradeUncheckedUpdateWithoutPurchaseReturnItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemGradeNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemGradeNestedInput
  }

  export type UnitUpsertWithoutPurchaseReturnItemsInput = {
    update: XOR<UnitUpdateWithoutPurchaseReturnItemsInput, UnitUncheckedUpdateWithoutPurchaseReturnItemsInput>
    create: XOR<UnitCreateWithoutPurchaseReturnItemsInput, UnitUncheckedCreateWithoutPurchaseReturnItemsInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutPurchaseReturnItemsInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutPurchaseReturnItemsInput, UnitUncheckedUpdateWithoutPurchaseReturnItemsInput>
  }

  export type UnitUpdateWithoutPurchaseReturnItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitsNestedInput
    conversionsFrom?: UnitConversionUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUpdateManyWithoutToUnitNestedInput
    products?: ProductUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutPurchaseReturnItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type PostCreateManyAuthorInput = {
    id?: number
    title: string
    content?: string | null
    published?: boolean
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    module: string
    resourceId?: string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AuditAccessCreateManySeniorInput = {
    id?: number
    juniorId: number
  }

  export type AuditAccessCreateManyJuniorInput = {
    id?: number
    seniorId: number
  }

  export type UserRoleCreateManyUserInput = {
    roleId: number
    assignedAt?: Date | string
  }

  export type UserWarehouseCreateManyUserInput = {
    warehouseId: number
    assignedAt?: Date | string
  }

  export type PostUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditAccessUpdateWithoutSeniorInput = {
    junior?: UserUpdateOneRequiredWithoutVisibleToAuditNestedInput
  }

  export type AuditAccessUncheckedUpdateWithoutSeniorInput = {
    id?: IntFieldUpdateOperationsInput | number
    juniorId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditAccessUncheckedUpdateManyWithoutSeniorInput = {
    id?: IntFieldUpdateOperationsInput | number
    juniorId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditAccessUpdateWithoutJuniorInput = {
    senior?: UserUpdateOneRequiredWithoutAuditLogPermissionsNestedInput
  }

  export type AuditAccessUncheckedUpdateWithoutJuniorInput = {
    id?: IntFieldUpdateOperationsInput | number
    seniorId?: IntFieldUpdateOperationsInput | number
  }

  export type AuditAccessUncheckedUpdateManyWithoutJuniorInput = {
    id?: IntFieldUpdateOperationsInput | number
    seniorId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWarehouseUpdateWithoutUserInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneRequiredWithoutUserWarehousesNestedInput
  }

  export type UserWarehouseUncheckedUpdateWithoutUserInput = {
    warehouseId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWarehouseUncheckedUpdateManyWithoutUserInput = {
    warehouseId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyDepartmentInput = {
    id?: number
    email: string
    name?: string | null
    image?: string | null
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstLogin?: boolean
    forcePasswordChange?: boolean
    isActive?: boolean
  }

  export type UserUpdateWithoutDepartmentInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    auditLogPermissions?: AuditAccessUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    auditLogPermissions?: AuditAccessUncheckedUpdateManyWithoutSeniorNestedInput
    visibleToAudit?: AuditAccessUncheckedUpdateManyWithoutJuniorNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    userWarehouses?: UserWarehouseUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstLogin?: BoolFieldUpdateOperationsInput | boolean
    forcePasswordChange?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleCreateManyRoleInput = {
    userId: number
    assignedAt?: Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    permissionId: number
    assignedAt?: Date | string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    roleId: number
    assignedAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWarehouseCreateManyWarehouseInput = {
    userId: number
    assignedAt?: Date | string
  }

  export type PurchaseOrderCreateManyWarehouseInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserWarehouseUpdateWithoutWarehouseInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserWarehousesNestedInput
  }

  export type UserWarehouseUncheckedUpdateWithoutWarehouseInput = {
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserWarehouseUncheckedUpdateManyWithoutWarehouseInput = {
    userId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutPurchaseOrdersNestedInput
    currency?: CurrencyUpdateOneWithoutPurchaseOrdersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutWarehouseInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitConversionCreateManyFromUnitInput = {
    id?: number
    toUnitId: number
    conversionRate: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitConversionCreateManyToUnitInput = {
    id?: number
    fromUnitId: number
    conversionRate: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyUnitInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    categoryId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemMasterCreateManyBaseUnitInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemCreateManyUnitInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemCreateManyUnitInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateManyUnitInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateManyUnitInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitConversionUpdateWithoutFromUnitInput = {
    conversionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitConversionsNestedInput
    toUnit?: UnitUpdateOneRequiredWithoutConversionsToNestedInput
  }

  export type UnitConversionUncheckedUpdateWithoutFromUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUnitId?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitConversionUncheckedUpdateManyWithoutFromUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    toUnitId?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitConversionUpdateWithoutToUnitInput = {
    conversionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUnitConversionsNestedInput
    fromUnit?: UnitUpdateOneRequiredWithoutConversionsFromNestedInput
  }

  export type UnitConversionUncheckedUpdateWithoutToUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUnitId?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitConversionUncheckedUpdateManyWithoutToUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUnitId?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutUnitInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemMasterUpdateWithoutBaseUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroup?: ItemGroupUpdateOneRequiredWithoutItemMastersNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutItemMastersNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemMastersNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateWithoutBaseUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateManyWithoutBaseUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseOrderItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseOrderItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    grnItems?: GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput
    color?: ColorUpdateOneWithoutGrnItemsNestedInput
    brand?: BrandUpdateOneWithoutGrnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutGrnItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutGrnItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneWithoutInvoiceItemsNestedInput
    grnItem?: GRNItemUpdateOneWithoutInvoiceItemsNestedInput
    itemMaster?: ItemMasterUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseInvoiceItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return?: PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseReturnItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseReturnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseReturnItemsNestedInput
  }

  export type PurchaseReturnItemUncheckedUpdateWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGroupCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    pictureUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitCreateManyCompanyInput = {
    id?: number
    code: string
    name: string
    symbol: string
    unitType: string
    isBase?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemGradeCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitConversionCreateManyCompanyInput = {
    id?: number
    fromUnitId: number
    toUnitId: number
    conversionRate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemMasterCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    packingUnitId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateManyCompanyInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNCreateManyCompanyInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    purchaseOrderId: string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceCreateManyCompanyInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    purchaseOrderId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnCreateManyCompanyInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    purchaseInvoiceId?: string | null
    grnId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackingUnitCreateManyCompanyInput = {
    id?: string
    code: string
    name: string
    symbol?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemGroupUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ItemGroupUpdateOneWithoutChildrenNestedInput
    children?: ItemGroupUpdateManyWithoutParentNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutItemGroupNestedInput
  }

  export type ItemGroupUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ItemGroupUncheckedUpdateManyWithoutParentNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutItemGroupNestedInput
  }

  export type ItemGroupUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutColorNestedInput
    grnItems?: GRNItemUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutColorNestedInput
  }

  export type ColorUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutColorNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutColorNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutColorNestedInput
  }

  export type ColorUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutBrandNestedInput
    grnItems?: GRNItemUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutBrandNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutBrandNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitUpdateWithoutCompanyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUpdateManyWithoutToUnitNestedInput
    products?: ProductUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversionsFrom?: UnitConversionUncheckedUpdateManyWithoutFromUnitNestedInput
    conversionsTo?: UnitConversionUncheckedUpdateManyWithoutToUnitNestedInput
    products?: ProductUncheckedUpdateManyWithoutUnitNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutBaseUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutUnitNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    unitType?: StringFieldUpdateOperationsInput | string
    isBase?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemGradeUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemGradeNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemGradeNestedInput
  }

  export type ItemGradeUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemGradeNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemGradeNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemGradeNestedInput
  }

  export type ItemGradeUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitConversionUpdateWithoutCompanyInput = {
    conversionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUnit?: UnitUpdateOneRequiredWithoutConversionsFromNestedInput
    toUnit?: UnitUpdateOneRequiredWithoutConversionsToNestedInput
  }

  export type UnitConversionUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUnitId?: IntFieldUpdateOperationsInput | number
    toUnitId?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitConversionUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fromUnitId?: IntFieldUpdateOperationsInput | number
    toUnitId?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemMasterUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroup?: ItemGroupUpdateOneRequiredWithoutItemMastersNestedInput
    baseUnit?: UnitUpdateOneRequiredWithoutItemMastersNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutItemMastersNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutPurchaseOrdersNestedInput
    currency?: CurrencyUpdateOneWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutGrnsNestedInput
    items?: GRNItemUpdateManyWithoutGrnNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutGrnNestedInput
  }

  export type GRNUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: GRNItemUncheckedUpdateManyWithoutGrnNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutGrnNestedInput
  }

  export type GRNUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    account?: AccountUpdateOneWithoutPurchaseInvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutInvoiceNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseInvoice?: PurchaseInvoiceUpdateOneWithoutPurchaseReturnsNestedInput
    grn?: GRNUpdateOneWithoutPurchaseReturnsNestedInput
    account?: AccountUpdateOneWithoutPurchaseReturnsNestedInput
    items?: PurchaseReturnItemUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    grnId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseReturnItemUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    grnId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackingUnitUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemMasters?: ItemMasterUpdateManyWithoutPackingUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutPackingUnitNestedInput
    grnItems?: GRNItemUpdateManyWithoutPackingUnitNestedInput
  }

  export type PackingUnitUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutPackingUnitNestedInput
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutPackingUnitNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutPackingUnitNestedInput
  }

  export type PackingUnitUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateManyFiscalYearInput = {
    id?: number
    number: string
    date: Date | string
    type: $Enums.VoucherType
    reference?: string | null
    narration?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateWithoutFiscalYearInput = {
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: JournalLineUpdateManyWithoutEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateWithoutFiscalYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: JournalLineUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type JournalEntryUncheckedUpdateManyWithoutFiscalYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumVoucherTypeFieldUpdateOperationsInput | $Enums.VoucherType
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManyCurrencyInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    accountId?: number | null
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutPurchaseOrdersNestedInput
    warehouse?: WarehouseUpdateOneWithoutPurchaseOrdersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    name: string
    code: string
    description?: string | null
    type: $Enums.ProductType
    unitId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unit?: UnitUpdateOneRequiredWithoutProductsNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    unitId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    unitId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantCreateManyProductInput = {
    id?: number
    name: string
    sku: string
    color?: string | null
    count?: string | null
    gsm?: string | null
    width?: string | null
    shade?: string | null
    weave?: string | null
    finish?: string | null
    type?: string | null
    price?: number | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariantUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableStringFieldUpdateOperationsInput | string | null
    gsm?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    shade?: NullableStringFieldUpdateOperationsInput | string | null
    weave?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableStringFieldUpdateOperationsInput | string | null
    gsm?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    shade?: NullableStringFieldUpdateOperationsInput | string | null
    weave?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    count?: NullableStringFieldUpdateOperationsInput | string | null
    gsm?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    shade?: NullableStringFieldUpdateOperationsInput | string | null
    weave?: NullableStringFieldUpdateOperationsInput | string | null
    finish?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineCreateManyLocationInput = {
    id?: number
    name: string
    code: string
    type?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MachineUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MachineUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyParentInput = {
    id?: number
    code: string
    name: string
    type: $Enums.AccountType
    level?: number
    isPosting?: boolean
    description?: string | null
    openingBalance?: number
    openingBalanceType?: $Enums.BalanceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalLineCreateManyAccountInput = {
    id?: number
    entryId: number
    debit?: number
    credit?: number
    narration?: string | null
  }

  export type PurchaseOrderCreateManyAccountInput = {
    id?: string
    poNumber: string
    type: $Enums.PurchaseOrderType
    status?: $Enums.PurchaseOrderStatus
    date?: Date | string
    partyName?: string | null
    warehouseId?: number | null
    referenceNo?: string | null
    documentDate?: Date | string | null
    fileNo?: string | null
    remarks?: string | null
    totalAmount?: number
    currencyId?: number | null
    exchangeRate?: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceCreateManyAccountInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    purchaseOrderId?: string | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnCreateManyAccountInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    purchaseInvoiceId?: string | null
    grnId?: string | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutParentInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AccountUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AccountUncheckedUpdateManyWithoutParentNestedInput
    journalLines?: JournalLineUncheckedUpdateManyWithoutAccountNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutAccountNestedInput
    purchaseInvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutAccountNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    level?: IntFieldUpdateOperationsInput | number
    isPosting?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openingBalance?: FloatFieldUpdateOperationsInput | number
    openingBalanceType?: EnumBalanceTypeFieldUpdateOperationsInput | $Enums.BalanceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineUpdateWithoutAccountInput = {
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    entry?: JournalEntryUpdateOneRequiredWithoutLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    entryId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseOrderUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehouseUpdateOneWithoutPurchaseOrdersNestedInput
    currency?: CurrencyUpdateOneWithoutPurchaseOrdersNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    grns?: GRNUncheckedUpdateManyWithoutPurchaseOrderNestedInput
    invoices?: PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumPurchaseOrderTypeFieldUpdateOperationsInput | $Enums.PurchaseOrderType
    status?: EnumPurchaseOrderStatusFieldUpdateOperationsInput | $Enums.PurchaseOrderStatus
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    currencyId?: NullableIntFieldUpdateOperationsInput | number | null
    exchangeRate?: FloatFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneWithoutInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutInvoiceNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseInvoice?: PurchaseInvoiceUpdateOneWithoutPurchaseReturnsNestedInput
    grn?: GRNUpdateOneWithoutPurchaseReturnsNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseReturnsNestedInput
    items?: PurchaseReturnItemUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    grnId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseReturnItemUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    grnId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalLineCreateManyEntryInput = {
    id?: number
    accountId: number
    debit?: number
    credit?: number
    narration?: string | null
  }

  export type JournalLineUpdateWithoutEntryInput = {
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
    account?: AccountUpdateOneRequiredWithoutJournalLinesNestedInput
  }

  export type JournalLineUncheckedUpdateWithoutEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JournalLineUncheckedUpdateManyWithoutEntryInput = {
    id?: IntFieldUpdateOperationsInput | number
    accountId?: IntFieldUpdateOperationsInput | number
    debit?: FloatFieldUpdateOperationsInput | number
    credit?: FloatFieldUpdateOperationsInput | number
    narration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemGroupCreateManyParentInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemMasterCreateManyItemGroupInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    baseUnitId: number
    packingUnitId?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemGroupUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ItemGroupUpdateManyWithoutParentNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemGroupsNestedInput
    itemMasters?: ItemMasterUpdateManyWithoutItemGroupNestedInput
  }

  export type ItemGroupUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: ItemGroupUncheckedUpdateManyWithoutParentNestedInput
    itemMasters?: ItemMasterUncheckedUpdateManyWithoutItemGroupNestedInput
  }

  export type ItemGroupUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemMasterUpdateWithoutItemGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseUnit?: UnitUpdateOneRequiredWithoutItemMastersNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutItemMastersNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemMastersNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateWithoutItemGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateManyWithoutItemGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    baseUnitId?: IntFieldUpdateOperationsInput | number
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyColorInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemCreateManyColorInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateManyColorInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateManyColorInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseOrderItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    grnItems?: GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput
    brand?: BrandUpdateOneWithoutGrnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutGrnItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutGrnItemsNestedInput
    unit?: UnitUpdateOneWithoutGrnItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateManyWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneWithoutInvoiceItemsNestedInput
    grnItem?: GRNItemUpdateOneWithoutInvoiceItemsNestedInput
    itemMaster?: ItemMasterUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseInvoiceItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return?: PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseReturnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseReturnItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseReturnItemsNestedInput
  }

  export type PurchaseReturnItemUncheckedUpdateWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutColorInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyBrandInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemCreateManyBrandInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateManyBrandInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateManyBrandInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseOrderItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    grnItems?: GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput
    color?: ColorUpdateOneWithoutGrnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutGrnItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutGrnItemsNestedInput
    unit?: UnitUpdateOneWithoutGrnItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneWithoutInvoiceItemsNestedInput
    grnItem?: GRNItemUpdateOneWithoutInvoiceItemsNestedInput
    itemMaster?: ItemMasterUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseInvoiceItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return?: PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseReturnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseReturnItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseReturnItemsNestedInput
  }

  export type PurchaseReturnItemUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyItemGradeInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemCreateManyItemGradeInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateManyItemGradeInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateManyItemGradeInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseOrderItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseOrderItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    grnItems?: GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemUpdateWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput
    color?: ColorUpdateOneWithoutGrnItemsNestedInput
    brand?: BrandUpdateOneWithoutGrnItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutGrnItemsNestedInput
    unit?: UnitUpdateOneWithoutGrnItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateManyWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneWithoutInvoiceItemsNestedInput
    grnItem?: GRNItemUpdateOneWithoutInvoiceItemsNestedInput
    itemMaster?: ItemMasterUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseInvoiceItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUpdateWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return?: PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseReturnItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseReturnItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseReturnItemsNestedInput
  }

  export type PurchaseReturnItemUncheckedUpdateWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutItemGradeInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemMasterCreateManyPackingUnitInput = {
    id?: string
    code: string
    name: string
    shortDescription?: string | null
    status?: string
    hsCode?: string | null
    imageUrl?: string | null
    itemGroupId: string
    baseUnitId: number
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemCreateManyPackingUnitInput = {
    id?: string
    purchaseOrderId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemCreateManyPackingUnitInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemMasterUpdateWithoutPackingUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemGroup?: ItemGroupUpdateOneRequiredWithoutItemMastersNestedInput
    baseUnit?: UnitUpdateOneRequiredWithoutItemMastersNestedInput
    company?: CompanyUpdateOneRequiredWithoutItemMastersNestedInput
    purchaseOrderItems?: PurchaseOrderItemUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateWithoutPackingUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItems?: PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterNestedInput
    grnItems?: GRNItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseInvoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterNestedInput
    purchaseReturnItems?: PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterNestedInput
  }

  export type ItemMasterUncheckedUpdateManyWithoutPackingUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    hsCode?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    itemGroupId?: StringFieldUpdateOperationsInput | string
    baseUnitId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUpdateWithoutPackingUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseOrderItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseOrderItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    grnItems?: GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutPackingUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPackingUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemUpdateWithoutPackingUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput
    color?: ColorUpdateOneWithoutGrnItemsNestedInput
    brand?: BrandUpdateOneWithoutGrnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutGrnItemsNestedInput
    unit?: UnitUpdateOneWithoutGrnItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateWithoutPackingUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateManyWithoutPackingUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyItemMasterInput = {
    id?: string
    purchaseOrderId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemCreateManyItemMasterInput = {
    id?: string
    grnId: string
    purchaseOrderItemId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateManyItemMasterInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemCreateManyItemMasterInput = {
    id?: string
    returnId: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrder?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseOrderItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseOrderItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    grnItems?: GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemUpdateWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput
    color?: ColorUpdateOneWithoutGrnItemsNestedInput
    brand?: BrandUpdateOneWithoutGrnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutGrnItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutGrnItemsNestedInput
    unit?: UnitUpdateOneWithoutGrnItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateManyWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneWithoutInvoiceItemsNestedInput
    grnItem?: GRNItemUpdateOneWithoutInvoiceItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseInvoiceItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUpdateWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    return?: PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseReturnItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseReturnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseReturnItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseReturnItemsNestedInput
  }

  export type PurchaseReturnItemUncheckedUpdateWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutItemMasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnId?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyPurchaseOrderInput = {
    id?: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    packingType?: $Enums.PackingType | null
    pcs?: number | null
    unitSize?: number | null
    quantity?: number | null
    unitId?: number | null
    rate: number
    amount: number
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNCreateManyPurchaseOrderInput = {
    id?: string
    grnNumber: string
    date?: Date | string
    lotNo?: string | null
    warehouseRefNo?: string | null
    remarks?: string | null
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceCreateManyPurchaseOrderInput = {
    id?: string
    invoiceNumber: string
    date?: Date | string
    supplierInvoiceNo?: string | null
    remarks?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseOrderItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseOrderItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseOrderItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseOrderItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseOrderItemsNestedInput
    grnItems?: GRNItemUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grnItems?: GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutGrnsNestedInput
    items?: GRNItemUpdateManyWithoutGrnNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutGrnNestedInput
  }

  export type GRNUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: GRNItemUncheckedUpdateManyWithoutGrnNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutGrnNestedInput
  }

  export type GRNUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNo?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseRefNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneWithoutPurchaseInvoicesNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseInvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutInvoiceNestedInput
    purchaseReturns?: PurchaseReturnUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
    purchaseReturns?: PurchaseReturnUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutPurchaseOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierInvoiceNo?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemCreateManyPurchaseOrderItemInput = {
    id?: string
    grnId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateManyPurchaseOrderItemInput = {
    id?: string
    invoiceId: string
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemUpdateWithoutPurchaseOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneRequiredWithoutItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput
    color?: ColorUpdateOneWithoutGrnItemsNestedInput
    brand?: BrandUpdateOneWithoutGrnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutGrnItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutGrnItemsNestedInput
    unit?: UnitUpdateOneWithoutGrnItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateWithoutPurchaseOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateManyWithoutPurchaseOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    grnId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutPurchaseOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
    grnItem?: GRNItemUpdateOneWithoutInvoiceItemsNestedInput
    itemMaster?: ItemMasterUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseInvoiceItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutPurchaseOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNItemCreateManyGrnInput = {
    id?: string
    purchaseOrderItemId: string
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    packingUnitId?: string | null
    receivedQty: number
    pcs?: number | null
    unitSize?: number | null
    packingType?: $Enums.PackingType | null
    unitId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnCreateManyGrnInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    purchaseInvoiceId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GRNItemUpdateWithoutGrnInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItem?: PurchaseOrderItemUpdateOneRequiredWithoutGrnItemsNestedInput
    itemMaster?: ItemMasterUpdateOneRequiredWithoutGrnItemsNestedInput
    color?: ColorUpdateOneWithoutGrnItemsNestedInput
    brand?: BrandUpdateOneWithoutGrnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutGrnItemsNestedInput
    packingUnit?: PackingUnitUpdateOneWithoutGrnItemsNestedInput
    unit?: UnitUpdateOneWithoutGrnItemsNestedInput
    invoiceItems?: PurchaseInvoiceItemUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateWithoutGrnInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemNestedInput
  }

  export type GRNItemUncheckedUpdateManyWithoutGrnInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: StringFieldUpdateOperationsInput | string
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    packingUnitId?: NullableStringFieldUpdateOperationsInput | string | null
    receivedQty?: FloatFieldUpdateOperationsInput | number
    pcs?: NullableFloatFieldUpdateOperationsInput | number | null
    unitSize?: NullableFloatFieldUpdateOperationsInput | number | null
    packingType?: NullableEnumPackingTypeFieldUpdateOperationsInput | $Enums.PackingType | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnUpdateWithoutGrnInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseInvoice?: PurchaseInvoiceUpdateOneWithoutPurchaseReturnsNestedInput
    account?: AccountUpdateOneWithoutPurchaseReturnsNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseReturnsNestedInput
    items?: PurchaseReturnItemUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnUncheckedUpdateWithoutGrnInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseReturnItemUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnUncheckedUpdateManyWithoutGrnInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemCreateManyGrnItemInput = {
    id?: string
    invoiceId: string
    purchaseOrderItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutGrnItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
    purchaseOrderItem?: PurchaseOrderItemUpdateOneWithoutInvoiceItemsNestedInput
    itemMaster?: ItemMasterUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseInvoiceItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutGrnItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutGrnItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemCreateManyInvoiceInput = {
    id?: string
    purchaseOrderItemId?: string | null
    grnItemId?: string | null
    itemMasterId?: string | null
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    invoicedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnCreateManyPurchaseInvoiceInput = {
    id?: string
    returnNumber: string
    date?: Date | string
    remarks?: string | null
    grnId?: string | null
    accountId?: number | null
    totalAmount?: number
    status?: string
    companyId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrderItem?: PurchaseOrderItemUpdateOneWithoutInvoiceItemsNestedInput
    grnItem?: GRNItemUpdateOneWithoutInvoiceItemsNestedInput
    itemMaster?: ItemMasterUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseInvoiceItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseInvoiceItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseOrderItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: NullableStringFieldUpdateOperationsInput | string | null
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    invoicedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnUpdateWithoutPurchaseInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grn?: GRNUpdateOneWithoutPurchaseReturnsNestedInput
    account?: AccountUpdateOneWithoutPurchaseReturnsNestedInput
    company?: CompanyUpdateOneRequiredWithoutPurchaseReturnsNestedInput
    items?: PurchaseReturnItemUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnUncheckedUpdateWithoutPurchaseInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    grnId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseReturnItemUncheckedUpdateManyWithoutReturnNestedInput
  }

  export type PurchaseReturnUncheckedUpdateManyWithoutPurchaseInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    grnId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableIntFieldUpdateOperationsInput | number | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    companyId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemCreateManyReturnInput = {
    id?: string
    purchaseInvoiceItemId?: string | null
    grnItemId?: string | null
    itemMasterId: string
    colorId?: string | null
    brandId?: string | null
    itemGradeId?: string | null
    unitId?: number | null
    returnedQty: number
    rate: number
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnItemUpdateWithoutReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemMaster?: ItemMasterUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput
    color?: ColorUpdateOneWithoutPurchaseReturnItemsNestedInput
    brand?: BrandUpdateOneWithoutPurchaseReturnItemsNestedInput
    itemGrade?: ItemGradeUpdateOneWithoutPurchaseReturnItemsNestedInput
    unit?: UnitUpdateOneWithoutPurchaseReturnItemsNestedInput
  }

  export type PurchaseReturnItemUncheckedUpdateWithoutReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnItemUncheckedUpdateManyWithoutReturnInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseInvoiceItemId?: NullableStringFieldUpdateOperationsInput | string | null
    grnItemId?: NullableStringFieldUpdateOperationsInput | string | null
    itemMasterId?: StringFieldUpdateOperationsInput | string
    colorId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    itemGradeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableIntFieldUpdateOperationsInput | number | null
    returnedQty?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}